/* automatically generated by rust-bindgen */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
extern crate libc;

pub type __uid_t = ::libc::c_uint;
pub type va_list = __builtin_va_list;
pub type uid_t = __uid_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum boolean { B_FALSE = 0, B_TRUE = 1, }
pub use self::boolean as boolean_t;
pub type uint_t = ::libc::c_uint;
pub type ulong_t = ::libc::c_ulong;
pub type hrtime_t = ::libc::c_longlong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvlist {
    pub nvl_version: i32,
    pub nvl_nvflag: u32,
    pub nvl_priv: u64,
    pub nvl_flag: u32,
    pub nvl_pad: i32,
}
#[test]
fn bindgen_test_layout_nvlist() {
    assert_eq!(::core::mem::size_of::<nvlist>() , 24usize , concat ! (
               "Size of: " , stringify ! ( nvlist ) ));
    assert_eq! (::core::mem::align_of::<nvlist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nvlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvlist ) ) . nvl_version as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvlist ) , "::" ,
                stringify ! ( nvl_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvlist ) ) . nvl_nvflag as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvlist ) , "::" ,
                stringify ! ( nvl_nvflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvlist ) ) . nvl_priv as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvlist ) , "::" ,
                stringify ! ( nvl_priv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvlist ) ) . nvl_flag as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvlist ) , "::" ,
                stringify ! ( nvl_flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvlist ) ) . nvl_pad as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( nvlist ) , "::" ,
                stringify ! ( nvl_pad ) ));
}
impl Clone for nvlist {
    fn clone(&self) -> Self { *self }
}
pub type nvlist_t = nvlist;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nv_alloc_ops {
    pub nv_ao_init: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut nv_alloc_t,
                                                                arg2:
                                                                    *mut __va_list_tag)
                                               -> ::libc::c_int>,
    pub nv_ao_fini: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut nv_alloc_t)>,
    pub nv_ao_alloc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut nv_alloc_t,
                                                                 arg2: usize)
                                                -> *mut ::libc::c_void>,
    pub nv_ao_free: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut nv_alloc_t,
                                                                arg2:
                                                                    *mut ::libc::c_void,
                                                                arg3: usize)>,
    pub nv_ao_reset: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut nv_alloc_t)>,
}
#[test]
fn bindgen_test_layout_nv_alloc_ops() {
    assert_eq!(::core::mem::size_of::<nv_alloc_ops>() , 40usize , concat ! (
               "Size of: " , stringify ! ( nv_alloc_ops ) ));
    assert_eq! (::core::mem::align_of::<nv_alloc_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nv_alloc_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nv_alloc_ops ) ) . nv_ao_init as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nv_alloc_ops ) , "::" ,
                stringify ! ( nv_ao_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nv_alloc_ops ) ) . nv_ao_fini as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nv_alloc_ops ) , "::" ,
                stringify ! ( nv_ao_fini ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nv_alloc_ops ) ) . nv_ao_alloc as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nv_alloc_ops ) , "::" ,
                stringify ! ( nv_ao_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nv_alloc_ops ) ) . nv_ao_free as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nv_alloc_ops ) , "::" ,
                stringify ! ( nv_ao_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nv_alloc_ops ) ) . nv_ao_reset as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nv_alloc_ops ) , "::" ,
                stringify ! ( nv_ao_reset ) ));
}
impl Clone for nv_alloc_ops {
    fn clone(&self) -> Self { *self }
}
pub type nv_alloc_ops_t = nv_alloc_ops;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nv_alloc {
    pub nva_ops: *const nv_alloc_ops_t,
    pub nva_arg: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_nv_alloc() {
    assert_eq!(::core::mem::size_of::<nv_alloc>() , 16usize , concat ! (
               "Size of: " , stringify ! ( nv_alloc ) ));
    assert_eq! (::core::mem::align_of::<nv_alloc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nv_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nv_alloc ) ) . nva_ops as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nv_alloc ) , "::" ,
                stringify ! ( nva_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nv_alloc ) ) . nva_arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nv_alloc ) , "::" ,
                stringify ! ( nva_arg ) ));
}
impl Clone for nv_alloc {
    fn clone(&self) -> Self { *self }
}
pub type nv_alloc_t = nv_alloc;
extern "C" {
    #[link_name = "nv_fixed_ops"]
    pub static mut nv_fixed_ops: *const nv_alloc_ops_t;
}
extern "C" {
    #[link_name = "nv_alloc_nosleep"]
    pub static mut nv_alloc_nosleep: *mut nv_alloc_t;
}
extern "C" {
    pub fn nv_alloc_init(arg1: *mut nv_alloc_t,
                         arg2: *const nv_alloc_ops_t, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn nv_alloc_reset(arg1: *mut nv_alloc_t);
}
extern "C" {
    pub fn nv_alloc_fini(arg1: *mut nv_alloc_t);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mnttab {
    pub mnt_special: *mut ::libc::c_char,
    pub mnt_mountp: *mut ::libc::c_char,
    pub mnt_fstype: *mut ::libc::c_char,
    pub mnt_mntopts: *mut ::libc::c_char,
}
#[test]
fn bindgen_test_layout_mnttab() {
    assert_eq!(::core::mem::size_of::<mnttab>() , 32usize , concat ! (
               "Size of: " , stringify ! ( mnttab ) ));
    assert_eq! (::core::mem::align_of::<mnttab>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mnttab ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mnttab ) ) . mnt_special as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mnttab ) , "::" ,
                stringify ! ( mnt_special ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mnttab ) ) . mnt_mountp as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mnttab ) , "::" ,
                stringify ! ( mnt_mountp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mnttab ) ) . mnt_fstype as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mnttab ) , "::" ,
                stringify ! ( mnt_fstype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mnttab ) ) . mnt_mntopts as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mnttab ) , "::" ,
                stringify ! ( mnt_mntopts ) ));
}
impl Clone for mnttab {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_type_t {
    ZFS_TYPE_FILESYSTEM = 1,
    ZFS_TYPE_SNAPSHOT = 2,
    ZFS_TYPE_VOLUME = 4,
    ZFS_TYPE_POOL = 8,
    ZFS_TYPE_BOOKMARK = 16,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_prop_t {
    ZFS_PROP_BAD = -1,
    ZFS_PROP_TYPE = 0,
    ZFS_PROP_CREATION = 1,
    ZFS_PROP_USED = 2,
    ZFS_PROP_AVAILABLE = 3,
    ZFS_PROP_REFERENCED = 4,
    ZFS_PROP_COMPRESSRATIO = 5,
    ZFS_PROP_MOUNTED = 6,
    ZFS_PROP_ORIGIN = 7,
    ZFS_PROP_QUOTA = 8,
    ZFS_PROP_RESERVATION = 9,
    ZFS_PROP_VOLSIZE = 10,
    ZFS_PROP_VOLBLOCKSIZE = 11,
    ZFS_PROP_RECORDSIZE = 12,
    ZFS_PROP_MOUNTPOINT = 13,
    ZFS_PROP_SHARENFS = 14,
    ZFS_PROP_CHECKSUM = 15,
    ZFS_PROP_COMPRESSION = 16,
    ZFS_PROP_ATIME = 17,
    ZFS_PROP_DEVICES = 18,
    ZFS_PROP_EXEC = 19,
    ZFS_PROP_SETUID = 20,
    ZFS_PROP_READONLY = 21,
    ZFS_PROP_ZONED = 22,
    ZFS_PROP_SNAPDIR = 23,
    ZFS_PROP_PRIVATE = 24,
    ZFS_PROP_ACLINHERIT = 25,
    ZFS_PROP_CREATETXG = 26,
    ZFS_PROP_NAME = 27,
    ZFS_PROP_CANMOUNT = 28,
    ZFS_PROP_ISCSIOPTIONS = 29,
    ZFS_PROP_XATTR = 30,
    ZFS_PROP_NUMCLONES = 31,
    ZFS_PROP_COPIES = 32,
    ZFS_PROP_VERSION = 33,
    ZFS_PROP_UTF8ONLY = 34,
    ZFS_PROP_NORMALIZE = 35,
    ZFS_PROP_CASE = 36,
    ZFS_PROP_VSCAN = 37,
    ZFS_PROP_NBMAND = 38,
    ZFS_PROP_SHARESMB = 39,
    ZFS_PROP_REFQUOTA = 40,
    ZFS_PROP_REFRESERVATION = 41,
    ZFS_PROP_GUID = 42,
    ZFS_PROP_PRIMARYCACHE = 43,
    ZFS_PROP_SECONDARYCACHE = 44,
    ZFS_PROP_USEDSNAP = 45,
    ZFS_PROP_USEDDS = 46,
    ZFS_PROP_USEDCHILD = 47,
    ZFS_PROP_USEDREFRESERV = 48,
    ZFS_PROP_USERACCOUNTING = 49,
    ZFS_PROP_STMF_SHAREINFO = 50,
    ZFS_PROP_DEFER_DESTROY = 51,
    ZFS_PROP_USERREFS = 52,
    ZFS_PROP_LOGBIAS = 53,
    ZFS_PROP_UNIQUE = 54,
    ZFS_PROP_OBJSETID = 55,
    ZFS_PROP_DEDUP = 56,
    ZFS_PROP_MLSLABEL = 57,
    ZFS_PROP_SYNC = 58,
    ZFS_PROP_DNODESIZE = 59,
    ZFS_PROP_REFRATIO = 60,
    ZFS_PROP_WRITTEN = 61,
    ZFS_PROP_CLONES = 62,
    ZFS_PROP_LOGICALUSED = 63,
    ZFS_PROP_LOGICALREFERENCED = 64,
    ZFS_PROP_INCONSISTENT = 65,
    ZFS_PROP_VOLMODE = 66,
    ZFS_PROP_FILESYSTEM_LIMIT = 67,
    ZFS_PROP_SNAPSHOT_LIMIT = 68,
    ZFS_PROP_FILESYSTEM_COUNT = 69,
    ZFS_PROP_SNAPSHOT_COUNT = 70,
    ZFS_PROP_SNAPDEV = 71,
    ZFS_PROP_ACLTYPE = 72,
    ZFS_PROP_SELINUX_CONTEXT = 73,
    ZFS_PROP_SELINUX_FSCONTEXT = 74,
    ZFS_PROP_SELINUX_DEFCONTEXT = 75,
    ZFS_PROP_SELINUX_ROOTCONTEXT = 76,
    ZFS_PROP_RELATIME = 77,
    ZFS_PROP_REDUNDANT_METADATA = 78,
    ZFS_PROP_OVERLAY = 79,
    ZFS_PROP_PREV_SNAP = 80,
    ZFS_PROP_RECEIVE_RESUME_TOKEN = 81,
    ZFS_NUM_PROPS = 82,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_userquota_prop_t {
    ZFS_PROP_USERUSED = 0,
    ZFS_PROP_USERQUOTA = 1,
    ZFS_PROP_GROUPUSED = 2,
    ZFS_PROP_GROUPQUOTA = 3,
    ZFS_PROP_USEROBJUSED = 4,
    ZFS_PROP_USEROBJQUOTA = 5,
    ZFS_PROP_GROUPOBJUSED = 6,
    ZFS_PROP_GROUPOBJQUOTA = 7,
    ZFS_NUM_USERQUOTA_PROPS = 8,
}
extern "C" {
    #[link_name = "zfs_userquota_prop_prefixes"]
    pub static mut zfs_userquota_prop_prefixes:
               [*const ::libc::c_char; 8usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zpool_prop_t {
    ZPOOL_PROP_NAME = 0,
    ZPOOL_PROP_SIZE = 1,
    ZPOOL_PROP_CAPACITY = 2,
    ZPOOL_PROP_ALTROOT = 3,
    ZPOOL_PROP_HEALTH = 4,
    ZPOOL_PROP_GUID = 5,
    ZPOOL_PROP_VERSION = 6,
    ZPOOL_PROP_BOOTFS = 7,
    ZPOOL_PROP_DELEGATION = 8,
    ZPOOL_PROP_AUTOREPLACE = 9,
    ZPOOL_PROP_CACHEFILE = 10,
    ZPOOL_PROP_FAILUREMODE = 11,
    ZPOOL_PROP_LISTSNAPS = 12,
    ZPOOL_PROP_AUTOEXPAND = 13,
    ZPOOL_PROP_DEDUPDITTO = 14,
    ZPOOL_PROP_DEDUPRATIO = 15,
    ZPOOL_PROP_FREE = 16,
    ZPOOL_PROP_ALLOCATED = 17,
    ZPOOL_PROP_READONLY = 18,
    ZPOOL_PROP_ASHIFT = 19,
    ZPOOL_PROP_COMMENT = 20,
    ZPOOL_PROP_EXPANDSZ = 21,
    ZPOOL_PROP_FREEING = 22,
    ZPOOL_PROP_FRAGMENTATION = 23,
    ZPOOL_PROP_LEAKED = 24,
    ZPOOL_PROP_MAXBLOCKSIZE = 25,
    ZPOOL_PROP_TNAME = 26,
    ZPOOL_PROP_MAXDNODESIZE = 27,
    ZPOOL_PROP_MULTIHOST = 28,
    ZPOOL_NUM_PROPS = 29,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zprop_source_t {
    ZPROP_SRC_NONE = 1,
    ZPROP_SRC_DEFAULT = 2,
    ZPROP_SRC_TEMPORARY = 4,
    ZPROP_SRC_LOCAL = 8,
    ZPROP_SRC_INHERITED = 16,
    ZPROP_SRC_RECEIVED = 32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zprop_errflags_t { ZPROP_ERR_NOCLEAR = 1, ZPROP_ERR_NORESTORE = 2, }
pub type zprop_func =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int,
                                                arg2: *mut ::libc::c_void)
                               -> ::libc::c_int>;
extern "C" {
    pub fn zfs_prop_default_string(arg1: zfs_prop_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_prop_default_numeric(arg1: zfs_prop_t) -> u64;
}
extern "C" {
    pub fn zfs_prop_readonly(arg1: zfs_prop_t) -> boolean_t;
}
extern "C" {
    pub fn zfs_prop_inheritable(arg1: zfs_prop_t) -> boolean_t;
}
extern "C" {
    pub fn zfs_prop_setonce(arg1: zfs_prop_t) -> boolean_t;
}
extern "C" {
    pub fn zfs_prop_to_name(arg1: zfs_prop_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_name_to_prop(arg1: *const ::libc::c_char) -> zfs_prop_t;
}
extern "C" {
    pub fn zfs_prop_user(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_prop_userquota(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_prop_written(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_prop_index_to_string(arg1: zfs_prop_t, arg2: u64,
                                    arg3: *mut *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_string_to_index(arg1: zfs_prop_t,
                                    arg2: *const ::libc::c_char,
                                    arg3: *mut u64) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_random_value(arg1: zfs_prop_t, seed: u64) -> u64;
}
extern "C" {
    pub fn zfs_prop_valid_for_type(arg1: ::libc::c_int, arg2: zfs_type_t,
                                   arg3: boolean_t) -> boolean_t;
}
extern "C" {
    pub fn zpool_name_to_prop(arg1: *const ::libc::c_char) -> zpool_prop_t;
}
extern "C" {
    pub fn zpool_prop_to_name(arg1: zpool_prop_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zpool_prop_default_string(arg1: zpool_prop_t)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn zpool_prop_default_numeric(arg1: zpool_prop_t) -> u64;
}
extern "C" {
    pub fn zpool_prop_readonly(arg1: zpool_prop_t) -> boolean_t;
}
extern "C" {
    pub fn zpool_prop_feature(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zpool_prop_unsupported(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zpool_prop_index_to_string(arg1: zpool_prop_t, arg2: u64,
                                      arg3: *mut *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_prop_string_to_index(arg1: zpool_prop_t,
                                      arg2: *const ::libc::c_char,
                                      arg3: *mut u64) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_prop_random_value(arg1: zpool_prop_t, seed: u64) -> u64;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_deleg_who_type_t {
    ZFS_DELEG_WHO_UNKNOWN = 0,
    ZFS_DELEG_USER = 117,
    ZFS_DELEG_USER_SETS = 85,
    ZFS_DELEG_GROUP = 103,
    ZFS_DELEG_GROUP_SETS = 71,
    ZFS_DELEG_EVERYONE = 101,
    ZFS_DELEG_EVERYONE_SETS = 69,
    ZFS_DELEG_CREATE = 99,
    ZFS_DELEG_CREATE_SETS = 67,
    ZFS_DELEG_NAMED_SET = 115,
    ZFS_DELEG_NAMED_SET_SETS = 83,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_deleg_inherit_t {
    ZFS_DELEG_NONE = 0,
    ZFS_DELEG_PERM_LOCAL = 1,
    ZFS_DELEG_PERM_DESCENDENT = 2,
    ZFS_DELEG_PERM_LOCALDESCENDENT = 3,
    ZFS_DELEG_PERM_CREATE = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_canmount_type_t {
    ZFS_CANMOUNT_OFF = 0,
    ZFS_CANMOUNT_ON = 1,
    ZFS_CANMOUNT_NOAUTO = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_logbias_op_t {
    ZFS_LOGBIAS_LATENCY = 0,
    ZFS_LOGBIAS_THROUGHPUT = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_share_op {
    ZFS_SHARE_NFS = 0,
    ZFS_UNSHARE_NFS = 1,
    ZFS_SHARE_SMB = 2,
    ZFS_UNSHARE_SMB = 3,
}
pub use self::zfs_share_op as zfs_share_op_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_smb_acl_op {
    ZFS_SMB_ACL_ADD = 0,
    ZFS_SMB_ACL_REMOVE = 1,
    ZFS_SMB_ACL_RENAME = 2,
    ZFS_SMB_ACL_PURGE = 3,
}
pub use self::zfs_smb_acl_op as zfs_smb_acl_op_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_cache_type {
    ZFS_CACHE_NONE = 0,
    ZFS_CACHE_METADATA = 1,
    ZFS_CACHE_ALL = 2,
}
pub use self::zfs_cache_type as zfs_cache_type_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_sync_type_t {
    ZFS_SYNC_STANDARD = 0,
    ZFS_SYNC_ALWAYS = 1,
    ZFS_SYNC_DISABLED = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_xattr_type_t {
    ZFS_XATTR_OFF = 0,
    ZFS_XATTR_DIR = 1,
    ZFS_XATTR_SA = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_dnsize_type_t {
    ZFS_DNSIZE_LEGACY = 0,
    ZFS_DNSIZE_AUTO = 1,
    ZFS_DNSIZE_1K = 1024,
    ZFS_DNSIZE_2K = 2048,
    ZFS_DNSIZE_4K = 4096,
    ZFS_DNSIZE_8K = 8192,
    ZFS_DNSIZE_16K = 16384,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_redundant_metadata_type_t {
    ZFS_REDUNDANT_METADATA_ALL = 0,
    ZFS_REDUNDANT_METADATA_MOST = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_volmode_t {
    ZFS_VOLMODE_DEFAULT = 0,
    ZFS_VOLMODE_GEOM = 1,
    ZFS_VOLMODE_DEV = 2,
    ZFS_VOLMODE_NONE = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct zpool_rewind_policy {
    pub zrp_request: u32,
    pub zrp_maxmeta: u64,
    pub zrp_maxdata: u64,
    pub zrp_txg: u64,
}
#[test]
fn bindgen_test_layout_zpool_rewind_policy() {
    assert_eq!(::core::mem::size_of::<zpool_rewind_policy>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( zpool_rewind_policy )
               ));
    assert_eq! (::core::mem::align_of::<zpool_rewind_policy>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( zpool_rewind_policy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_rewind_policy ) ) . zrp_request as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_rewind_policy ) ,
                "::" , stringify ! ( zrp_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_rewind_policy ) ) . zrp_maxmeta as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_rewind_policy ) ,
                "::" , stringify ! ( zrp_maxmeta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_rewind_policy ) ) . zrp_maxdata as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_rewind_policy ) ,
                "::" , stringify ! ( zrp_maxdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_rewind_policy ) ) . zrp_txg as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_rewind_policy ) ,
                "::" , stringify ! ( zrp_txg ) ));
}
impl Clone for zpool_rewind_policy {
    fn clone(&self) -> Self { *self }
}
pub type zpool_rewind_policy_t = zpool_rewind_policy;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vdev_state {
    VDEV_STATE_UNKNOWN = 0,
    VDEV_STATE_CLOSED = 1,
    VDEV_STATE_OFFLINE = 2,
    VDEV_STATE_REMOVED = 3,
    VDEV_STATE_CANT_OPEN = 4,
    VDEV_STATE_FAULTED = 5,
    VDEV_STATE_DEGRADED = 6,
    VDEV_STATE_HEALTHY = 7,
}
pub use self::vdev_state as vdev_state_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vdev_aux {
    VDEV_AUX_NONE = 0,
    VDEV_AUX_OPEN_FAILED = 1,
    VDEV_AUX_CORRUPT_DATA = 2,
    VDEV_AUX_NO_REPLICAS = 3,
    VDEV_AUX_BAD_GUID_SUM = 4,
    VDEV_AUX_TOO_SMALL = 5,
    VDEV_AUX_BAD_LABEL = 6,
    VDEV_AUX_VERSION_NEWER = 7,
    VDEV_AUX_VERSION_OLDER = 8,
    VDEV_AUX_UNSUP_FEAT = 9,
    VDEV_AUX_SPARED = 10,
    VDEV_AUX_ERR_EXCEEDED = 11,
    VDEV_AUX_IO_FAILURE = 12,
    VDEV_AUX_BAD_LOG = 13,
    VDEV_AUX_EXTERNAL = 14,
    VDEV_AUX_SPLIT_POOL = 15,
    VDEV_AUX_BAD_ASHIFT = 16,
    VDEV_AUX_EXTERNAL_PERSIST = 17,
    VDEV_AUX_ACTIVE = 18,
}
pub use self::vdev_aux as vdev_aux_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pool_state {
    POOL_STATE_ACTIVE = 0,
    POOL_STATE_EXPORTED = 1,
    POOL_STATE_DESTROYED = 2,
    POOL_STATE_SPARE = 3,
    POOL_STATE_L2CACHE = 4,
    POOL_STATE_UNINITIALIZED = 5,
    POOL_STATE_UNAVAIL = 6,
    POOL_STATE_POTENTIALLY_ACTIVE = 7,
}
pub use self::pool_state as pool_state_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pool_scan_func {
    POOL_SCAN_NONE = 0,
    POOL_SCAN_SCRUB = 1,
    POOL_SCAN_RESILVER = 2,
    POOL_SCAN_FUNCS = 3,
}
pub use self::pool_scan_func as pool_scan_func_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pool_scrub_cmd {
    POOL_SCRUB_NORMAL = 0,
    POOL_SCRUB_PAUSE = 1,
    POOL_SCRUB_FLAGS_END = 2,
}
pub use self::pool_scrub_cmd as pool_scrub_cmd_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zpool_errata {
    ZPOOL_ERRATA_NONE = 0,
    ZPOOL_ERRATA_ZOL_2094_SCRUB = 1,
    ZPOOL_ERRATA_ZOL_2094_ASYNC_DESTROY = 2,
}
pub use self::zpool_errata as zpool_errata_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vdev_stat {
    pub vs_timestamp: hrtime_t,
    pub vs_state: u64,
    pub vs_aux: u64,
    pub vs_alloc: u64,
    pub vs_space: u64,
    pub vs_dspace: u64,
    pub vs_rsize: u64,
    pub vs_esize: u64,
    pub vs_ops: [u64; 6usize],
    pub vs_bytes: [u64; 6usize],
    pub vs_read_errors: u64,
    pub vs_write_errors: u64,
    pub vs_checksum_errors: u64,
    pub vs_self_healed: u64,
    pub vs_scan_removing: u64,
    pub vs_scan_processed: u64,
    pub vs_fragmentation: u64,
}
#[test]
fn bindgen_test_layout_vdev_stat() {
    assert_eq!(::core::mem::size_of::<vdev_stat>() , 216usize , concat ! (
               "Size of: " , stringify ! ( vdev_stat ) ));
    assert_eq! (::core::mem::align_of::<vdev_stat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vdev_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_timestamp as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_aux as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_aux ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_alloc as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_space as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_dspace as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_dspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_rsize as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_rsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_esize as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_esize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_ops as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_bytes as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_read_errors as * const
                _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_read_errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_write_errors as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_write_errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_checksum_errors as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_checksum_errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_self_healed as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_self_healed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_scan_removing as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_scan_removing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_scan_processed as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_scan_processed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_fragmentation as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_fragmentation ) ));
}
impl Clone for vdev_stat {
    fn clone(&self) -> Self { *self }
}
pub type vdev_stat_t = vdev_stat;
#[repr(C)]
#[derive(Copy)]
pub struct vdev_stat_ex {
    pub vsx_active_queue: [u64; 5usize],
    pub vsx_pend_queue: [u64; 5usize],
    pub vsx_queue_histo: [[u64; 37usize]; 5usize],
    pub vsx_total_histo: [[u64; 37usize]; 6usize],
    pub vsx_disk_histo: [[u64; 37usize]; 6usize],
    pub vsx_ind_histo: [[u64; 25usize]; 5usize],
    pub vsx_agg_histo: [[u64; 25usize]; 5usize],
}
#[test]
fn bindgen_test_layout_vdev_stat_ex() {
    assert_eq!(::core::mem::size_of::<vdev_stat_ex>() , 7112usize , concat ! (
               "Size of: " , stringify ! ( vdev_stat_ex ) ));
    assert_eq! (::core::mem::align_of::<vdev_stat_ex>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vdev_stat_ex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat_ex ) ) . vsx_active_queue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat_ex ) , "::" ,
                stringify ! ( vsx_active_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat_ex ) ) . vsx_pend_queue as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat_ex ) , "::" ,
                stringify ! ( vsx_pend_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat_ex ) ) . vsx_queue_histo as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat_ex ) , "::" ,
                stringify ! ( vsx_queue_histo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat_ex ) ) . vsx_total_histo as *
                const _ as usize } , 1560usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat_ex ) , "::" ,
                stringify ! ( vsx_total_histo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat_ex ) ) . vsx_disk_histo as *
                const _ as usize } , 3336usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat_ex ) , "::" ,
                stringify ! ( vsx_disk_histo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat_ex ) ) . vsx_ind_histo as *
                const _ as usize } , 5112usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat_ex ) , "::" ,
                stringify ! ( vsx_ind_histo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat_ex ) ) . vsx_agg_histo as *
                const _ as usize } , 6112usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat_ex ) , "::" ,
                stringify ! ( vsx_agg_histo ) ));
}
impl Clone for vdev_stat_ex {
    fn clone(&self) -> Self { *self }
}
pub type vdev_stat_ex_t = vdev_stat_ex;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ddt_stat {
    pub dds_blocks: u64,
    pub dds_lsize: u64,
    pub dds_psize: u64,
    pub dds_dsize: u64,
    pub dds_ref_blocks: u64,
    pub dds_ref_lsize: u64,
    pub dds_ref_psize: u64,
    pub dds_ref_dsize: u64,
}
#[test]
fn bindgen_test_layout_ddt_stat() {
    assert_eq!(::core::mem::size_of::<ddt_stat>() , 64usize , concat ! (
               "Size of: " , stringify ! ( ddt_stat ) ));
    assert_eq! (::core::mem::align_of::<ddt_stat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ddt_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_blocks as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_blocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_lsize as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_lsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_psize as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_psize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_dsize as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_dsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_ref_blocks as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_ref_blocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_ref_lsize as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_ref_lsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_ref_psize as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_ref_psize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_ref_dsize as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_ref_dsize ) ));
}
impl Clone for ddt_stat {
    fn clone(&self) -> Self { *self }
}
pub type ddt_stat_t = ddt_stat;
#[repr(C)]
#[derive(Copy)]
pub struct ddt_histogram {
    pub ddh_stat: [ddt_stat_t; 64usize],
}
#[test]
fn bindgen_test_layout_ddt_histogram() {
    assert_eq!(::core::mem::size_of::<ddt_histogram>() , 4096usize , concat !
               ( "Size of: " , stringify ! ( ddt_histogram ) ));
    assert_eq! (::core::mem::align_of::<ddt_histogram>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ddt_histogram ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_histogram ) ) . ddh_stat as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_histogram ) , "::"
                , stringify ! ( ddh_stat ) ));
}
impl Clone for ddt_histogram {
    fn clone(&self) -> Self { *self }
}
pub type ddt_histogram_t = ddt_histogram;
pub const zfs_ioc_ZFS_IOC: zfs_ioc = zfs_ioc::ZFS_IOC_FIRST;
pub const zfs_ioc_ZFS_IOC_POOL_CREATE: zfs_ioc = zfs_ioc::ZFS_IOC_FIRST;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_ioc {
    ZFS_IOC_FIRST = 23040,
    ZFS_IOC_POOL_DESTROY = 23041,
    ZFS_IOC_POOL_IMPORT = 23042,
    ZFS_IOC_POOL_EXPORT = 23043,
    ZFS_IOC_POOL_CONFIGS = 23044,
    ZFS_IOC_POOL_STATS = 23045,
    ZFS_IOC_POOL_TRYIMPORT = 23046,
    ZFS_IOC_POOL_SCAN = 23047,
    ZFS_IOC_POOL_FREEZE = 23048,
    ZFS_IOC_POOL_UPGRADE = 23049,
    ZFS_IOC_POOL_GET_HISTORY = 23050,
    ZFS_IOC_VDEV_ADD = 23051,
    ZFS_IOC_VDEV_REMOVE = 23052,
    ZFS_IOC_VDEV_SET_STATE = 23053,
    ZFS_IOC_VDEV_ATTACH = 23054,
    ZFS_IOC_VDEV_DETACH = 23055,
    ZFS_IOC_VDEV_SETPATH = 23056,
    ZFS_IOC_VDEV_SETFRU = 23057,
    ZFS_IOC_OBJSET_STATS = 23058,
    ZFS_IOC_OBJSET_ZPLPROPS = 23059,
    ZFS_IOC_DATASET_LIST_NEXT = 23060,
    ZFS_IOC_SNAPSHOT_LIST_NEXT = 23061,
    ZFS_IOC_SET_PROP = 23062,
    ZFS_IOC_CREATE = 23063,
    ZFS_IOC_DESTROY = 23064,
    ZFS_IOC_ROLLBACK = 23065,
    ZFS_IOC_RENAME = 23066,
    ZFS_IOC_RECV = 23067,
    ZFS_IOC_SEND = 23068,
    ZFS_IOC_INJECT_FAULT = 23069,
    ZFS_IOC_CLEAR_FAULT = 23070,
    ZFS_IOC_INJECT_LIST_NEXT = 23071,
    ZFS_IOC_ERROR_LOG = 23072,
    ZFS_IOC_CLEAR = 23073,
    ZFS_IOC_PROMOTE = 23074,
    ZFS_IOC_SNAPSHOT = 23075,
    ZFS_IOC_DSOBJ_TO_DSNAME = 23076,
    ZFS_IOC_OBJ_TO_PATH = 23077,
    ZFS_IOC_POOL_SET_PROPS = 23078,
    ZFS_IOC_POOL_GET_PROPS = 23079,
    ZFS_IOC_SET_FSACL = 23080,
    ZFS_IOC_GET_FSACL = 23081,
    ZFS_IOC_SHARE = 23082,
    ZFS_IOC_INHERIT_PROP = 23083,
    ZFS_IOC_SMB_ACL = 23084,
    ZFS_IOC_USERSPACE_ONE = 23085,
    ZFS_IOC_USERSPACE_MANY = 23086,
    ZFS_IOC_USERSPACE_UPGRADE = 23087,
    ZFS_IOC_HOLD = 23088,
    ZFS_IOC_RELEASE = 23089,
    ZFS_IOC_GET_HOLDS = 23090,
    ZFS_IOC_OBJSET_RECVD_PROPS = 23091,
    ZFS_IOC_VDEV_SPLIT = 23092,
    ZFS_IOC_NEXT_OBJ = 23093,
    ZFS_IOC_DIFF = 23094,
    ZFS_IOC_TMP_SNAPSHOT = 23095,
    ZFS_IOC_OBJ_TO_STATS = 23096,
    ZFS_IOC_SPACE_WRITTEN = 23097,
    ZFS_IOC_SPACE_SNAPS = 23098,
    ZFS_IOC_DESTROY_SNAPS = 23099,
    ZFS_IOC_POOL_REGUID = 23100,
    ZFS_IOC_POOL_REOPEN = 23101,
    ZFS_IOC_SEND_PROGRESS = 23102,
    ZFS_IOC_LOG_HISTORY = 23103,
    ZFS_IOC_SEND_NEW = 23104,
    ZFS_IOC_SEND_SPACE = 23105,
    ZFS_IOC_CLONE = 23106,
    ZFS_IOC_BOOKMARK = 23107,
    ZFS_IOC_GET_BOOKMARKS = 23108,
    ZFS_IOC_DESTROY_BOOKMARKS = 23109,
    ZFS_IOC_RECV_NEW = 23110,
    ZFS_IOC_POOL_SYNC = 23111,
    ZFS_IOC_LINUX = 23168,
    ZFS_IOC_EVENTS_NEXT = 23169,
    ZFS_IOC_EVENTS_CLEAR = 23170,
    ZFS_IOC_EVENTS_SEEK = 23171,
    ZFS_IOC_FREEBSD = 23232,
    ZFS_IOC_LAST = 23233,
}
pub use self::zfs_ioc as zfs_ioc_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avl_node {
    pub avl_child: [*mut avl_node; 2usize],
    pub avl_pcb: usize,
}
#[test]
fn bindgen_test_layout_avl_node() {
    assert_eq!(::core::mem::size_of::<avl_node>() , 24usize , concat ! (
               "Size of: " , stringify ! ( avl_node ) ));
    assert_eq! (::core::mem::align_of::<avl_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( avl_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avl_node ) ) . avl_child as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avl_node ) , "::" ,
                stringify ! ( avl_child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avl_node ) ) . avl_pcb as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( avl_node ) , "::" ,
                stringify ! ( avl_pcb ) ));
}
impl Clone for avl_node {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avl_tree {
    pub avl_root: *mut avl_node,
    pub avl_compar: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::libc::c_void,
                                                                arg2:
                                                                    *const ::libc::c_void)
                                               -> ::libc::c_int>,
    pub avl_offset: usize,
    pub avl_numnodes: ulong_t,
    pub avl_size: usize,
}
#[test]
fn bindgen_test_layout_avl_tree() {
    assert_eq!(::core::mem::size_of::<avl_tree>() , 40usize , concat ! (
               "Size of: " , stringify ! ( avl_tree ) ));
    assert_eq! (::core::mem::align_of::<avl_tree>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( avl_tree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avl_tree ) ) . avl_root as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avl_tree ) , "::" ,
                stringify ! ( avl_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avl_tree ) ) . avl_compar as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avl_tree ) , "::" ,
                stringify ! ( avl_compar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avl_tree ) ) . avl_offset as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( avl_tree ) , "::" ,
                stringify ! ( avl_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avl_tree ) ) . avl_numnodes as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( avl_tree ) , "::" ,
                stringify ! ( avl_numnodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avl_tree ) ) . avl_size as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( avl_tree ) , "::" ,
                stringify ! ( avl_size ) ));
}
impl Clone for avl_tree {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn avl_walk(arg1: *mut avl_tree, arg2: *mut ::libc::c_void,
                    arg3: ::libc::c_int) -> *mut ::libc::c_void;
}
pub type avl_tree_t = avl_tree;
pub type avl_node_t = avl_node;
pub type avl_index_t = usize;
extern "C" {
    pub fn avl_create(tree: *mut avl_tree_t,
                      compar:
                          ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                          *const ::libc::c_void,
                                                                      arg2:
                                                                          *const ::libc::c_void)
                                                     -> ::libc::c_int>,
                      size: usize, offset: usize);
}
extern "C" {
    pub fn avl_find(tree: *mut avl_tree_t, node: *const ::libc::c_void,
                    where_: *mut avl_index_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn avl_insert(tree: *mut avl_tree_t, node: *mut ::libc::c_void,
                      where_: avl_index_t);
}
extern "C" {
    pub fn avl_insert_here(tree: *mut avl_tree_t,
                           new_data: *mut ::libc::c_void,
                           here: *mut ::libc::c_void,
                           direction: ::libc::c_int);
}
extern "C" {
    pub fn avl_first(tree: *mut avl_tree_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn avl_last(tree: *mut avl_tree_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn avl_nearest(tree: *mut avl_tree_t, where_: avl_index_t,
                       direction: ::libc::c_int) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn avl_add(tree: *mut avl_tree_t, node: *mut ::libc::c_void);
}
extern "C" {
    pub fn avl_remove(tree: *mut avl_tree_t, node: *mut ::libc::c_void);
}
extern "C" {
    pub fn avl_update(arg1: *mut avl_tree_t, arg2: *mut ::libc::c_void)
     -> boolean_t;
}
extern "C" {
    pub fn avl_update_lt(arg1: *mut avl_tree_t, arg2: *mut ::libc::c_void)
     -> boolean_t;
}
extern "C" {
    pub fn avl_update_gt(arg1: *mut avl_tree_t, arg2: *mut ::libc::c_void)
     -> boolean_t;
}
extern "C" {
    pub fn avl_swap(tree1: *mut avl_tree_t, tree2: *mut avl_tree_t);
}
extern "C" {
    pub fn avl_numnodes(tree: *mut avl_tree_t) -> ulong_t;
}
extern "C" {
    pub fn avl_is_empty(tree: *mut avl_tree_t) -> boolean_t;
}
extern "C" {
    pub fn avl_destroy_nodes(tree: *mut avl_tree_t,
                             cookie: *mut *mut ::libc::c_void)
     -> *mut ::libc::c_void;
}
extern "C" {
    pub fn avl_destroy(tree: *mut avl_tree_t);
}
extern "C" {
    pub fn libzfs_core_init() -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_core_fini();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lzc_dataset_type {
    LZC_DATSET_TYPE_ZFS = 2,
    LZC_DATSET_TYPE_ZVOL = 3,
}
extern "C" {
    pub fn lzc_snapshot(arg1: *mut nvlist_t, arg2: *mut nvlist_t,
                        arg3: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_create(arg1: *const ::libc::c_char, arg2: lzc_dataset_type,
                      arg3: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_clone(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                     arg3: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_promote(arg1: *const ::libc::c_char, arg2: *mut ::libc::c_char,
                       arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_destroy_snaps(arg1: *mut nvlist_t, arg2: boolean_t,
                             arg3: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_bookmark(arg1: *mut nvlist_t, arg2: *mut *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_get_bookmarks(arg1: *const ::libc::c_char, arg2: *mut nvlist_t,
                             arg3: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_destroy_bookmarks(arg1: *mut nvlist_t,
                                 arg2: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_snaprange_space(arg1: *const ::libc::c_char,
                               arg2: *const ::libc::c_char, arg3: *mut u64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_hold(arg1: *mut nvlist_t, arg2: ::libc::c_int,
                    arg3: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_release(arg1: *mut nvlist_t, arg2: *mut *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_get_holds(arg1: *const ::libc::c_char,
                         arg2: *mut *mut nvlist_t) -> ::libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lzc_send_flags {
    LZC_SEND_FLAG_EMBED_DATA = 1,
    LZC_SEND_FLAG_LARGE_BLOCK = 2,
    LZC_SEND_FLAG_COMPRESS = 4,
}
extern "C" {
    pub fn lzc_send(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                    arg3: ::libc::c_int, arg4: lzc_send_flags)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_send_resume(arg1: *const ::libc::c_char,
                           arg2: *const ::libc::c_char, arg3: ::libc::c_int,
                           arg4: lzc_send_flags, arg5: u64, arg6: u64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_send_space(arg1: *const ::libc::c_char,
                          arg2: *const ::libc::c_char, arg3: lzc_send_flags,
                          arg4: *mut u64) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dmu_replay_record {
    _unused: [u8; 0],
}
extern "C" {
    pub fn lzc_receive(arg1: *const ::libc::c_char, arg2: *mut nvlist_t,
                       arg3: *const ::libc::c_char, arg4: boolean_t,
                       arg5: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_receive_resumable(arg1: *const ::libc::c_char,
                                 arg2: *mut nvlist_t,
                                 arg3: *const ::libc::c_char, arg4: boolean_t,
                                 arg5: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_receive_with_header(arg1: *const ::libc::c_char,
                                   arg2: *mut nvlist_t,
                                   arg3: *const ::libc::c_char,
                                   arg4: boolean_t, arg5: boolean_t,
                                   arg6: ::libc::c_int,
                                   arg7: *const dmu_replay_record)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_receive_one(arg1: *const ::libc::c_char, arg2: *mut nvlist_t,
                           arg3: *const ::libc::c_char, arg4: boolean_t,
                           arg5: boolean_t, arg6: ::libc::c_int,
                           arg7: *const dmu_replay_record,
                           arg8: ::libc::c_int, arg9: *mut u64,
                           arg10: *mut u64, arg11: *mut u64,
                           arg12: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_receive_with_cmdprops(arg1: *const ::libc::c_char,
                                     arg2: *mut nvlist_t, arg3: *mut nvlist_t,
                                     arg4: *const ::libc::c_char,
                                     arg5: boolean_t, arg6: boolean_t,
                                     arg7: ::libc::c_int,
                                     arg8: *const dmu_replay_record,
                                     arg9: ::libc::c_int, arg10: *mut u64,
                                     arg11: *mut u64, arg12: *mut u64,
                                     arg13: *mut *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_exists(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn lzc_rollback(arg1: *const ::libc::c_char,
                        arg2: *mut ::libc::c_char, arg3: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_rollback_to(arg1: *const ::libc::c_char,
                           arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_sync(arg1: *const ::libc::c_char, arg2: *mut nvlist_t,
                    arg3: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "zpool_default_import_path"]
    pub static mut zpool_default_import_path: [*mut ::libc::c_char; 9usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_error {
    EZFS_SUCCESS = 0,
    EZFS_NOMEM = 2000,
    EZFS_BADPROP = 2001,
    EZFS_PROPREADONLY = 2002,
    EZFS_PROPTYPE = 2003,
    EZFS_PROPNONINHERIT = 2004,
    EZFS_PROPSPACE = 2005,
    EZFS_BADTYPE = 2006,
    EZFS_BUSY = 2007,
    EZFS_EXISTS = 2008,
    EZFS_NOENT = 2009,
    EZFS_BADSTREAM = 2010,
    EZFS_DSREADONLY = 2011,
    EZFS_VOLTOOBIG = 2012,
    EZFS_INVALIDNAME = 2013,
    EZFS_BADRESTORE = 2014,
    EZFS_BADBACKUP = 2015,
    EZFS_BADTARGET = 2016,
    EZFS_NODEVICE = 2017,
    EZFS_BADDEV = 2018,
    EZFS_NOREPLICAS = 2019,
    EZFS_RESILVERING = 2020,
    EZFS_BADVERSION = 2021,
    EZFS_POOLUNAVAIL = 2022,
    EZFS_DEVOVERFLOW = 2023,
    EZFS_BADPATH = 2024,
    EZFS_CROSSTARGET = 2025,
    EZFS_ZONED = 2026,
    EZFS_MOUNTFAILED = 2027,
    EZFS_UMOUNTFAILED = 2028,
    EZFS_UNSHARENFSFAILED = 2029,
    EZFS_SHARENFSFAILED = 2030,
    EZFS_PERM = 2031,
    EZFS_NOSPC = 2032,
    EZFS_FAULT = 2033,
    EZFS_IO = 2034,
    EZFS_INTR = 2035,
    EZFS_ISSPARE = 2036,
    EZFS_INVALCONFIG = 2037,
    EZFS_RECURSIVE = 2038,
    EZFS_NOHISTORY = 2039,
    EZFS_POOLPROPS = 2040,
    EZFS_POOL_NOTSUP = 2041,
    EZFS_POOL_INVALARG = 2042,
    EZFS_NAMETOOLONG = 2043,
    EZFS_OPENFAILED = 2044,
    EZFS_NOCAP = 2045,
    EZFS_LABELFAILED = 2046,
    EZFS_BADWHO = 2047,
    EZFS_BADPERM = 2048,
    EZFS_BADPERMSET = 2049,
    EZFS_NODELEGATION = 2050,
    EZFS_UNSHARESMBFAILED = 2051,
    EZFS_SHARESMBFAILED = 2052,
    EZFS_BADCACHE = 2053,
    EZFS_ISL2CACHE = 2054,
    EZFS_VDEVNOTSUP = 2055,
    EZFS_NOTSUP = 2056,
    EZFS_ACTIVE_SPARE = 2057,
    EZFS_UNPLAYED_LOGS = 2058,
    EZFS_REFTAG_RELE = 2059,
    EZFS_REFTAG_HOLD = 2060,
    EZFS_TAGTOOLONG = 2061,
    EZFS_PIPEFAILED = 2062,
    EZFS_THREADCREATEFAILED = 2063,
    EZFS_POSTSPLIT_ONLINE = 2064,
    EZFS_SCRUBBING = 2065,
    EZFS_NO_SCRUB = 2066,
    EZFS_DIFF = 2067,
    EZFS_DIFFDATA = 2068,
    EZFS_POOLREADONLY = 2069,
    EZFS_SCRUB_PAUSED = 2070,
    EZFS_ACTIVE_POOL = 2071,
    EZFS_UNKNOWN = 2072,
}
pub use self::zfs_error as zfs_error_t;
#[repr(C)]
#[derive(Copy)]
pub struct zfs_perm_node {
    pub z_node: avl_node_t,
    pub z_pname: [::libc::c_char; 4096usize],
}
#[test]
fn bindgen_test_layout_zfs_perm_node() {
    assert_eq!(::core::mem::size_of::<zfs_perm_node>() , 4120usize , concat !
               ( "Size of: " , stringify ! ( zfs_perm_node ) ));
    assert_eq! (::core::mem::align_of::<zfs_perm_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( zfs_perm_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_perm_node ) ) . z_node as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_perm_node ) , "::"
                , stringify ! ( z_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_perm_node ) ) . z_pname as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_perm_node ) , "::"
                , stringify ! ( z_pname ) ));
}
impl Clone for zfs_perm_node {
    fn clone(&self) -> Self { *self }
}
pub type zfs_perm_node_t = zfs_perm_node;
#[repr(C)]
#[derive(Copy)]
pub struct zfs_allow_node {
    pub z_node: avl_node_t,
    pub z_key: [::libc::c_char; 4096usize],
    pub z_localdescend: avl_tree_t,
    pub z_local: avl_tree_t,
    pub z_descend: avl_tree_t,
}
#[test]
fn bindgen_test_layout_zfs_allow_node() {
    assert_eq!(::core::mem::size_of::<zfs_allow_node>() , 4240usize , concat !
               ( "Size of: " , stringify ! ( zfs_allow_node ) ));
    assert_eq! (::core::mem::align_of::<zfs_allow_node>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( zfs_allow_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow_node ) ) . z_node as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow_node ) , "::"
                , stringify ! ( z_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow_node ) ) . z_key as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow_node ) , "::"
                , stringify ! ( z_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow_node ) ) . z_localdescend as *
                const _ as usize } , 4120usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow_node ) , "::"
                , stringify ! ( z_localdescend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow_node ) ) . z_local as * const _
                as usize } , 4160usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow_node ) , "::"
                , stringify ! ( z_local ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow_node ) ) . z_descend as * const
                _ as usize } , 4200usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow_node ) , "::"
                , stringify ! ( z_descend ) ));
}
impl Clone for zfs_allow_node {
    fn clone(&self) -> Self { *self }
}
pub type zfs_allow_node_t = zfs_allow_node;
#[repr(C)]
#[derive(Copy)]
pub struct zfs_allow {
    pub z_next: *mut zfs_allow,
    pub z_setpoint: [::libc::c_char; 4096usize],
    pub z_sets: avl_tree_t,
    pub z_crperms: avl_tree_t,
    pub z_user: avl_tree_t,
    pub z_group: avl_tree_t,
    pub z_everyone: avl_tree_t,
}
#[test]
fn bindgen_test_layout_zfs_allow() {
    assert_eq!(::core::mem::size_of::<zfs_allow>() , 4304usize , concat ! (
               "Size of: " , stringify ! ( zfs_allow ) ));
    assert_eq! (::core::mem::align_of::<zfs_allow>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( zfs_allow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow ) ) . z_next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow ) , "::" ,
                stringify ! ( z_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow ) ) . z_setpoint as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow ) , "::" ,
                stringify ! ( z_setpoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow ) ) . z_sets as * const _ as
                usize } , 4104usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow ) , "::" ,
                stringify ! ( z_sets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow ) ) . z_crperms as * const _ as
                usize } , 4144usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow ) , "::" ,
                stringify ! ( z_crperms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow ) ) . z_user as * const _ as
                usize } , 4184usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow ) , "::" ,
                stringify ! ( z_user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow ) ) . z_group as * const _ as
                usize } , 4224usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow ) , "::" ,
                stringify ! ( z_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow ) ) . z_everyone as * const _
                as usize } , 4264usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow ) , "::" ,
                stringify ! ( z_everyone ) ));
}
impl Clone for zfs_allow {
    fn clone(&self) -> Self { *self }
}
pub type zfs_allow_t = zfs_allow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zfs_handle {
    _unused: [u8; 0],
}
pub type zfs_handle_t = zfs_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zpool_handle {
    _unused: [u8; 0],
}
pub type zpool_handle_t = zpool_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libzfs_handle {
    _unused: [u8; 0],
}
pub type libzfs_handle_t = libzfs_handle;
extern "C" {
    pub fn libzfs_init() -> *mut libzfs_handle_t;
}
extern "C" {
    pub fn libzfs_fini(arg1: *mut libzfs_handle_t);
}
extern "C" {
    pub fn zpool_get_handle(arg1: *mut zpool_handle_t)
     -> *mut libzfs_handle_t;
}
extern "C" {
    pub fn zfs_get_handle(arg1: *mut zfs_handle_t) -> *mut libzfs_handle_t;
}
extern "C" {
    pub fn libzfs_print_on_error(arg1: *mut libzfs_handle_t, arg2: boolean_t);
}
extern "C" {
    pub fn zfs_save_arguments(argc: ::libc::c_int,
                              arg1: *mut *mut ::libc::c_char,
                              arg2: *mut ::libc::c_char, arg3: ::libc::c_int);
}
extern "C" {
    pub fn zpool_log_history(arg1: *mut libzfs_handle_t,
                             arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_errno(arg1: *mut libzfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_error_init(arg1: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn libzfs_error_action(arg1: *mut libzfs_handle_t)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn libzfs_error_description(arg1: *mut libzfs_handle_t)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_standard_error(arg1: *mut libzfs_handle_t, arg2: ::libc::c_int,
                              arg3: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_mnttab_init(arg1: *mut libzfs_handle_t);
}
extern "C" {
    pub fn libzfs_mnttab_fini(arg1: *mut libzfs_handle_t);
}
extern "C" {
    pub fn libzfs_mnttab_cache(arg1: *mut libzfs_handle_t, arg2: boolean_t);
}
extern "C" {
    pub fn libzfs_mnttab_find(arg1: *mut libzfs_handle_t,
                              arg2: *const ::libc::c_char, arg3: *mut mnttab)
     -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_mnttab_add(arg1: *mut libzfs_handle_t,
                             arg2: *const ::libc::c_char,
                             arg3: *const ::libc::c_char,
                             arg4: *const ::libc::c_char);
}
extern "C" {
    pub fn libzfs_mnttab_remove(arg1: *mut libzfs_handle_t,
                                arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn zpool_open(arg1: *mut libzfs_handle_t, arg2: *const ::libc::c_char)
     -> *mut zpool_handle_t;
}
extern "C" {
    pub fn zpool_open_canfail(arg1: *mut libzfs_handle_t,
                              arg2: *const ::libc::c_char)
     -> *mut zpool_handle_t;
}
extern "C" {
    pub fn zpool_close(arg1: *mut zpool_handle_t);
}
extern "C" {
    pub fn zpool_get_name(arg1: *mut zpool_handle_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zpool_get_state(arg1: *mut zpool_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_state_to_name(arg1: vdev_state_t, arg2: vdev_aux_t)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn zpool_pool_state_to_name(arg1: pool_state_t)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn zpool_free_handles(arg1: *mut libzfs_handle_t);
}
pub type zpool_iter_f =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut zpool_handle_t,
                                                arg2: *mut ::libc::c_void)
                               -> ::libc::c_int>;
extern "C" {
    pub fn zpool_iter(arg1: *mut libzfs_handle_t, arg2: zpool_iter_f,
                      arg3: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_skip_pool(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zpool_create(arg1: *mut libzfs_handle_t,
                        arg2: *const ::libc::c_char, arg3: *mut nvlist_t,
                        arg4: *mut nvlist_t, arg5: *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_destroy(arg1: *mut zpool_handle_t,
                         arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_add(arg1: *mut zpool_handle_t, arg2: *mut nvlist_t)
     -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct splitflags {
    pub _bitfield_1: u8,
    pub name_flags: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_splitflags() {
    assert_eq!(::core::mem::size_of::<splitflags>() , 8usize , concat ! (
               "Size of: " , stringify ! ( splitflags ) ));
    assert_eq! (::core::mem::align_of::<splitflags>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( splitflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const splitflags ) ) . name_flags as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( splitflags ) , "::" ,
                stringify ! ( name_flags ) ));
}
impl Clone for splitflags {
    fn clone(&self) -> Self { *self }
}
impl splitflags {
    #[inline]
    pub fn dryrun(&self) -> ::libc::c_int {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_dryrun(&mut self, val: ::libc::c_int) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn import(&self) -> ::libc::c_int {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_import(&mut self, val: ::libc::c_int) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(dryrun: ::libc::c_int, import: ::libc::c_int)
     -> u8 {
        ({ ({ 0 } | ((dryrun as u32 as u8) << 0usize) & (1u64 as u8)) } |
             ((import as u32 as u8) << 1usize) & (2u64 as u8))
    }
}
pub type splitflags_t = splitflags;
extern "C" {
    pub fn zpool_scan(arg1: *mut zpool_handle_t, arg2: pool_scan_func_t,
                      arg3: pool_scrub_cmd_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_clear(arg1: *mut zpool_handle_t, arg2: *const ::libc::c_char,
                       arg3: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_reguid(arg1: *mut zpool_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_reopen(arg1: *mut zpool_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_sync_one(arg1: *mut zpool_handle_t,
                          arg2: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_online(arg1: *mut zpool_handle_t,
                             arg2: *const ::libc::c_char, arg3: ::libc::c_int,
                             arg4: *mut vdev_state_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_offline(arg1: *mut zpool_handle_t,
                              arg2: *const ::libc::c_char, arg3: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_attach(arg1: *mut zpool_handle_t,
                             arg2: *const ::libc::c_char,
                             arg3: *const ::libc::c_char, arg4: *mut nvlist_t,
                             arg5: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_detach(arg1: *mut zpool_handle_t,
                             arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_remove(arg1: *mut zpool_handle_t,
                             arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_split(arg1: *mut zpool_handle_t,
                            arg2: *mut ::libc::c_char,
                            arg3: *mut *mut nvlist_t, arg4: *mut nvlist_t,
                            arg5: splitflags_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_fault(arg1: *mut zpool_handle_t, arg2: u64,
                            arg3: vdev_aux_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_degrade(arg1: *mut zpool_handle_t, arg2: u64,
                              arg3: vdev_aux_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_clear(arg1: *mut zpool_handle_t, arg2: u64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_find_vdev(arg1: *mut zpool_handle_t,
                           arg2: *const ::libc::c_char, arg3: *mut boolean_t,
                           arg4: *mut boolean_t, arg5: *mut boolean_t)
     -> *mut nvlist_t;
}
extern "C" {
    pub fn zpool_find_vdev_by_physpath(arg1: *mut zpool_handle_t,
                                       arg2: *const ::libc::c_char,
                                       arg3: *mut boolean_t,
                                       arg4: *mut boolean_t,
                                       arg5: *mut boolean_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn zpool_label_disk_wait(arg1: *mut ::libc::c_char,
                                 arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_label_disk(arg1: *mut libzfs_handle_t,
                            arg2: *mut zpool_handle_t,
                            arg3: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_path_to_guid(zhp: *mut zpool_handle_t,
                                   path: *const ::libc::c_char) -> u64;
}
extern "C" {
    pub fn zfs_dev_is_dm(dev_name: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_dev_is_whole_disk(dev_name: *mut ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_get_underlying_path(dev_name: *mut ::libc::c_char)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn zfs_get_enclosure_sysfs_path(dev_name: *mut ::libc::c_char)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn zpool_set_prop(arg1: *mut zpool_handle_t,
                          arg2: *const ::libc::c_char,
                          arg3: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_get_prop(arg1: *mut zpool_handle_t, arg2: zpool_prop_t,
                          arg3: *mut ::libc::c_char, proplen: usize,
                          arg4: *mut zprop_source_t, literal: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_get_prop_int(arg1: *mut zpool_handle_t, arg2: zpool_prop_t,
                              arg3: *mut zprop_source_t) -> u64;
}
extern "C" {
    pub fn zpool_prop_values(arg1: zpool_prop_t) -> *const ::libc::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zpool_status_t {
    ZPOOL_STATUS_CORRUPT_CACHE = 0,
    ZPOOL_STATUS_MISSING_DEV_R = 1,
    ZPOOL_STATUS_MISSING_DEV_NR = 2,
    ZPOOL_STATUS_CORRUPT_LABEL_R = 3,
    ZPOOL_STATUS_CORRUPT_LABEL_NR = 4,
    ZPOOL_STATUS_BAD_GUID_SUM = 5,
    ZPOOL_STATUS_CORRUPT_POOL = 6,
    ZPOOL_STATUS_CORRUPT_DATA = 7,
    ZPOOL_STATUS_FAILING_DEV = 8,
    ZPOOL_STATUS_VERSION_NEWER = 9,
    ZPOOL_STATUS_HOSTID_MISMATCH = 10,
    ZPOOL_STATUS_HOSTID_ACTIVE = 11,
    ZPOOL_STATUS_HOSTID_REQUIRED = 12,
    ZPOOL_STATUS_IO_FAILURE_WAIT = 13,
    ZPOOL_STATUS_IO_FAILURE_CONTINUE = 14,
    ZPOOL_STATUS_BAD_LOG = 15,
    ZPOOL_STATUS_ERRATA = 16,
    ZPOOL_STATUS_UNSUP_FEAT_READ = 17,
    ZPOOL_STATUS_UNSUP_FEAT_WRITE = 18,
    ZPOOL_STATUS_FAULTED_DEV_R = 19,
    ZPOOL_STATUS_FAULTED_DEV_NR = 20,
    ZPOOL_STATUS_VERSION_OLDER = 21,
    ZPOOL_STATUS_FEAT_DISABLED = 22,
    ZPOOL_STATUS_RESILVERING = 23,
    ZPOOL_STATUS_OFFLINE_DEV = 24,
    ZPOOL_STATUS_REMOVED_DEV = 25,
    ZPOOL_STATUS_OK = 26,
}
extern "C" {
    pub fn zpool_get_status(arg1: *mut zpool_handle_t,
                            arg2: *mut *mut ::libc::c_char,
                            arg3: *mut zpool_errata_t) -> zpool_status_t;
}
extern "C" {
    pub fn zpool_import_status(arg1: *mut nvlist_t,
                               arg2: *mut *mut ::libc::c_char,
                               arg3: *mut zpool_errata_t) -> zpool_status_t;
}
extern "C" {
    pub fn zpool_dump_ddt(dds: *const ddt_stat_t,
                          ddh: *const ddt_histogram_t);
}
extern "C" {
    pub fn zpool_get_config(arg1: *mut zpool_handle_t,
                            arg2: *mut *mut nvlist_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn zpool_get_features(arg1: *mut zpool_handle_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn zpool_refresh_stats(arg1: *mut zpool_handle_t,
                               arg2: *mut boolean_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_get_errlog(arg1: *mut zpool_handle_t,
                            arg2: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_export(arg1: *mut zpool_handle_t, arg2: boolean_t,
                        arg3: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_export_force(arg1: *mut zpool_handle_t,
                              arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_import(arg1: *mut libzfs_handle_t, arg2: *mut nvlist_t,
                        arg3: *const ::libc::c_char,
                        altroot: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_import_props(arg1: *mut libzfs_handle_t, arg2: *mut nvlist_t,
                              arg3: *const ::libc::c_char,
                              arg4: *mut nvlist_t, arg5: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_print_unsup_feat(config: *mut nvlist_t);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct importargs {
    pub path: *mut *mut ::libc::c_char,
    pub paths: ::libc::c_int,
    pub poolname: *mut ::libc::c_char,
    pub guid: u64,
    pub cachefile: *mut ::libc::c_char,
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_importargs() {
    assert_eq!(::core::mem::size_of::<importargs>() , 48usize , concat ! (
               "Size of: " , stringify ! ( importargs ) ));
    assert_eq! (::core::mem::align_of::<importargs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( importargs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const importargs ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( importargs ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const importargs ) ) . paths as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( importargs ) , "::" ,
                stringify ! ( paths ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const importargs ) ) . poolname as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( importargs ) , "::" ,
                stringify ! ( poolname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const importargs ) ) . guid as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( importargs ) , "::" ,
                stringify ! ( guid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const importargs ) ) . cachefile as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( importargs ) , "::" ,
                stringify ! ( cachefile ) ));
}
impl Clone for importargs {
    fn clone(&self) -> Self { *self }
}
impl importargs {
    #[inline]
    pub fn can_be_active(&self) -> ::libc::c_int {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_can_be_active(&mut self, val: ::libc::c_int) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn unique(&self) -> ::libc::c_int {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_unique(&mut self, val: ::libc::c_int) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn exists(&self) -> ::libc::c_int {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_exists(&mut self, val: ::libc::c_int) {
        let mask = 4u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn scan(&self) -> ::libc::c_int {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_scan(&mut self, val: ::libc::c_int) {
        let mask = 8u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(can_be_active: ::libc::c_int, unique: ::libc::c_int,
                          exists: ::libc::c_int, scan: ::libc::c_int) -> u8 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((can_be_active as u32 as u8) << 0usize) &
                                (1u64 as u8))
                   } | ((unique as u32 as u8) << 1usize) & (2u64 as u8))
              } | ((exists as u32 as u8) << 2usize) & (4u64 as u8))
         } | ((scan as u32 as u8) << 3usize) & (8u64 as u8))
    }
}
pub type importargs_t = importargs;
extern "C" {
    pub fn zpool_search_import(arg1: *mut libzfs_handle_t,
                               arg2: *mut importargs_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn zpool_tryimport(hdl: *mut libzfs_handle_t,
                           target: *mut ::libc::c_char,
                           configp: *mut *mut nvlist_t,
                           args: *mut importargs_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_find_import(arg1: *mut libzfs_handle_t, arg2: ::libc::c_int,
                             arg3: *mut *mut ::libc::c_char) -> *mut nvlist_t;
}
extern "C" {
    pub fn zpool_find_import_cached(arg1: *mut libzfs_handle_t,
                                    arg2: *const ::libc::c_char,
                                    arg3: *mut ::libc::c_char, arg4: u64)
     -> *mut nvlist_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zfs_cmd {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "zfs_history_event_names"]
    pub static mut zfs_history_event_names: [*const ::libc::c_char; 0usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vdev_name_t {
    VDEV_NAME_PATH = 1,
    VDEV_NAME_GUID = 2,
    VDEV_NAME_FOLLOW_LINKS = 4,
    VDEV_NAME_TYPE_ID = 8,
}
extern "C" {
    pub fn zpool_vdev_name(arg1: *mut libzfs_handle_t,
                           arg2: *mut zpool_handle_t, arg3: *mut nvlist_t,
                           name_flags: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn zpool_upgrade(arg1: *mut zpool_handle_t, arg2: u64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_get_history(arg1: *mut zpool_handle_t,
                             arg2: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_history_unpack(arg1: *mut ::libc::c_char, arg2: u64,
                                arg3: *mut u64, arg4: *mut *mut *mut nvlist_t,
                                arg5: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_events_next(arg1: *mut libzfs_handle_t,
                             arg2: *mut *mut nvlist_t,
                             arg3: *mut ::libc::c_int, arg4: ::libc::c_uint,
                             arg5: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_events_clear(arg1: *mut libzfs_handle_t,
                              arg2: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_events_seek(arg1: *mut libzfs_handle_t, arg2: u64,
                             arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_obj_to_path(arg1: *mut zpool_handle_t, arg2: u64, arg3: u64,
                             arg4: *mut ::libc::c_char, len: usize);
}
extern "C" {
    pub fn zfs_ioctl(arg1: *mut libzfs_handle_t, arg2: ::libc::c_int,
                     arg3: *mut zfs_cmd) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_get_physpath(arg1: *mut zpool_handle_t,
                              arg2: *mut ::libc::c_char, arg3: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_explain_recover(arg1: *mut libzfs_handle_t,
                                 arg2: *const ::libc::c_char,
                                 arg3: ::libc::c_int, arg4: *mut nvlist_t);
}
extern "C" {
    pub fn zfs_open(arg1: *mut libzfs_handle_t, arg2: *const ::libc::c_char,
                    arg3: ::libc::c_int) -> *mut zfs_handle_t;
}
extern "C" {
    pub fn zfs_handle_dup(arg1: *mut zfs_handle_t) -> *mut zfs_handle_t;
}
extern "C" {
    pub fn zfs_close(arg1: *mut zfs_handle_t);
}
extern "C" {
    pub fn zfs_get_type(arg1: *const zfs_handle_t) -> zfs_type_t;
}
extern "C" {
    pub fn zfs_get_name(arg1: *const zfs_handle_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_get_pool_handle(arg1: *const zfs_handle_t)
     -> *mut zpool_handle_t;
}
extern "C" {
    pub fn zfs_get_pool_name(arg1: *const zfs_handle_t)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_prop_column_name(arg1: zfs_prop_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_prop_align_right(arg1: zfs_prop_t) -> boolean_t;
}
extern "C" {
    pub fn zfs_valid_proplist(arg1: *mut libzfs_handle_t, arg2: zfs_type_t,
                              arg3: *mut nvlist_t, arg4: u64,
                              arg5: *mut zfs_handle_t,
                              arg6: *mut zpool_handle_t,
                              arg7: *const ::libc::c_char) -> *mut nvlist_t;
}
extern "C" {
    pub fn zfs_prop_set(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                        arg3: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_set_list(arg1: *mut zfs_handle_t, arg2: *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get(arg1: *mut zfs_handle_t, arg2: zfs_prop_t,
                        arg3: *mut ::libc::c_char, arg4: usize,
                        arg5: *mut zprop_source_t, arg6: *mut ::libc::c_char,
                        arg7: usize, arg8: boolean_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_recvd(arg1: *mut zfs_handle_t,
                              arg2: *const ::libc::c_char,
                              arg3: *mut ::libc::c_char, arg4: usize,
                              arg5: boolean_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_numeric(arg1: *mut zfs_handle_t, arg2: zfs_prop_t,
                                arg3: *mut u64, arg4: *mut zprop_source_t,
                                arg5: *mut ::libc::c_char, arg6: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_userquota_int(zhp: *mut zfs_handle_t,
                                      propname: *const ::libc::c_char,
                                      propvalue: *mut u64) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_userquota(zhp: *mut zfs_handle_t,
                                  propname: *const ::libc::c_char,
                                  propbuf: *mut ::libc::c_char,
                                  proplen: ::libc::c_int, literal: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_written_int(zhp: *mut zfs_handle_t,
                                    propname: *const ::libc::c_char,
                                    propvalue: *mut u64) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_written(zhp: *mut zfs_handle_t,
                                propname: *const ::libc::c_char,
                                propbuf: *mut ::libc::c_char,
                                proplen: ::libc::c_int, literal: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_feature(zhp: *mut zfs_handle_t,
                                propname: *const ::libc::c_char,
                                buf: *mut ::libc::c_char, len: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_int(arg1: *mut zfs_handle_t, arg2: zfs_prop_t) -> u64;
}
extern "C" {
    pub fn zfs_prop_inherit(arg1: *mut zfs_handle_t,
                            arg2: *const ::libc::c_char, arg3: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_values(arg1: zfs_prop_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_prop_is_string(prop: zfs_prop_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_get_user_props(arg1: *mut zfs_handle_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn zfs_get_recvd_props(arg1: *mut zfs_handle_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn zfs_get_clones_nvl(arg1: *mut zfs_handle_t) -> *mut nvlist_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct zprop_list {
    pub pl_prop: ::libc::c_int,
    pub pl_user_prop: *mut ::libc::c_char,
    pub pl_next: *mut zprop_list,
    pub pl_all: boolean_t,
    pub pl_width: usize,
    pub pl_recvd_width: usize,
    pub pl_fixed: boolean_t,
}
#[test]
fn bindgen_test_layout_zprop_list() {
    assert_eq!(::core::mem::size_of::<zprop_list>() , 56usize , concat ! (
               "Size of: " , stringify ! ( zprop_list ) ));
    assert_eq! (::core::mem::align_of::<zprop_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( zprop_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_prop as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_prop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_user_prop as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_user_prop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_next as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_all as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_all ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_width as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_recvd_width as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_recvd_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_fixed as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_fixed ) ));
}
impl Clone for zprop_list {
    fn clone(&self) -> Self { *self }
}
pub type zprop_list_t = zprop_list;
extern "C" {
    pub fn zfs_expand_proplist(arg1: *mut zfs_handle_t,
                               arg2: *mut *mut zprop_list_t, arg3: boolean_t,
                               arg4: boolean_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prune_proplist(arg1: *mut zfs_handle_t, arg2: *mut u8);
}
extern "C" {
    pub fn zpool_expand_proplist(arg1: *mut zpool_handle_t,
                                 arg2: *mut *mut zprop_list_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_prop_get_feature(arg1: *mut zpool_handle_t,
                                  arg2: *const ::libc::c_char,
                                  arg3: *mut ::libc::c_char, arg4: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_prop_column_name(arg1: zpool_prop_t)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn zpool_prop_align_right(arg1: zpool_prop_t) -> boolean_t;
}
extern "C" {
    pub fn zprop_iter(func: zprop_func, cb: *mut ::libc::c_void,
                      show_all: boolean_t, ordered: boolean_t,
                      type_: zfs_type_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zprop_get_list(arg1: *mut libzfs_handle_t,
                          arg2: *mut ::libc::c_char,
                          arg3: *mut *mut zprop_list_t, arg4: zfs_type_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zprop_free_list(arg1: *mut zprop_list_t);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_get_column_t {
    GET_COL_NONE = 0,
    GET_COL_NAME = 1,
    GET_COL_PROPERTY = 2,
    GET_COL_VALUE = 3,
    GET_COL_RECVD = 4,
    GET_COL_SOURCE = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct zprop_get_cbdata {
    pub cb_sources: ::libc::c_int,
    pub cb_columns: [zfs_get_column_t; 5usize],
    pub cb_colwidths: [::libc::c_int; 6usize],
    pub cb_scripted: boolean_t,
    pub cb_literal: boolean_t,
    pub cb_first: boolean_t,
    pub cb_proplist: *mut zprop_list_t,
    pub cb_type: zfs_type_t,
}
#[test]
fn bindgen_test_layout_zprop_get_cbdata() {
    assert_eq!(::core::mem::size_of::<zprop_get_cbdata>() , 80usize , concat !
               ( "Size of: " , stringify ! ( zprop_get_cbdata ) ));
    assert_eq! (::core::mem::align_of::<zprop_get_cbdata>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( zprop_get_cbdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_sources as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_sources ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_columns as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_columns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_colwidths as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_colwidths ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_scripted as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_scripted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_literal as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_literal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_first as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_proplist as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_proplist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_type as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_type ) ));
}
impl Clone for zprop_get_cbdata {
    fn clone(&self) -> Self { *self }
}
pub type zprop_get_cbdata_t = zprop_get_cbdata;
extern "C" {
    pub fn zprop_print_one_property(arg1: *const ::libc::c_char,
                                    arg2: *mut zprop_get_cbdata_t,
                                    arg3: *const ::libc::c_char,
                                    arg4: *const ::libc::c_char,
                                    arg5: zprop_source_t,
                                    arg6: *const ::libc::c_char,
                                    arg7: *const ::libc::c_char);
}
pub type zfs_iter_f =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut zfs_handle_t,
                                                arg2: *mut ::libc::c_void)
                               -> ::libc::c_int>;
extern "C" {
    pub fn zfs_iter_root(arg1: *mut libzfs_handle_t, arg2: zfs_iter_f,
                         arg3: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_iter_children(arg1: *mut zfs_handle_t, arg2: zfs_iter_f,
                             arg3: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_iter_dependents(arg1: *mut zfs_handle_t, arg2: boolean_t,
                               arg3: zfs_iter_f, arg4: *mut ::libc::c_void)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_iter_filesystems(arg1: *mut zfs_handle_t, arg2: zfs_iter_f,
                                arg3: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_iter_snapshots(arg1: *mut zfs_handle_t, arg2: boolean_t,
                              arg3: zfs_iter_f, arg4: *mut ::libc::c_void)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_iter_snapshots_sorted(arg1: *mut zfs_handle_t,
                                     arg2: zfs_iter_f,
                                     arg3: *mut ::libc::c_void)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_iter_snapspec(arg1: *mut zfs_handle_t,
                             arg2: *const ::libc::c_char, arg3: zfs_iter_f,
                             arg4: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_iter_bookmarks(arg1: *mut zfs_handle_t, arg2: zfs_iter_f,
                              arg3: *mut ::libc::c_void) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct get_all_cb {
    pub cb_handles: *mut *mut zfs_handle_t,
    pub cb_alloc: usize,
    pub cb_used: usize,
    pub cb_verbose: boolean_t,
    pub cb_getone: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut zfs_handle_t,
                                                               arg2:
                                                                   *mut ::libc::c_void)
                                              -> ::libc::c_int>,
}
#[test]
fn bindgen_test_layout_get_all_cb() {
    assert_eq!(::core::mem::size_of::<get_all_cb>() , 40usize , concat ! (
               "Size of: " , stringify ! ( get_all_cb ) ));
    assert_eq! (::core::mem::align_of::<get_all_cb>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( get_all_cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const get_all_cb ) ) . cb_handles as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( get_all_cb ) , "::" ,
                stringify ! ( cb_handles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const get_all_cb ) ) . cb_alloc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( get_all_cb ) , "::" ,
                stringify ! ( cb_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const get_all_cb ) ) . cb_used as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( get_all_cb ) , "::" ,
                stringify ! ( cb_used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const get_all_cb ) ) . cb_verbose as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( get_all_cb ) , "::" ,
                stringify ! ( cb_verbose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const get_all_cb ) ) . cb_getone as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( get_all_cb ) , "::" ,
                stringify ! ( cb_getone ) ));
}
impl Clone for get_all_cb {
    fn clone(&self) -> Self { *self }
}
pub type get_all_cb_t = get_all_cb;
extern "C" {
    pub fn libzfs_add_handle(arg1: *mut get_all_cb_t,
                             arg2: *mut zfs_handle_t);
}
extern "C" {
    pub fn libzfs_dataset_cmp(arg1: *const ::libc::c_void,
                              arg2: *const ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_create(arg1: *mut libzfs_handle_t, arg2: *const ::libc::c_char,
                      arg3: zfs_type_t, arg4: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_create_ancestors(arg1: *mut libzfs_handle_t,
                                arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_destroy(arg1: *mut zfs_handle_t, arg2: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_destroy_snaps(arg1: *mut zfs_handle_t,
                             arg2: *mut ::libc::c_char, arg3: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_destroy_snaps_nvl(arg1: *mut libzfs_handle_t,
                                 arg2: *mut nvlist_t, arg3: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_clone(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                     arg3: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_snapshot(arg1: *mut libzfs_handle_t,
                        arg2: *const ::libc::c_char, arg3: boolean_t,
                        arg4: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_snapshot_nvl(hdl: *mut libzfs_handle_t, snaps: *mut nvlist_t,
                            props: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_rollback(arg1: *mut zfs_handle_t, arg2: *mut zfs_handle_t,
                        arg3: boolean_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_rename(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                      arg3: boolean_t, arg4: boolean_t) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sendflags {
    pub verbose: boolean_t,
    pub replicate: boolean_t,
    pub doall: boolean_t,
    pub fromorigin: boolean_t,
    pub dedup: boolean_t,
    pub props: boolean_t,
    pub dryrun: boolean_t,
    pub parsable: boolean_t,
    pub progress: boolean_t,
    pub largeblock: boolean_t,
    pub embed_data: boolean_t,
    pub compress: boolean_t,
}
#[test]
fn bindgen_test_layout_sendflags() {
    assert_eq!(::core::mem::size_of::<sendflags>() , 48usize , concat ! (
               "Size of: " , stringify ! ( sendflags ) ));
    assert_eq! (::core::mem::align_of::<sendflags>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sendflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . verbose as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( verbose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . replicate as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( replicate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . doall as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( doall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . fromorigin as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( fromorigin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . dedup as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( dedup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . props as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( props ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . dryrun as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( dryrun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . parsable as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( parsable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . progress as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( progress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . largeblock as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( largeblock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . embed_data as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( embed_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . compress as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( compress ) ));
}
impl Clone for sendflags {
    fn clone(&self) -> Self { *self }
}
pub type sendflags_t = sendflags;
pub type snapfilter_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut zfs_handle_t,
                                                arg2: *mut ::libc::c_void)
                               -> boolean_t>;
extern "C" {
    pub fn zfs_send(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                    arg3: *const ::libc::c_char, arg4: *mut sendflags_t,
                    arg5: ::libc::c_int, arg6: snapfilter_cb_t,
                    arg7: *mut ::libc::c_void, arg8: *mut *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_send_one(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                        arg3: ::libc::c_int, arg4: lzc_send_flags)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_send_resume(arg1: *mut libzfs_handle_t, arg2: *mut sendflags_t,
                           outfd: ::libc::c_int, arg3: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_send_resume_token_to_nvlist(hdl: *mut libzfs_handle_t,
                                           token: *const ::libc::c_char)
     -> *mut nvlist_t;
}
extern "C" {
    pub fn zfs_promote(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_hold(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                    arg3: *const ::libc::c_char, arg4: boolean_t,
                    arg5: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_hold_nvl(arg1: *mut zfs_handle_t, arg2: ::libc::c_int,
                        arg3: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_release(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                       arg3: *const ::libc::c_char, arg4: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_get_holds(arg1: *mut zfs_handle_t, arg2: *mut *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zvol_volsize_to_reservation(arg1: u64, arg2: *mut nvlist_t) -> u64;
}
pub type zfs_userspace_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::libc::c_void,
                                                domain: *const ::libc::c_char,
                                                rid: uid_t, space: u64)
                               -> ::libc::c_int>;
extern "C" {
    pub fn zfs_userspace(arg1: *mut zfs_handle_t, arg2: zfs_userquota_prop_t,
                         arg3: zfs_userspace_cb_t, arg4: *mut ::libc::c_void)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_get_fsacl(arg1: *mut zfs_handle_t, arg2: *mut *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_set_fsacl(arg1: *mut zfs_handle_t, arg2: boolean_t,
                         arg3: *mut nvlist_t) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct recvflags {
    pub verbose: boolean_t,
    pub isprefix: boolean_t,
    pub istail: boolean_t,
    pub dryrun: boolean_t,
    pub force: boolean_t,
    pub canmountoff: boolean_t,
    pub resumable: boolean_t,
    pub byteswap: boolean_t,
    pub nomount: boolean_t,
}
#[test]
fn bindgen_test_layout_recvflags() {
    assert_eq!(::core::mem::size_of::<recvflags>() , 36usize , concat ! (
               "Size of: " , stringify ! ( recvflags ) ));
    assert_eq! (::core::mem::align_of::<recvflags>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( recvflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . verbose as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( verbose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . isprefix as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( isprefix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . istail as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( istail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . dryrun as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( dryrun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . force as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( force ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . canmountoff as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( canmountoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . resumable as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( resumable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . byteswap as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( byteswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . nomount as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( nomount ) ));
}
impl Clone for recvflags {
    fn clone(&self) -> Self { *self }
}
pub type recvflags_t = recvflags;
extern "C" {
    pub fn zfs_receive(arg1: *mut libzfs_handle_t,
                       arg2: *const ::libc::c_char, arg3: *mut nvlist_t,
                       arg4: *mut recvflags_t, arg5: ::libc::c_int,
                       arg6: *mut avl_tree_t) -> ::libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum diff_flags {
    ZFS_DIFF_PARSEABLE = 1,
    ZFS_DIFF_TIMESTAMP = 2,
    ZFS_DIFF_CLASSIFY = 4,
}
pub use self::diff_flags as diff_flags_t;
extern "C" {
    pub fn zfs_show_diffs(arg1: *mut zfs_handle_t, arg2: ::libc::c_int,
                          arg3: *const ::libc::c_char,
                          arg4: *const ::libc::c_char, arg5: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_type_to_name(arg1: zfs_type_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_refresh_properties(arg1: *mut zfs_handle_t);
}
extern "C" {
    pub fn zfs_name_valid(arg1: *const ::libc::c_char, arg2: zfs_type_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_path_to_zhandle(arg1: *mut libzfs_handle_t,
                               arg2: *mut ::libc::c_char, arg3: zfs_type_t)
     -> *mut zfs_handle_t;
}
extern "C" {
    pub fn zfs_dataset_exists(arg1: *mut libzfs_handle_t,
                              arg2: *const ::libc::c_char, arg3: zfs_type_t)
     -> boolean_t;
}
extern "C" {
    pub fn zfs_spa_version(arg1: *mut zfs_handle_t, arg2: *mut ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_bookmark_exists(path: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_append_partition(path: *mut ::libc::c_char, max_len: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_resolve_shortname(name: *const ::libc::c_char,
                                 path: *mut ::libc::c_char, pathlen: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_strcmp_pathname(name: *mut ::libc::c_char,
                               cmp_name: *mut ::libc::c_char,
                               wholedisk: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_path_order(path: *mut ::libc::c_char,
                          order: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_is_mounted(arg1: *mut zfs_handle_t,
                          arg2: *mut *mut ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_mount(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                     arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unmount(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                       arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unmountall(arg1: *mut zfs_handle_t, arg2: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_is_shared(arg1: *mut zfs_handle_t) -> boolean_t;
}
extern "C" {
    pub fn zfs_share(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshare(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_is_shared_nfs(arg1: *mut zfs_handle_t,
                             arg2: *mut *mut ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_is_shared_smb(arg1: *mut zfs_handle_t,
                             arg2: *mut *mut ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_share_nfs(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_share_smb(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_shareall(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshare_nfs(arg1: *mut zfs_handle_t,
                           arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshare_smb(arg1: *mut zfs_handle_t,
                           arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshareall_nfs(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshareall_smb(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshareall_bypath(arg1: *mut zfs_handle_t,
                                 arg2: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshareall_bytype(arg1: *mut zfs_handle_t,
                                 arg2: *const ::libc::c_char,
                                 arg3: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshareall(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_deleg_share_nfs(arg1: *mut libzfs_handle_t,
                               arg2: *mut ::libc::c_char,
                               arg3: *mut ::libc::c_char,
                               arg4: *mut ::libc::c_char,
                               arg5: *mut ::libc::c_void,
                               arg6: *mut ::libc::c_void, arg7: ::libc::c_int,
                               arg8: zfs_share_op_t) -> ::libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_nicenum_format {
    ZFS_NICENUM_1024 = 0,
    ZFS_NICENUM_BYTES = 1,
    ZFS_NICENUM_TIME = 2,
    ZFS_NICENUM_RAW = 3,
    ZFS_NICENUM_RAWTIME = 4,
}
extern "C" {
    pub fn zfs_nicenum(arg1: u64, arg2: *mut ::libc::c_char, arg3: usize);
}
extern "C" {
    pub fn zfs_nicenum_format(num: u64, buf: *mut ::libc::c_char,
                              buflen: usize, type_: zfs_nicenum_format);
}
extern "C" {
    pub fn zfs_nicetime(arg1: u64, arg2: *mut ::libc::c_char, arg3: usize);
}
extern "C" {
    pub fn zfs_nicebytes(arg1: u64, arg2: *mut ::libc::c_char, arg3: usize);
}
extern "C" {
    pub fn zfs_nicestrtonum(arg1: *mut libzfs_handle_t,
                            arg2: *const ::libc::c_char, arg3: *mut u64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_run_process(arg1: *const ::libc::c_char,
                              arg2: *mut *mut ::libc::c_char,
                              flags: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_run_process_get_stdout(path: *const ::libc::c_char,
                                         argv: *mut *mut ::libc::c_char,
                                         env: *mut *mut ::libc::c_char,
                                         lines: *mut *mut *mut ::libc::c_char,
                                         lines_cnt: *mut ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_run_process_get_stdout_nopath(path: *const ::libc::c_char,
                                                argv:
                                                    *mut *mut ::libc::c_char,
                                                env: *mut *mut ::libc::c_char,
                                                lines:
                                                    *mut *mut *mut ::libc::c_char,
                                                lines_cnt: *mut ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_free_str_array(strs: *mut *mut ::libc::c_char,
                                 count: ::libc::c_int);
}
extern "C" {
    pub fn libzfs_envvar_is_set(envvar: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_in_use(arg1: *mut libzfs_handle_t, arg2: ::libc::c_int,
                        arg3: *mut pool_state_t,
                        arg4: *mut *mut ::libc::c_char, arg5: *mut boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_read_label(arg1: ::libc::c_int, arg2: *mut *mut nvlist_t,
                            arg3: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_clear_label(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_smb_acl_add(arg1: *mut libzfs_handle_t,
                           arg2: *mut ::libc::c_char,
                           arg3: *mut ::libc::c_char,
                           arg4: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_smb_acl_remove(arg1: *mut libzfs_handle_t,
                              arg2: *mut ::libc::c_char,
                              arg3: *mut ::libc::c_char,
                              arg4: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_smb_acl_purge(arg1: *mut libzfs_handle_t,
                             arg2: *mut ::libc::c_char,
                             arg3: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_smb_acl_rename(arg1: *mut libzfs_handle_t,
                              arg2: *mut ::libc::c_char,
                              arg3: *mut ::libc::c_char,
                              arg4: *mut ::libc::c_char,
                              arg5: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_enable_datasets(arg1: *mut zpool_handle_t,
                                 arg2: *const ::libc::c_char,
                                 arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_disable_datasets(arg1: *mut zpool_handle_t, arg2: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_fru_refresh(arg1: *mut libzfs_handle_t);
}
extern "C" {
    pub fn libzfs_fru_lookup(arg1: *mut libzfs_handle_t,
                             arg2: *const ::libc::c_char)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn libzfs_fru_devpath(arg1: *mut libzfs_handle_t,
                              arg2: *const ::libc::c_char)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn libzfs_fru_compare(arg1: *mut libzfs_handle_t,
                              arg2: *const ::libc::c_char,
                              arg3: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn libzfs_fru_notself(arg1: *mut libzfs_handle_t,
                              arg2: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zpool_fru_set(arg1: *mut zpool_handle_t, arg2: u64,
                         arg3: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_strip_partition(arg1: *mut ::libc::c_char)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn zfs_strip_partition_path(arg1: *mut ::libc::c_char)
     -> *mut ::libc::c_char;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::libc::c_uint,
    pub fp_offset: ::libc::c_uint,
    pub overflow_arg_area: *mut ::libc::c_void,
    pub reg_save_area: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::core::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::core::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}

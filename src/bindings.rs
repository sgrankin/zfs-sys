/* automatically generated by rust-bindgen */

pub const _ASSERT_H: ::libc::c_uint = 1;
pub const _FEATURES_H: ::libc::c_uint = 1;
pub const _DEFAULT_SOURCE: ::libc::c_uint = 1;
pub const __USE_ISOC11: ::libc::c_uint = 1;
pub const __USE_ISOC99: ::libc::c_uint = 1;
pub const __USE_ISOC95: ::libc::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::libc::c_uint = 1;
pub const _POSIX_SOURCE: ::libc::c_uint = 1;
pub const _POSIX_C_SOURCE: ::libc::c_uint = 200809;
pub const __USE_POSIX: ::libc::c_uint = 1;
pub const __USE_POSIX2: ::libc::c_uint = 1;
pub const __USE_POSIX199309: ::libc::c_uint = 1;
pub const __USE_POSIX199506: ::libc::c_uint = 1;
pub const __USE_XOPEN2K: ::libc::c_uint = 1;
pub const __USE_XOPEN2K8: ::libc::c_uint = 1;
pub const _ATFILE_SOURCE: ::libc::c_uint = 1;
pub const __USE_MISC: ::libc::c_uint = 1;
pub const __USE_ATFILE: ::libc::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::libc::c_uint = 0;
pub const _STDC_PREDEF_H: ::libc::c_uint = 1;
pub const __STDC_IEC_559__: ::libc::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::libc::c_uint = 1;
pub const __STDC_ISO_10646__: ::libc::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::libc::c_uint = 1;
pub const __GNU_LIBRARY__: ::libc::c_uint = 6;
pub const __GLIBC__: ::libc::c_uint = 2;
pub const __GLIBC_MINOR__: ::libc::c_uint = 25;
pub const _SYS_CDEFS_H: ::libc::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::libc::c_uint = 1;
pub const __WORDSIZE: ::libc::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::libc::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::libc::c_uint = 64;
pub const _STDIO_H: ::libc::c_uint = 1;
pub const __GLIBC_USE_LIB_EXT2: ::libc::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::libc::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::libc::c_uint = 0;
pub const _BITS_TYPES_H: ::libc::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::libc::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::libc::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::libc::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::libc::c_uint = 1;
pub const __FD_SETSIZE: ::libc::c_uint = 1024;
pub const __FILE_defined: ::libc::c_uint = 1;
pub const ____FILE_defined: ::libc::c_uint = 1;
pub const _G_config_h: ::libc::c_uint = 1;
pub const ____mbstate_t_defined: ::libc::c_uint = 1;
pub const _G_HAVE_MMAP: ::libc::c_uint = 1;
pub const _G_HAVE_MREMAP: ::libc::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::libc::c_uint = 131073;
pub const _G_BUFSIZ: ::libc::c_uint = 8192;
pub const _IO_BUFSIZ: ::libc::c_uint = 8192;
pub const __GNUC_VA_LIST: ::libc::c_uint = 1;
pub const _IO_UNIFIED_JUMPTABLES: ::libc::c_uint = 1;
pub const EOF: ::libc::c_int = -1;
pub const _IOS_INPUT: ::libc::c_uint = 1;
pub const _IOS_OUTPUT: ::libc::c_uint = 2;
pub const _IOS_ATEND: ::libc::c_uint = 4;
pub const _IOS_APPEND: ::libc::c_uint = 8;
pub const _IOS_TRUNC: ::libc::c_uint = 16;
pub const _IOS_NOCREATE: ::libc::c_uint = 32;
pub const _IOS_NOREPLACE: ::libc::c_uint = 64;
pub const _IOS_BIN: ::libc::c_uint = 128;
pub const _IO_MAGIC: ::libc::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::libc::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::libc::c_uint = 4294901760;
pub const _IO_USER_BUF: ::libc::c_uint = 1;
pub const _IO_UNBUFFERED: ::libc::c_uint = 2;
pub const _IO_NO_READS: ::libc::c_uint = 4;
pub const _IO_NO_WRITES: ::libc::c_uint = 8;
pub const _IO_EOF_SEEN: ::libc::c_uint = 16;
pub const _IO_ERR_SEEN: ::libc::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::libc::c_uint = 64;
pub const _IO_LINKED: ::libc::c_uint = 128;
pub const _IO_IN_BACKUP: ::libc::c_uint = 256;
pub const _IO_LINE_BUF: ::libc::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::libc::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::libc::c_uint = 2048;
pub const _IO_IS_APPENDING: ::libc::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::libc::c_uint = 8192;
pub const _IO_BAD_SEEN: ::libc::c_uint = 16384;
pub const _IO_USER_LOCK: ::libc::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::libc::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::libc::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::libc::c_uint = 8;
pub const _IO_SKIPWS: ::libc::c_uint = 1;
pub const _IO_LEFT: ::libc::c_uint = 2;
pub const _IO_RIGHT: ::libc::c_uint = 4;
pub const _IO_INTERNAL: ::libc::c_uint = 8;
pub const _IO_DEC: ::libc::c_uint = 16;
pub const _IO_OCT: ::libc::c_uint = 32;
pub const _IO_HEX: ::libc::c_uint = 64;
pub const _IO_SHOWBASE: ::libc::c_uint = 128;
pub const _IO_SHOWPOINT: ::libc::c_uint = 256;
pub const _IO_UPPERCASE: ::libc::c_uint = 512;
pub const _IO_SHOWPOS: ::libc::c_uint = 1024;
pub const _IO_SCIENTIFIC: ::libc::c_uint = 2048;
pub const _IO_FIXED: ::libc::c_uint = 4096;
pub const _IO_UNITBUF: ::libc::c_uint = 8192;
pub const _IO_STDIO: ::libc::c_uint = 16384;
pub const _IO_DONT_CLOSE: ::libc::c_uint = 32768;
pub const _IO_BOOLALPHA: ::libc::c_uint = 65536;
pub const _IOFBF: ::libc::c_uint = 0;
pub const _IOLBF: ::libc::c_uint = 1;
pub const _IONBF: ::libc::c_uint = 2;
pub const BUFSIZ: ::libc::c_uint = 8192;
pub const SEEK_SET: ::libc::c_uint = 0;
pub const SEEK_CUR: ::libc::c_uint = 1;
pub const SEEK_END: ::libc::c_uint = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\x00";
pub const L_tmpnam: ::libc::c_uint = 20;
pub const TMP_MAX: ::libc::c_uint = 238328;
pub const FILENAME_MAX: ::libc::c_uint = 4096;
pub const L_ctermid: ::libc::c_uint = 9;
pub const FOPEN_MAX: ::libc::c_uint = 16;
pub const _STDLIB_H: ::libc::c_uint = 1;
pub const WNOHANG: ::libc::c_uint = 1;
pub const WUNTRACED: ::libc::c_uint = 2;
pub const WSTOPPED: ::libc::c_uint = 2;
pub const WEXITED: ::libc::c_uint = 4;
pub const WCONTINUED: ::libc::c_uint = 8;
pub const WNOWAIT: ::libc::c_uint = 16777216;
pub const __WNOTHREAD: ::libc::c_uint = 536870912;
pub const __WALL: ::libc::c_uint = 1073741824;
pub const __WCLONE: ::libc::c_uint = 2147483648;
pub const __W_CONTINUED: ::libc::c_uint = 65535;
pub const __WCOREFLAG: ::libc::c_uint = 128;
pub const __ldiv_t_defined: ::libc::c_uint = 1;
pub const __lldiv_t_defined: ::libc::c_uint = 1;
pub const RAND_MAX: ::libc::c_uint = 2147483647;
pub const EXIT_FAILURE: ::libc::c_uint = 1;
pub const EXIT_SUCCESS: ::libc::c_uint = 0;
pub const _SYS_TYPES_H: ::libc::c_uint = 1;
pub const __clock_t_defined: ::libc::c_uint = 1;
pub const __clockid_t_defined: ::libc::c_uint = 1;
pub const __time_t_defined: ::libc::c_uint = 1;
pub const __timer_t_defined: ::libc::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::libc::c_uint = 1;
pub const _ENDIAN_H: ::libc::c_uint = 1;
pub const __LITTLE_ENDIAN: ::libc::c_uint = 1234;
pub const __BIG_ENDIAN: ::libc::c_uint = 4321;
pub const __PDP_ENDIAN: ::libc::c_uint = 3412;
pub const __BYTE_ORDER: ::libc::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::libc::c_uint = 1234;
pub const LITTLE_ENDIAN: ::libc::c_uint = 1234;
pub const BIG_ENDIAN: ::libc::c_uint = 4321;
pub const PDP_ENDIAN: ::libc::c_uint = 3412;
pub const BYTE_ORDER: ::libc::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::libc::c_uint = 1;
pub const _BITS_UINTN_IDENTITY_H: ::libc::c_uint = 1;
pub const _SYS_SELECT_H: ::libc::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::libc::c_uint = 1;
pub const __timeval_defined: ::libc::c_uint = 1;
pub const __timespec_defined: ::libc::c_uint = 1;
pub const FD_SETSIZE: ::libc::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::libc::c_uint = 1;
pub const _BITS_SYSMACROS_H: ::libc::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::libc::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::libc::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::libc::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::libc::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::libc::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::libc::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::libc::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::libc::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::libc::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::libc::c_uint = 4;
pub const __have_pthread_attr_t: ::libc::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::libc::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::libc::c_uint = 1;
pub const _INTTYPES_H: ::libc::c_uint = 1;
pub const _STDINT_H: ::libc::c_uint = 1;
pub const _BITS_WCHAR_H: ::libc::c_uint = 1;
pub const INT8_MIN: ::libc::c_int = -128;
pub const INT16_MIN: ::libc::c_int = -32768;
pub const INT32_MIN: ::libc::c_int = -2147483648;
pub const INT8_MAX: ::libc::c_uint = 127;
pub const INT16_MAX: ::libc::c_uint = 32767;
pub const INT32_MAX: ::libc::c_uint = 2147483647;
pub const UINT8_MAX: ::libc::c_uint = 255;
pub const UINT16_MAX: ::libc::c_uint = 65535;
pub const UINT32_MAX: ::libc::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::libc::c_int = -128;
pub const INT_LEAST16_MIN: ::libc::c_int = -32768;
pub const INT_LEAST32_MIN: ::libc::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::libc::c_uint = 127;
pub const INT_LEAST16_MAX: ::libc::c_uint = 32767;
pub const INT_LEAST32_MAX: ::libc::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::libc::c_uint = 255;
pub const UINT_LEAST16_MAX: ::libc::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::libc::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::libc::c_int = -128;
pub const INT_FAST16_MIN: ::libc::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::libc::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::libc::c_uint = 127;
pub const INT_FAST16_MAX: ::libc::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::libc::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::libc::c_uint = 255;
pub const UINT_FAST16_MAX: ::libc::c_int = -1;
pub const UINT_FAST32_MAX: ::libc::c_int = -1;
pub const INTPTR_MIN: ::libc::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::libc::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::libc::c_int = -1;
pub const PTRDIFF_MIN: ::libc::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::libc::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::libc::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::libc::c_uint = 2147483647;
pub const SIZE_MAX: ::libc::c_int = -1;
pub const WINT_MIN: ::libc::c_uint = 0;
pub const WINT_MAX: ::libc::c_uint = 4294967295;
pub const ____gwchar_t_defined: ::libc::c_uint = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\x00";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\x00";
pub const PRId8: &'static [u8; 2usize] = b"d\x00";
pub const PRId16: &'static [u8; 2usize] = b"d\x00";
pub const PRId32: &'static [u8; 2usize] = b"d\x00";
pub const PRId64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\x00";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIi8: &'static [u8; 2usize] = b"i\x00";
pub const PRIi16: &'static [u8; 2usize] = b"i\x00";
pub const PRIi32: &'static [u8; 2usize] = b"i\x00";
pub const PRIi64: &'static [u8; 3usize] = b"li\x00";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\x00";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\x00";
pub const PRIo8: &'static [u8; 2usize] = b"o\x00";
pub const PRIo16: &'static [u8; 2usize] = b"o\x00";
pub const PRIo32: &'static [u8; 2usize] = b"o\x00";
pub const PRIo64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\x00";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIu8: &'static [u8; 2usize] = b"u\x00";
pub const PRIu16: &'static [u8; 2usize] = b"u\x00";
pub const PRIu32: &'static [u8; 2usize] = b"u\x00";
pub const PRIu64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\x00";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIx8: &'static [u8; 2usize] = b"x\x00";
pub const PRIx16: &'static [u8; 2usize] = b"x\x00";
pub const PRIx32: &'static [u8; 2usize] = b"x\x00";
pub const PRIx64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\x00";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIX8: &'static [u8; 2usize] = b"X\x00";
pub const PRIX16: &'static [u8; 2usize] = b"X\x00";
pub const PRIX32: &'static [u8; 2usize] = b"X\x00";
pub const PRIX64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\x00";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\x00";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\x00";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\x00";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNd16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNd32: &'static [u8; 2usize] = b"d\x00";
pub const SCNd64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNi16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNi32: &'static [u8; 2usize] = b"i\x00";
pub const SCNi64: &'static [u8; 3usize] = b"li\x00";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\x00";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNu16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNu32: &'static [u8; 2usize] = b"u\x00";
pub const SCNu64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNo8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNo16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNo32: &'static [u8; 2usize] = b"o\x00";
pub const SCNo64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNx16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNx32: &'static [u8; 2usize] = b"x\x00";
pub const SCNx64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\x00";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\x00";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const _SYS_PARAM_H: ::libc::c_uint = 1;
pub const _LIBC_LIMITS_H_: ::libc::c_uint = 1;
pub const MB_LEN_MAX: ::libc::c_uint = 16;
pub const _BITS_POSIX1_LIM_H: ::libc::c_uint = 1;
pub const _POSIX_AIO_LISTIO_MAX: ::libc::c_uint = 2;
pub const _POSIX_AIO_MAX: ::libc::c_uint = 1;
pub const _POSIX_ARG_MAX: ::libc::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::libc::c_uint = 25;
pub const _POSIX_DELAYTIMER_MAX: ::libc::c_uint = 32;
pub const _POSIX_HOST_NAME_MAX: ::libc::c_uint = 255;
pub const _POSIX_LINK_MAX: ::libc::c_uint = 8;
pub const _POSIX_LOGIN_NAME_MAX: ::libc::c_uint = 9;
pub const _POSIX_MAX_CANON: ::libc::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::libc::c_uint = 255;
pub const _POSIX_MQ_OPEN_MAX: ::libc::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::libc::c_uint = 32;
pub const _POSIX_NAME_MAX: ::libc::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::libc::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::libc::c_uint = 20;
pub const _POSIX_PATH_MAX: ::libc::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::libc::c_uint = 512;
pub const _POSIX_RE_DUP_MAX: ::libc::c_uint = 255;
pub const _POSIX_RTSIG_MAX: ::libc::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::libc::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::libc::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::libc::c_uint = 32;
pub const _POSIX_SSIZE_MAX: ::libc::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::libc::c_uint = 8;
pub const _POSIX_SYMLINK_MAX: ::libc::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::libc::c_uint = 8;
pub const _POSIX_TIMER_MAX: ::libc::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::libc::c_uint = 9;
pub const _POSIX_TZNAME_MAX: ::libc::c_uint = 6;
pub const _POSIX_CLOCKRES_MIN: ::libc::c_uint = 20000000;
pub const NR_OPEN: ::libc::c_uint = 1024;
pub const NGROUPS_MAX: ::libc::c_uint = 65536;
pub const ARG_MAX: ::libc::c_uint = 131072;
pub const LINK_MAX: ::libc::c_uint = 127;
pub const MAX_CANON: ::libc::c_uint = 255;
pub const MAX_INPUT: ::libc::c_uint = 255;
pub const NAME_MAX: ::libc::c_uint = 255;
pub const PATH_MAX: ::libc::c_uint = 4096;
pub const PIPE_BUF: ::libc::c_uint = 4096;
pub const XATTR_NAME_MAX: ::libc::c_uint = 255;
pub const XATTR_SIZE_MAX: ::libc::c_uint = 65536;
pub const XATTR_LIST_MAX: ::libc::c_uint = 65536;
pub const RTSIG_MAX: ::libc::c_uint = 32;
pub const _POSIX_THREAD_KEYS_MAX: ::libc::c_uint = 128;
pub const PTHREAD_KEYS_MAX: ::libc::c_uint = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::libc::c_uint = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::libc::c_uint = 4;
pub const _POSIX_THREAD_THREADS_MAX: ::libc::c_uint = 64;
pub const AIO_PRIO_DELTA_MAX: ::libc::c_uint = 20;
pub const PTHREAD_STACK_MIN: ::libc::c_uint = 16384;
pub const DELAYTIMER_MAX: ::libc::c_uint = 2147483647;
pub const TTY_NAME_MAX: ::libc::c_uint = 32;
pub const LOGIN_NAME_MAX: ::libc::c_uint = 256;
pub const HOST_NAME_MAX: ::libc::c_uint = 64;
pub const MQ_PRIO_MAX: ::libc::c_uint = 32768;
pub const SEM_VALUE_MAX: ::libc::c_uint = 2147483647;
pub const _BITS_POSIX2_LIM_H: ::libc::c_uint = 1;
pub const _POSIX2_BC_BASE_MAX: ::libc::c_uint = 99;
pub const _POSIX2_BC_DIM_MAX: ::libc::c_uint = 2048;
pub const _POSIX2_BC_SCALE_MAX: ::libc::c_uint = 99;
pub const _POSIX2_BC_STRING_MAX: ::libc::c_uint = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: ::libc::c_uint = 2;
pub const _POSIX2_EXPR_NEST_MAX: ::libc::c_uint = 32;
pub const _POSIX2_LINE_MAX: ::libc::c_uint = 2048;
pub const _POSIX2_RE_DUP_MAX: ::libc::c_uint = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: ::libc::c_uint = 14;
pub const BC_BASE_MAX: ::libc::c_uint = 99;
pub const BC_DIM_MAX: ::libc::c_uint = 2048;
pub const BC_SCALE_MAX: ::libc::c_uint = 99;
pub const BC_STRING_MAX: ::libc::c_uint = 1000;
pub const COLL_WEIGHTS_MAX: ::libc::c_uint = 255;
pub const EXPR_NEST_MAX: ::libc::c_uint = 32;
pub const LINE_MAX: ::libc::c_uint = 2048;
pub const CHARCLASS_NAME_MAX: ::libc::c_uint = 2048;
pub const RE_DUP_MAX: ::libc::c_uint = 32767;
pub const DBL_DIG: ::libc::c_uint = 15;
pub const FLT_DIG: ::libc::c_uint = 6;
pub const _SIGSET_H_fns: ::libc::c_uint = 1;
pub const SIGHUP: ::libc::c_uint = 1;
pub const SIGINT: ::libc::c_uint = 2;
pub const SIGQUIT: ::libc::c_uint = 3;
pub const SIGILL: ::libc::c_uint = 4;
pub const SIGTRAP: ::libc::c_uint = 5;
pub const SIGABRT: ::libc::c_uint = 6;
pub const SIGIOT: ::libc::c_uint = 6;
pub const SIGBUS: ::libc::c_uint = 7;
pub const SIGFPE: ::libc::c_uint = 8;
pub const SIGKILL: ::libc::c_uint = 9;
pub const SIGUSR1: ::libc::c_uint = 10;
pub const SIGSEGV: ::libc::c_uint = 11;
pub const SIGUSR2: ::libc::c_uint = 12;
pub const SIGPIPE: ::libc::c_uint = 13;
pub const SIGALRM: ::libc::c_uint = 14;
pub const SIGTERM: ::libc::c_uint = 15;
pub const SIGSTKFLT: ::libc::c_uint = 16;
pub const SIGCHLD: ::libc::c_uint = 17;
pub const SIGCONT: ::libc::c_uint = 18;
pub const SIGSTOP: ::libc::c_uint = 19;
pub const SIGTSTP: ::libc::c_uint = 20;
pub const SIGTTIN: ::libc::c_uint = 21;
pub const SIGTTOU: ::libc::c_uint = 22;
pub const SIGURG: ::libc::c_uint = 23;
pub const SIGXCPU: ::libc::c_uint = 24;
pub const SIGXFSZ: ::libc::c_uint = 25;
pub const SIGVTALRM: ::libc::c_uint = 26;
pub const SIGPROF: ::libc::c_uint = 27;
pub const SIGWINCH: ::libc::c_uint = 28;
pub const SIGIO: ::libc::c_uint = 29;
pub const SIGPWR: ::libc::c_uint = 30;
pub const SIGSYS: ::libc::c_uint = 31;
pub const SIGUNUSED: ::libc::c_uint = 31;
pub const _NSIG: ::libc::c_uint = 65;
pub const __SIGRTMIN: ::libc::c_uint = 32;
pub const __SIGRTMAX: ::libc::c_uint = 64;
pub const __have_sigval_t: ::libc::c_uint = 1;
pub const __have_siginfo_t: ::libc::c_uint = 1;
pub const __SI_MAX_SIZE: ::libc::c_uint = 128;
pub const __have_sigevent_t: ::libc::c_uint = 1;
pub const __SIGEV_MAX_SIZE: ::libc::c_uint = 64;
pub const NSIG: ::libc::c_uint = 65;
pub const SA_NOCLDSTOP: ::libc::c_uint = 1;
pub const SA_NOCLDWAIT: ::libc::c_uint = 2;
pub const SA_SIGINFO: ::libc::c_uint = 4;
pub const SA_ONSTACK: ::libc::c_uint = 134217728;
pub const SA_RESTART: ::libc::c_uint = 268435456;
pub const SA_NODEFER: ::libc::c_uint = 1073741824;
pub const SA_RESETHAND: ::libc::c_uint = 2147483648;
pub const SA_INTERRUPT: ::libc::c_uint = 536870912;
pub const SA_NOMASK: ::libc::c_uint = 1073741824;
pub const SA_ONESHOT: ::libc::c_uint = 2147483648;
pub const SA_STACK: ::libc::c_uint = 134217728;
pub const SIG_BLOCK: ::libc::c_uint = 0;
pub const SIG_UNBLOCK: ::libc::c_uint = 1;
pub const SIG_SETMASK: ::libc::c_uint = 2;
pub const _BITS_SIGCONTEXT_H: ::libc::c_uint = 1;
pub const FP_XSTATE_MAGIC1: ::libc::c_uint = 1179670611;
pub const FP_XSTATE_MAGIC2: ::libc::c_uint = 1179670597;
pub const _BITS_SIGSTACK_H: ::libc::c_uint = 1;
pub const MINSIGSTKSZ: ::libc::c_uint = 2048;
pub const SIGSTKSZ: ::libc::c_uint = 8192;
pub const _SYS_UCONTEXT_H: ::libc::c_uint = 1;
pub const NGREG: ::libc::c_uint = 23;
pub const _BITS_SIGTHREAD_H: ::libc::c_uint = 1;
pub const HZ: ::libc::c_uint = 100;
pub const EXEC_PAGESIZE: ::libc::c_uint = 4096;
pub const NOGROUP: ::libc::c_int = -1;
pub const MAXHOSTNAMELEN: ::libc::c_uint = 64;
pub const MAXSYMLINKS: ::libc::c_uint = 20;
pub const NOFILE: ::libc::c_uint = 256;
pub const NCARGS: ::libc::c_uint = 131072;
pub const NGROUPS: ::libc::c_uint = 65536;
pub const CANBSIZ: ::libc::c_uint = 255;
pub const MAXPATHLEN: ::libc::c_uint = 4096;
pub const DEV_BSIZE: ::libc::c_uint = 512;
pub const _UNISTD_H: ::libc::c_uint = 1;
pub const _POSIX_VERSION: ::libc::c_uint = 200809;
pub const __POSIX2_THIS_VERSION: ::libc::c_uint = 200809;
pub const _POSIX2_VERSION: ::libc::c_uint = 200809;
pub const _POSIX2_C_VERSION: ::libc::c_uint = 200809;
pub const _POSIX2_C_BIND: ::libc::c_uint = 200809;
pub const _POSIX2_C_DEV: ::libc::c_uint = 200809;
pub const _POSIX2_SW_DEV: ::libc::c_uint = 200809;
pub const _POSIX2_LOCALEDEF: ::libc::c_uint = 200809;
pub const _XOPEN_VERSION: ::libc::c_uint = 700;
pub const _XOPEN_XCU_VERSION: ::libc::c_uint = 4;
pub const _XOPEN_XPG2: ::libc::c_uint = 1;
pub const _XOPEN_XPG3: ::libc::c_uint = 1;
pub const _XOPEN_XPG4: ::libc::c_uint = 1;
pub const _XOPEN_UNIX: ::libc::c_uint = 1;
pub const _XOPEN_CRYPT: ::libc::c_uint = 1;
pub const _XOPEN_ENH_I18N: ::libc::c_uint = 1;
pub const _XOPEN_LEGACY: ::libc::c_uint = 1;
pub const _BITS_POSIX_OPT_H: ::libc::c_uint = 1;
pub const _POSIX_JOB_CONTROL: ::libc::c_uint = 1;
pub const _POSIX_SAVED_IDS: ::libc::c_uint = 1;
pub const _POSIX_PRIORITY_SCHEDULING: ::libc::c_uint = 200809;
pub const _POSIX_SYNCHRONIZED_IO: ::libc::c_uint = 200809;
pub const _POSIX_FSYNC: ::libc::c_uint = 200809;
pub const _POSIX_MAPPED_FILES: ::libc::c_uint = 200809;
pub const _POSIX_MEMLOCK: ::libc::c_uint = 200809;
pub const _POSIX_MEMLOCK_RANGE: ::libc::c_uint = 200809;
pub const _POSIX_MEMORY_PROTECTION: ::libc::c_uint = 200809;
pub const _POSIX_CHOWN_RESTRICTED: ::libc::c_uint = 0;
pub const _POSIX_VDISABLE: u8 = b'\x00';
pub const _POSIX_NO_TRUNC: ::libc::c_uint = 1;
pub const _XOPEN_REALTIME: ::libc::c_uint = 1;
pub const _XOPEN_REALTIME_THREADS: ::libc::c_uint = 1;
pub const _XOPEN_SHM: ::libc::c_uint = 1;
pub const _POSIX_THREADS: ::libc::c_uint = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: ::libc::c_uint = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: ::libc::c_uint = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: ::libc::c_uint = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: ::libc::c_uint = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: ::libc::c_uint = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: ::libc::c_uint = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: ::libc::c_uint = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: ::libc::c_uint = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: ::libc::c_int = -1;
pub const _POSIX_SEMAPHORES: ::libc::c_uint = 200809;
pub const _POSIX_REALTIME_SIGNALS: ::libc::c_uint = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: ::libc::c_uint = 200809;
pub const _POSIX_ASYNC_IO: ::libc::c_uint = 1;
pub const _LFS_ASYNCHRONOUS_IO: ::libc::c_uint = 1;
pub const _POSIX_PRIORITIZED_IO: ::libc::c_uint = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: ::libc::c_uint = 1;
pub const _LFS_LARGEFILE: ::libc::c_uint = 1;
pub const _LFS64_LARGEFILE: ::libc::c_uint = 1;
pub const _LFS64_STDIO: ::libc::c_uint = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: ::libc::c_uint = 200809;
pub const _POSIX_CPUTIME: ::libc::c_uint = 0;
pub const _POSIX_THREAD_CPUTIME: ::libc::c_uint = 0;
pub const _POSIX_REGEXP: ::libc::c_uint = 1;
pub const _POSIX_READER_WRITER_LOCKS: ::libc::c_uint = 200809;
pub const _POSIX_SHELL: ::libc::c_uint = 1;
pub const _POSIX_TIMEOUTS: ::libc::c_uint = 200809;
pub const _POSIX_SPIN_LOCKS: ::libc::c_uint = 200809;
pub const _POSIX_SPAWN: ::libc::c_uint = 200809;
pub const _POSIX_TIMERS: ::libc::c_uint = 200809;
pub const _POSIX_BARRIERS: ::libc::c_uint = 200809;
pub const _POSIX_MESSAGE_PASSING: ::libc::c_uint = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: ::libc::c_uint = 200809;
pub const _POSIX_MONOTONIC_CLOCK: ::libc::c_uint = 0;
pub const _POSIX_CLOCK_SELECTION: ::libc::c_uint = 200809;
pub const _POSIX_ADVISORY_INFO: ::libc::c_uint = 200809;
pub const _POSIX_IPV6: ::libc::c_uint = 200809;
pub const _POSIX_RAW_SOCKETS: ::libc::c_uint = 200809;
pub const _POSIX2_CHAR_TERM: ::libc::c_uint = 200809;
pub const _POSIX_SPORADIC_SERVER: ::libc::c_int = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: ::libc::c_int = -1;
pub const _POSIX_TRACE: ::libc::c_int = -1;
pub const _POSIX_TRACE_EVENT_FILTER: ::libc::c_int = -1;
pub const _POSIX_TRACE_INHERIT: ::libc::c_int = -1;
pub const _POSIX_TRACE_LOG: ::libc::c_int = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: ::libc::c_int = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: ::libc::c_int = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: ::libc::c_int = -1;
pub const _XBS5_LPBIG_OFFBIG: ::libc::c_int = -1;
pub const _POSIX_V7_LP64_OFF64: ::libc::c_uint = 1;
pub const _POSIX_V6_LP64_OFF64: ::libc::c_uint = 1;
pub const _XBS5_LP64_OFF64: ::libc::c_uint = 1;
pub const __ILP32_OFF32_CFLAGS: &'static [u8; 5usize] = b"-m32\x00";
pub const __ILP32_OFF32_LDFLAGS: &'static [u8; 5usize] = b"-m32\x00";
pub const __ILP32_OFFBIG_CFLAGS: &'static [u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\x00";
pub const __ILP32_OFFBIG_LDFLAGS: &'static [u8; 5usize] = b"-m32\x00";
pub const __LP64_OFF64_CFLAGS: &'static [u8; 5usize] = b"-m64\x00";
pub const __LP64_OFF64_LDFLAGS: &'static [u8; 5usize] = b"-m64\x00";
pub const STDIN_FILENO: ::libc::c_uint = 0;
pub const STDOUT_FILENO: ::libc::c_uint = 1;
pub const STDERR_FILENO: ::libc::c_uint = 2;
pub const R_OK: ::libc::c_uint = 4;
pub const W_OK: ::libc::c_uint = 2;
pub const X_OK: ::libc::c_uint = 1;
pub const F_OK: ::libc::c_uint = 0;
pub const L_SET: ::libc::c_uint = 0;
pub const L_INCR: ::libc::c_uint = 1;
pub const L_XTND: ::libc::c_uint = 2;
pub const F_ULOCK: ::libc::c_uint = 0;
pub const F_LOCK: ::libc::c_uint = 1;
pub const F_TLOCK: ::libc::c_uint = 2;
pub const F_TEST: ::libc::c_uint = 3;
pub const _SYS_IOCTL_H: ::libc::c_uint = 1;
pub const _IOC_NRBITS: ::libc::c_uint = 8;
pub const _IOC_TYPEBITS: ::libc::c_uint = 8;
pub const _IOC_SIZEBITS: ::libc::c_uint = 14;
pub const _IOC_DIRBITS: ::libc::c_uint = 2;
pub const _IOC_NRMASK: ::libc::c_uint = 255;
pub const _IOC_TYPEMASK: ::libc::c_uint = 255;
pub const _IOC_SIZEMASK: ::libc::c_uint = 16383;
pub const _IOC_DIRMASK: ::libc::c_uint = 3;
pub const _IOC_NRSHIFT: ::libc::c_uint = 0;
pub const _IOC_TYPESHIFT: ::libc::c_uint = 8;
pub const _IOC_SIZESHIFT: ::libc::c_uint = 16;
pub const _IOC_DIRSHIFT: ::libc::c_uint = 30;
pub const _IOC_NONE: ::libc::c_uint = 0;
pub const _IOC_WRITE: ::libc::c_uint = 1;
pub const _IOC_READ: ::libc::c_uint = 2;
pub const IOC_IN: ::libc::c_uint = 1073741824;
pub const IOC_OUT: ::libc::c_uint = 2147483648;
pub const IOC_INOUT: ::libc::c_uint = 3221225472;
pub const IOCSIZE_MASK: ::libc::c_uint = 1073676288;
pub const IOCSIZE_SHIFT: ::libc::c_uint = 16;
pub const TCGETS: ::libc::c_uint = 21505;
pub const TCSETS: ::libc::c_uint = 21506;
pub const TCSETSW: ::libc::c_uint = 21507;
pub const TCSETSF: ::libc::c_uint = 21508;
pub const TCGETA: ::libc::c_uint = 21509;
pub const TCSETA: ::libc::c_uint = 21510;
pub const TCSETAW: ::libc::c_uint = 21511;
pub const TCSETAF: ::libc::c_uint = 21512;
pub const TCSBRK: ::libc::c_uint = 21513;
pub const TCXONC: ::libc::c_uint = 21514;
pub const TCFLSH: ::libc::c_uint = 21515;
pub const TIOCEXCL: ::libc::c_uint = 21516;
pub const TIOCNXCL: ::libc::c_uint = 21517;
pub const TIOCSCTTY: ::libc::c_uint = 21518;
pub const TIOCGPGRP: ::libc::c_uint = 21519;
pub const TIOCSPGRP: ::libc::c_uint = 21520;
pub const TIOCOUTQ: ::libc::c_uint = 21521;
pub const TIOCSTI: ::libc::c_uint = 21522;
pub const TIOCGWINSZ: ::libc::c_uint = 21523;
pub const TIOCSWINSZ: ::libc::c_uint = 21524;
pub const TIOCMGET: ::libc::c_uint = 21525;
pub const TIOCMBIS: ::libc::c_uint = 21526;
pub const TIOCMBIC: ::libc::c_uint = 21527;
pub const TIOCMSET: ::libc::c_uint = 21528;
pub const TIOCGSOFTCAR: ::libc::c_uint = 21529;
pub const TIOCSSOFTCAR: ::libc::c_uint = 21530;
pub const FIONREAD: ::libc::c_uint = 21531;
pub const TIOCINQ: ::libc::c_uint = 21531;
pub const TIOCLINUX: ::libc::c_uint = 21532;
pub const TIOCCONS: ::libc::c_uint = 21533;
pub const TIOCGSERIAL: ::libc::c_uint = 21534;
pub const TIOCSSERIAL: ::libc::c_uint = 21535;
pub const TIOCPKT: ::libc::c_uint = 21536;
pub const FIONBIO: ::libc::c_uint = 21537;
pub const TIOCNOTTY: ::libc::c_uint = 21538;
pub const TIOCSETD: ::libc::c_uint = 21539;
pub const TIOCGETD: ::libc::c_uint = 21540;
pub const TCSBRKP: ::libc::c_uint = 21541;
pub const TIOCSBRK: ::libc::c_uint = 21543;
pub const TIOCCBRK: ::libc::c_uint = 21544;
pub const TIOCGSID: ::libc::c_uint = 21545;
pub const TIOCGRS485: ::libc::c_uint = 21550;
pub const TIOCSRS485: ::libc::c_uint = 21551;
pub const TCGETX: ::libc::c_uint = 21554;
pub const TCSETX: ::libc::c_uint = 21555;
pub const TCSETXF: ::libc::c_uint = 21556;
pub const TCSETXW: ::libc::c_uint = 21557;
pub const TIOCVHANGUP: ::libc::c_uint = 21559;
pub const FIONCLEX: ::libc::c_uint = 21584;
pub const FIOCLEX: ::libc::c_uint = 21585;
pub const FIOASYNC: ::libc::c_uint = 21586;
pub const TIOCSERCONFIG: ::libc::c_uint = 21587;
pub const TIOCSERGWILD: ::libc::c_uint = 21588;
pub const TIOCSERSWILD: ::libc::c_uint = 21589;
pub const TIOCGLCKTRMIOS: ::libc::c_uint = 21590;
pub const TIOCSLCKTRMIOS: ::libc::c_uint = 21591;
pub const TIOCSERGSTRUCT: ::libc::c_uint = 21592;
pub const TIOCSERGETLSR: ::libc::c_uint = 21593;
pub const TIOCSERGETMULTI: ::libc::c_uint = 21594;
pub const TIOCSERSETMULTI: ::libc::c_uint = 21595;
pub const TIOCMIWAIT: ::libc::c_uint = 21596;
pub const TIOCGICOUNT: ::libc::c_uint = 21597;
pub const FIOQSIZE: ::libc::c_uint = 21600;
pub const TIOCPKT_DATA: ::libc::c_uint = 0;
pub const TIOCPKT_FLUSHREAD: ::libc::c_uint = 1;
pub const TIOCPKT_FLUSHWRITE: ::libc::c_uint = 2;
pub const TIOCPKT_STOP: ::libc::c_uint = 4;
pub const TIOCPKT_START: ::libc::c_uint = 8;
pub const TIOCPKT_NOSTOP: ::libc::c_uint = 16;
pub const TIOCPKT_DOSTOP: ::libc::c_uint = 32;
pub const TIOCPKT_IOCTL: ::libc::c_uint = 64;
pub const TIOCSER_TEMT: ::libc::c_uint = 1;
pub const SIOCADDRT: ::libc::c_uint = 35083;
pub const SIOCDELRT: ::libc::c_uint = 35084;
pub const SIOCRTMSG: ::libc::c_uint = 35085;
pub const SIOCGIFNAME: ::libc::c_uint = 35088;
pub const SIOCSIFLINK: ::libc::c_uint = 35089;
pub const SIOCGIFCONF: ::libc::c_uint = 35090;
pub const SIOCGIFFLAGS: ::libc::c_uint = 35091;
pub const SIOCSIFFLAGS: ::libc::c_uint = 35092;
pub const SIOCGIFADDR: ::libc::c_uint = 35093;
pub const SIOCSIFADDR: ::libc::c_uint = 35094;
pub const SIOCGIFDSTADDR: ::libc::c_uint = 35095;
pub const SIOCSIFDSTADDR: ::libc::c_uint = 35096;
pub const SIOCGIFBRDADDR: ::libc::c_uint = 35097;
pub const SIOCSIFBRDADDR: ::libc::c_uint = 35098;
pub const SIOCGIFNETMASK: ::libc::c_uint = 35099;
pub const SIOCSIFNETMASK: ::libc::c_uint = 35100;
pub const SIOCGIFMETRIC: ::libc::c_uint = 35101;
pub const SIOCSIFMETRIC: ::libc::c_uint = 35102;
pub const SIOCGIFMEM: ::libc::c_uint = 35103;
pub const SIOCSIFMEM: ::libc::c_uint = 35104;
pub const SIOCGIFMTU: ::libc::c_uint = 35105;
pub const SIOCSIFMTU: ::libc::c_uint = 35106;
pub const SIOCSIFNAME: ::libc::c_uint = 35107;
pub const SIOCSIFHWADDR: ::libc::c_uint = 35108;
pub const SIOCGIFENCAP: ::libc::c_uint = 35109;
pub const SIOCSIFENCAP: ::libc::c_uint = 35110;
pub const SIOCGIFHWADDR: ::libc::c_uint = 35111;
pub const SIOCGIFSLAVE: ::libc::c_uint = 35113;
pub const SIOCSIFSLAVE: ::libc::c_uint = 35120;
pub const SIOCADDMULTI: ::libc::c_uint = 35121;
pub const SIOCDELMULTI: ::libc::c_uint = 35122;
pub const SIOCGIFINDEX: ::libc::c_uint = 35123;
pub const SIOGIFINDEX: ::libc::c_uint = 35123;
pub const SIOCSIFPFLAGS: ::libc::c_uint = 35124;
pub const SIOCGIFPFLAGS: ::libc::c_uint = 35125;
pub const SIOCDIFADDR: ::libc::c_uint = 35126;
pub const SIOCSIFHWBROADCAST: ::libc::c_uint = 35127;
pub const SIOCGIFCOUNT: ::libc::c_uint = 35128;
pub const SIOCGIFBR: ::libc::c_uint = 35136;
pub const SIOCSIFBR: ::libc::c_uint = 35137;
pub const SIOCGIFTXQLEN: ::libc::c_uint = 35138;
pub const SIOCSIFTXQLEN: ::libc::c_uint = 35139;
pub const SIOCDARP: ::libc::c_uint = 35155;
pub const SIOCGARP: ::libc::c_uint = 35156;
pub const SIOCSARP: ::libc::c_uint = 35157;
pub const SIOCDRARP: ::libc::c_uint = 35168;
pub const SIOCGRARP: ::libc::c_uint = 35169;
pub const SIOCSRARP: ::libc::c_uint = 35170;
pub const SIOCGIFMAP: ::libc::c_uint = 35184;
pub const SIOCSIFMAP: ::libc::c_uint = 35185;
pub const SIOCADDDLCI: ::libc::c_uint = 35200;
pub const SIOCDELDLCI: ::libc::c_uint = 35201;
pub const SIOCDEVPRIVATE: ::libc::c_uint = 35312;
pub const SIOCPROTOPRIVATE: ::libc::c_uint = 35296;
pub const NCC: ::libc::c_uint = 8;
pub const TIOCM_LE: ::libc::c_uint = 1;
pub const TIOCM_DTR: ::libc::c_uint = 2;
pub const TIOCM_RTS: ::libc::c_uint = 4;
pub const TIOCM_ST: ::libc::c_uint = 8;
pub const TIOCM_SR: ::libc::c_uint = 16;
pub const TIOCM_CTS: ::libc::c_uint = 32;
pub const TIOCM_CAR: ::libc::c_uint = 64;
pub const TIOCM_RNG: ::libc::c_uint = 128;
pub const TIOCM_DSR: ::libc::c_uint = 256;
pub const TIOCM_CD: ::libc::c_uint = 64;
pub const TIOCM_RI: ::libc::c_uint = 128;
pub const N_TTY: ::libc::c_uint = 0;
pub const N_SLIP: ::libc::c_uint = 1;
pub const N_MOUSE: ::libc::c_uint = 2;
pub const N_PPP: ::libc::c_uint = 3;
pub const N_STRIP: ::libc::c_uint = 4;
pub const N_AX25: ::libc::c_uint = 5;
pub const N_X25: ::libc::c_uint = 6;
pub const N_6PACK: ::libc::c_uint = 7;
pub const N_MASC: ::libc::c_uint = 8;
pub const N_R3964: ::libc::c_uint = 9;
pub const N_PROFIBUS_FDL: ::libc::c_uint = 10;
pub const N_IRDA: ::libc::c_uint = 11;
pub const N_SMSBLOCK: ::libc::c_uint = 12;
pub const N_HDLC: ::libc::c_uint = 13;
pub const N_SYNC_PPP: ::libc::c_uint = 14;
pub const N_HCI: ::libc::c_uint = 15;
pub const CEOL: u8 = b'\x00';
pub const CERASE: ::libc::c_uint = 127;
pub const CSTATUS: u8 = b'\x00';
pub const CMIN: ::libc::c_uint = 1;
pub const CQUIT: ::libc::c_uint = 28;
pub const CTIME: ::libc::c_uint = 0;
pub const CBRK: u8 = b'\x00';
pub const MAXBSIZE: ::libc::c_uint = 8192;
pub const DEV_BSHIFT: ::libc::c_uint = 9;
pub const MAXNAMELEN: ::libc::c_uint = 256;
pub const UID_NOBODY: ::libc::c_uint = 60001;
pub const GID_NOBODY: ::libc::c_uint = 60001;
pub const UID_NOACCESS: ::libc::c_uint = 60002;
pub const MAXUID: ::libc::c_uint = 4294967295;
pub const MAXPROJID: ::libc::c_uint = 4294967295;
pub const _ALLOCA_H: ::libc::c_uint = 1;
pub const _SYS_TIME_H: ::libc::c_uint = 1;
pub const SEC: ::libc::c_uint = 1;
pub const MILLISEC: ::libc::c_uint = 1000;
pub const MICROSEC: ::libc::c_uint = 1000000;
pub const NANOSEC: ::libc::c_uint = 1000000000;
pub const NSEC_PER_USEC: ::libc::c_uint = 1000;
pub const _ERRNO_H: ::libc::c_uint = 1;
pub const EPERM: ::libc::c_uint = 1;
pub const ENOENT: ::libc::c_uint = 2;
pub const ESRCH: ::libc::c_uint = 3;
pub const EINTR: ::libc::c_uint = 4;
pub const EIO: ::libc::c_uint = 5;
pub const ENXIO: ::libc::c_uint = 6;
pub const E2BIG: ::libc::c_uint = 7;
pub const ENOEXEC: ::libc::c_uint = 8;
pub const EBADF: ::libc::c_uint = 9;
pub const ECHILD: ::libc::c_uint = 10;
pub const EAGAIN: ::libc::c_uint = 11;
pub const ENOMEM: ::libc::c_uint = 12;
pub const EACCES: ::libc::c_uint = 13;
pub const EFAULT: ::libc::c_uint = 14;
pub const ENOTBLK: ::libc::c_uint = 15;
pub const EBUSY: ::libc::c_uint = 16;
pub const EEXIST: ::libc::c_uint = 17;
pub const EXDEV: ::libc::c_uint = 18;
pub const ENODEV: ::libc::c_uint = 19;
pub const ENOTDIR: ::libc::c_uint = 20;
pub const EISDIR: ::libc::c_uint = 21;
pub const EINVAL: ::libc::c_uint = 22;
pub const ENFILE: ::libc::c_uint = 23;
pub const EMFILE: ::libc::c_uint = 24;
pub const ENOTTY: ::libc::c_uint = 25;
pub const ETXTBSY: ::libc::c_uint = 26;
pub const EFBIG: ::libc::c_uint = 27;
pub const ENOSPC: ::libc::c_uint = 28;
pub const ESPIPE: ::libc::c_uint = 29;
pub const EROFS: ::libc::c_uint = 30;
pub const EMLINK: ::libc::c_uint = 31;
pub const EPIPE: ::libc::c_uint = 32;
pub const EDOM: ::libc::c_uint = 33;
pub const ERANGE: ::libc::c_uint = 34;
pub const EDEADLK: ::libc::c_uint = 35;
pub const ENAMETOOLONG: ::libc::c_uint = 36;
pub const ENOLCK: ::libc::c_uint = 37;
pub const ENOSYS: ::libc::c_uint = 38;
pub const ENOTEMPTY: ::libc::c_uint = 39;
pub const ELOOP: ::libc::c_uint = 40;
pub const EWOULDBLOCK: ::libc::c_uint = 11;
pub const ENOMSG: ::libc::c_uint = 42;
pub const EIDRM: ::libc::c_uint = 43;
pub const ECHRNG: ::libc::c_uint = 44;
pub const EL2NSYNC: ::libc::c_uint = 45;
pub const EL3HLT: ::libc::c_uint = 46;
pub const EL3RST: ::libc::c_uint = 47;
pub const ELNRNG: ::libc::c_uint = 48;
pub const EUNATCH: ::libc::c_uint = 49;
pub const ENOCSI: ::libc::c_uint = 50;
pub const EL2HLT: ::libc::c_uint = 51;
pub const EBADE: ::libc::c_uint = 52;
pub const EBADR: ::libc::c_uint = 53;
pub const EXFULL: ::libc::c_uint = 54;
pub const ENOANO: ::libc::c_uint = 55;
pub const EBADRQC: ::libc::c_uint = 56;
pub const EBADSLT: ::libc::c_uint = 57;
pub const EDEADLOCK: ::libc::c_uint = 35;
pub const EBFONT: ::libc::c_uint = 59;
pub const ENOSTR: ::libc::c_uint = 60;
pub const ENODATA: ::libc::c_uint = 61;
pub const ETIME: ::libc::c_uint = 62;
pub const ENOSR: ::libc::c_uint = 63;
pub const ENONET: ::libc::c_uint = 64;
pub const ENOPKG: ::libc::c_uint = 65;
pub const EREMOTE: ::libc::c_uint = 66;
pub const ENOLINK: ::libc::c_uint = 67;
pub const EADV: ::libc::c_uint = 68;
pub const ESRMNT: ::libc::c_uint = 69;
pub const ECOMM: ::libc::c_uint = 70;
pub const EPROTO: ::libc::c_uint = 71;
pub const EMULTIHOP: ::libc::c_uint = 72;
pub const EDOTDOT: ::libc::c_uint = 73;
pub const EBADMSG: ::libc::c_uint = 74;
pub const EOVERFLOW: ::libc::c_uint = 75;
pub const ENOTUNIQ: ::libc::c_uint = 76;
pub const EBADFD: ::libc::c_uint = 77;
pub const EREMCHG: ::libc::c_uint = 78;
pub const ELIBACC: ::libc::c_uint = 79;
pub const ELIBBAD: ::libc::c_uint = 80;
pub const ELIBSCN: ::libc::c_uint = 81;
pub const ELIBMAX: ::libc::c_uint = 82;
pub const ELIBEXEC: ::libc::c_uint = 83;
pub const EILSEQ: ::libc::c_uint = 84;
pub const ERESTART: ::libc::c_uint = 85;
pub const ESTRPIPE: ::libc::c_uint = 86;
pub const EUSERS: ::libc::c_uint = 87;
pub const ENOTSOCK: ::libc::c_uint = 88;
pub const EDESTADDRREQ: ::libc::c_uint = 89;
pub const EMSGSIZE: ::libc::c_uint = 90;
pub const EPROTOTYPE: ::libc::c_uint = 91;
pub const ENOPROTOOPT: ::libc::c_uint = 92;
pub const EPROTONOSUPPORT: ::libc::c_uint = 93;
pub const ESOCKTNOSUPPORT: ::libc::c_uint = 94;
pub const EOPNOTSUPP: ::libc::c_uint = 95;
pub const EPFNOSUPPORT: ::libc::c_uint = 96;
pub const EAFNOSUPPORT: ::libc::c_uint = 97;
pub const EADDRINUSE: ::libc::c_uint = 98;
pub const EADDRNOTAVAIL: ::libc::c_uint = 99;
pub const ENETDOWN: ::libc::c_uint = 100;
pub const ENETUNREACH: ::libc::c_uint = 101;
pub const ENETRESET: ::libc::c_uint = 102;
pub const ECONNABORTED: ::libc::c_uint = 103;
pub const ECONNRESET: ::libc::c_uint = 104;
pub const ENOBUFS: ::libc::c_uint = 105;
pub const EISCONN: ::libc::c_uint = 106;
pub const ENOTCONN: ::libc::c_uint = 107;
pub const ESHUTDOWN: ::libc::c_uint = 108;
pub const ETOOMANYREFS: ::libc::c_uint = 109;
pub const ETIMEDOUT: ::libc::c_uint = 110;
pub const ECONNREFUSED: ::libc::c_uint = 111;
pub const EHOSTDOWN: ::libc::c_uint = 112;
pub const EHOSTUNREACH: ::libc::c_uint = 113;
pub const EALREADY: ::libc::c_uint = 114;
pub const EINPROGRESS: ::libc::c_uint = 115;
pub const ESTALE: ::libc::c_uint = 116;
pub const EUCLEAN: ::libc::c_uint = 117;
pub const ENOTNAM: ::libc::c_uint = 118;
pub const ENAVAIL: ::libc::c_uint = 119;
pub const EISNAM: ::libc::c_uint = 120;
pub const EREMOTEIO: ::libc::c_uint = 121;
pub const EDQUOT: ::libc::c_uint = 122;
pub const ENOMEDIUM: ::libc::c_uint = 123;
pub const EMEDIUMTYPE: ::libc::c_uint = 124;
pub const ECANCELED: ::libc::c_uint = 125;
pub const ENOKEY: ::libc::c_uint = 126;
pub const EKEYEXPIRED: ::libc::c_uint = 127;
pub const EKEYREVOKED: ::libc::c_uint = 128;
pub const EKEYREJECTED: ::libc::c_uint = 129;
pub const EOWNERDEAD: ::libc::c_uint = 130;
pub const ENOTRECOVERABLE: ::libc::c_uint = 131;
pub const ERFKILL: ::libc::c_uint = 132;
pub const EHWPOISON: ::libc::c_uint = 133;
pub const ENOTSUP: ::libc::c_uint = 95;
pub const NV_VERSION: ::libc::c_uint = 0;
pub const NV_ENCODE_NATIVE: ::libc::c_uint = 0;
pub const NV_ENCODE_XDR: ::libc::c_uint = 1;
pub const NV_UNIQUE_NAME: ::libc::c_uint = 1;
pub const NV_UNIQUE_NAME_TYPE: ::libc::c_uint = 2;
pub const NV_FLAG_NOENTOK: ::libc::c_uint = 1;
pub const _REGEX_H: ::libc::c_uint = 1;
pub const REG_EXTENDED: ::libc::c_uint = 1;
pub const REG_ICASE: ::libc::c_uint = 2;
pub const REG_NEWLINE: ::libc::c_uint = 4;
pub const REG_NOSUB: ::libc::c_uint = 8;
pub const REG_NOTBOL: ::libc::c_uint = 1;
pub const REG_NOTEOL: ::libc::c_uint = 2;
pub const REG_STARTEND: ::libc::c_uint = 4;
pub const _MNTENT_H: ::libc::c_uint = 1;
pub const _PATH_DEFPATH: &'static [u8; 14usize] = b"/usr/bin:/bin\x00";
pub const _PATH_STDPATH: &'static [u8; 30usize] =
    b"/usr/bin:/bin:/usr/sbin:/sbin\x00";
pub const _PATH_BSHELL: &'static [u8; 8usize] = b"/bin/sh\x00";
pub const _PATH_CONSOLE: &'static [u8; 13usize] = b"/dev/console\x00";
pub const _PATH_CSHELL: &'static [u8; 9usize] = b"/bin/csh\x00";
pub const _PATH_DEVDB: &'static [u8; 16usize] = b"/var/run/dev.db\x00";
pub const _PATH_DEVNULL: &'static [u8; 10usize] = b"/dev/null\x00";
pub const _PATH_DRUM: &'static [u8; 10usize] = b"/dev/drum\x00";
pub const _PATH_GSHADOW: &'static [u8; 13usize] = b"/etc/gshadow\x00";
pub const _PATH_KLOG: &'static [u8; 11usize] = b"/proc/kmsg\x00";
pub const _PATH_KMEM: &'static [u8; 10usize] = b"/dev/kmem\x00";
pub const _PATH_LASTLOG: &'static [u8; 17usize] = b"/var/log/lastlog\x00";
pub const _PATH_MAILDIR: &'static [u8; 10usize] = b"/var/mail\x00";
pub const _PATH_MAN: &'static [u8; 15usize] = b"/usr/share/man\x00";
pub const _PATH_MEM: &'static [u8; 9usize] = b"/dev/mem\x00";
pub const _PATH_MNTTAB: &'static [u8; 11usize] = b"/etc/fstab\x00";
pub const _PATH_MOUNTED: &'static [u8; 10usize] = b"/etc/mtab\x00";
pub const _PATH_NOLOGIN: &'static [u8; 13usize] = b"/etc/nologin\x00";
pub const _PATH_PRESERVE: &'static [u8; 9usize] = b"/var/lib\x00";
pub const _PATH_RWHODIR: &'static [u8; 16usize] = b"/var/spool/rwho\x00";
pub const _PATH_SENDMAIL: &'static [u8; 19usize] = b"/usr/sbin/sendmail\x00";
pub const _PATH_SHADOW: &'static [u8; 12usize] = b"/etc/shadow\x00";
pub const _PATH_SHELLS: &'static [u8; 12usize] = b"/etc/shells\x00";
pub const _PATH_TTY: &'static [u8; 9usize] = b"/dev/tty\x00";
pub const _PATH_UNIX: &'static [u8; 14usize] = b"/boot/vmlinux\x00";
pub const _PATH_UTMP: &'static [u8; 14usize] = b"/var/run/utmp\x00";
pub const _PATH_VI: &'static [u8; 12usize] = b"/usr/bin/vi\x00";
pub const _PATH_WTMP: &'static [u8; 14usize] = b"/var/log/wtmp\x00";
pub const _PATH_DEV: &'static [u8; 6usize] = b"/dev/\x00";
pub const _PATH_TMP: &'static [u8; 6usize] = b"/tmp/\x00";
pub const _PATH_VARDB: &'static [u8; 9usize] = b"/var/db/\x00";
pub const _PATH_VARRUN: &'static [u8; 10usize] = b"/var/run/\x00";
pub const _PATH_VARTMP: &'static [u8; 10usize] = b"/var/tmp/\x00";
pub const MNTTAB: &'static [u8; 11usize] = b"/etc/fstab\x00";
pub const MOUNTED: &'static [u8; 10usize] = b"/etc/mtab\x00";
pub const MNTTYPE_IGNORE: &'static [u8; 7usize] = b"ignore\x00";
pub const MNTTYPE_NFS: &'static [u8; 4usize] = b"nfs\x00";
pub const MNTTYPE_SWAP: &'static [u8; 5usize] = b"swap\x00";
pub const MNTOPT_DEFAULTS: &'static [u8; 9usize] = b"defaults\x00";
pub const MNTOPT_RO: &'static [u8; 3usize] = b"ro\x00";
pub const MNTOPT_RW: &'static [u8; 3usize] = b"rw\x00";
pub const MNTOPT_SUID: &'static [u8; 5usize] = b"suid\x00";
pub const MNTOPT_NOSUID: &'static [u8; 7usize] = b"nosuid\x00";
pub const MNTOPT_NOAUTO: &'static [u8; 7usize] = b"noauto\x00";
pub const MNT_LINE_MAX: ::libc::c_uint = 4096;
pub const MNT_TOOLONG: ::libc::c_uint = 1;
pub const MNT_TOOMANY: ::libc::c_uint = 2;
pub const MNT_TOOFEW: ::libc::c_uint = 3;
pub const ZAP_MAXNAMELEN: ::libc::c_uint = 256;
pub const ZAP_MAXVALUELEN: ::libc::c_uint = 8192;
pub const ZAP_OLDMAXVALUELEN: ::libc::c_uint = 1024;
pub const ZFS_MAX_DATASET_NAME_LEN: ::libc::c_uint = 256;
pub const ZPROP_MAX_COMMENT: ::libc::c_uint = 32;
pub const ZPROP_CONT: ::libc::c_int = -2;
pub const ZPROP_INVAL: ::libc::c_int = -1;
pub const ZPROP_VALUE: &'static [u8; 6usize] = b"value\x00";
pub const ZPROP_SOURCE: &'static [u8; 7usize] = b"source\x00";
pub const ZPROP_SRC_ALL: ::libc::c_uint = 63;
pub const ZPROP_SOURCE_VAL_RECVD: &'static [u8; 7usize] = b"$recvd\x00";
pub const ZPROP_N_MORE_ERRORS: &'static [u8; 14usize] = b"N_MORE_ERRORS\x00";
pub const ZPROP_HAS_RECVD: &'static [u8; 10usize] = b"$hasrecvd\x00";
pub const ZPOOL_ROOTFS_PROPS: &'static [u8; 15usize] = b"root-props-nvl\x00";
pub const ZFS_DELEG_PERM_UID: &'static [u8; 4usize] = b"uid\x00";
pub const ZFS_DELEG_PERM_GID: &'static [u8; 4usize] = b"gid\x00";
pub const ZFS_DELEG_PERM_GROUPS: &'static [u8; 7usize] = b"groups\x00";
pub const ZFS_MLSLABEL_DEFAULT: &'static [u8; 5usize] = b"none\x00";
pub const ZFS_SMB_ACL_SRC: &'static [u8; 4usize] = b"src\x00";
pub const ZFS_SMB_ACL_TARGET: &'static [u8; 7usize] = b"target\x00";
pub const SPA_VERSION_1: ::libc::c_uint = 1;
pub const SPA_VERSION_2: ::libc::c_uint = 2;
pub const SPA_VERSION_3: ::libc::c_uint = 3;
pub const SPA_VERSION_4: ::libc::c_uint = 4;
pub const SPA_VERSION_5: ::libc::c_uint = 5;
pub const SPA_VERSION_6: ::libc::c_uint = 6;
pub const SPA_VERSION_7: ::libc::c_uint = 7;
pub const SPA_VERSION_8: ::libc::c_uint = 8;
pub const SPA_VERSION_9: ::libc::c_uint = 9;
pub const SPA_VERSION_10: ::libc::c_uint = 10;
pub const SPA_VERSION_11: ::libc::c_uint = 11;
pub const SPA_VERSION_12: ::libc::c_uint = 12;
pub const SPA_VERSION_13: ::libc::c_uint = 13;
pub const SPA_VERSION_14: ::libc::c_uint = 14;
pub const SPA_VERSION_15: ::libc::c_uint = 15;
pub const SPA_VERSION_16: ::libc::c_uint = 16;
pub const SPA_VERSION_17: ::libc::c_uint = 17;
pub const SPA_VERSION_18: ::libc::c_uint = 18;
pub const SPA_VERSION_19: ::libc::c_uint = 19;
pub const SPA_VERSION_20: ::libc::c_uint = 20;
pub const SPA_VERSION_21: ::libc::c_uint = 21;
pub const SPA_VERSION_22: ::libc::c_uint = 22;
pub const SPA_VERSION_23: ::libc::c_uint = 23;
pub const SPA_VERSION_24: ::libc::c_uint = 24;
pub const SPA_VERSION_25: ::libc::c_uint = 25;
pub const SPA_VERSION_26: ::libc::c_uint = 26;
pub const SPA_VERSION_27: ::libc::c_uint = 27;
pub const SPA_VERSION_28: ::libc::c_uint = 28;
pub const SPA_VERSION_5000: ::libc::c_uint = 5000;
pub const SPA_VERSION: ::libc::c_uint = 5000;
pub const SPA_VERSION_STRING: &'static [u8; 5usize] = b"5000\x00";
pub const SPA_VERSION_INITIAL: ::libc::c_uint = 1;
pub const SPA_VERSION_DITTO_BLOCKS: ::libc::c_uint = 2;
pub const SPA_VERSION_SPARES: ::libc::c_uint = 3;
pub const SPA_VERSION_RAIDZ2: ::libc::c_uint = 3;
pub const SPA_VERSION_BPOBJ_ACCOUNT: ::libc::c_uint = 3;
pub const SPA_VERSION_RAIDZ_DEFLATE: ::libc::c_uint = 3;
pub const SPA_VERSION_DNODE_BYTES: ::libc::c_uint = 3;
pub const SPA_VERSION_ZPOOL_HISTORY: ::libc::c_uint = 4;
pub const SPA_VERSION_GZIP_COMPRESSION: ::libc::c_uint = 5;
pub const SPA_VERSION_BOOTFS: ::libc::c_uint = 6;
pub const SPA_VERSION_SLOGS: ::libc::c_uint = 7;
pub const SPA_VERSION_DELEGATED_PERMS: ::libc::c_uint = 8;
pub const SPA_VERSION_FUID: ::libc::c_uint = 9;
pub const SPA_VERSION_REFRESERVATION: ::libc::c_uint = 9;
pub const SPA_VERSION_REFQUOTA: ::libc::c_uint = 9;
pub const SPA_VERSION_UNIQUE_ACCURATE: ::libc::c_uint = 9;
pub const SPA_VERSION_L2CACHE: ::libc::c_uint = 10;
pub const SPA_VERSION_NEXT_CLONES: ::libc::c_uint = 11;
pub const SPA_VERSION_ORIGIN: ::libc::c_uint = 11;
pub const SPA_VERSION_DSL_SCRUB: ::libc::c_uint = 11;
pub const SPA_VERSION_SNAP_PROPS: ::libc::c_uint = 12;
pub const SPA_VERSION_USED_BREAKDOWN: ::libc::c_uint = 13;
pub const SPA_VERSION_PASSTHROUGH_X: ::libc::c_uint = 14;
pub const SPA_VERSION_USERSPACE: ::libc::c_uint = 15;
pub const SPA_VERSION_STMF_PROP: ::libc::c_uint = 16;
pub const SPA_VERSION_RAIDZ3: ::libc::c_uint = 17;
pub const SPA_VERSION_USERREFS: ::libc::c_uint = 18;
pub const SPA_VERSION_HOLES: ::libc::c_uint = 19;
pub const SPA_VERSION_ZLE_COMPRESSION: ::libc::c_uint = 20;
pub const SPA_VERSION_DEDUP: ::libc::c_uint = 21;
pub const SPA_VERSION_RECVD_PROPS: ::libc::c_uint = 22;
pub const SPA_VERSION_SLIM_ZIL: ::libc::c_uint = 23;
pub const SPA_VERSION_SA: ::libc::c_uint = 24;
pub const SPA_VERSION_SCAN: ::libc::c_uint = 25;
pub const SPA_VERSION_DIR_CLONES: ::libc::c_uint = 26;
pub const SPA_VERSION_DEADLISTS: ::libc::c_uint = 26;
pub const SPA_VERSION_FAST_SNAP: ::libc::c_uint = 27;
pub const SPA_VERSION_MULTI_REPLACE: ::libc::c_uint = 28;
pub const SPA_VERSION_BEFORE_FEATURES: ::libc::c_uint = 28;
pub const SPA_VERSION_FEATURES: ::libc::c_uint = 5000;
pub const ZPL_VERSION_1: ::libc::c_uint = 1;
pub const ZPL_VERSION_2: ::libc::c_uint = 2;
pub const ZPL_VERSION_3: ::libc::c_uint = 3;
pub const ZPL_VERSION_4: ::libc::c_uint = 4;
pub const ZPL_VERSION_5: ::libc::c_uint = 5;
pub const ZPL_VERSION: ::libc::c_uint = 5;
pub const ZPL_VERSION_STRING: &'static [u8; 2usize] = b"5\x00";
pub const ZPL_VERSION_INITIAL: ::libc::c_uint = 1;
pub const ZPL_VERSION_DIRENT_TYPE: ::libc::c_uint = 2;
pub const ZPL_VERSION_FUID: ::libc::c_uint = 3;
pub const ZPL_VERSION_NORMALIZATION: ::libc::c_uint = 3;
pub const ZPL_VERSION_SYSATTR: ::libc::c_uint = 3;
pub const ZPL_VERSION_USERSPACE: ::libc::c_uint = 4;
pub const ZPL_VERSION_SA: ::libc::c_uint = 5;
pub const ZPOOL_NO_REWIND: ::libc::c_uint = 1;
pub const ZPOOL_NEVER_REWIND: ::libc::c_uint = 2;
pub const ZPOOL_TRY_REWIND: ::libc::c_uint = 4;
pub const ZPOOL_DO_REWIND: ::libc::c_uint = 8;
pub const ZPOOL_EXTREME_REWIND: ::libc::c_uint = 16;
pub const ZPOOL_REWIND_MASK: ::libc::c_uint = 28;
pub const ZPOOL_REWIND_POLICIES: ::libc::c_uint = 31;
pub const ZPOOL_CONFIG_VERSION: &'static [u8; 8usize] = b"version\x00";
pub const ZPOOL_CONFIG_POOL_NAME: &'static [u8; 5usize] = b"name\x00";
pub const ZPOOL_CONFIG_POOL_STATE: &'static [u8; 6usize] = b"state\x00";
pub const ZPOOL_CONFIG_POOL_TXG: &'static [u8; 4usize] = b"txg\x00";
pub const ZPOOL_CONFIG_POOL_GUID: &'static [u8; 10usize] = b"pool_guid\x00";
pub const ZPOOL_CONFIG_CREATE_TXG: &'static [u8; 11usize] = b"create_txg\x00";
pub const ZPOOL_CONFIG_TOP_GUID: &'static [u8; 9usize] = b"top_guid\x00";
pub const ZPOOL_CONFIG_VDEV_TREE: &'static [u8; 10usize] = b"vdev_tree\x00";
pub const ZPOOL_CONFIG_TYPE: &'static [u8; 5usize] = b"type\x00";
pub const ZPOOL_CONFIG_CHILDREN: &'static [u8; 9usize] = b"children\x00";
pub const ZPOOL_CONFIG_ID: &'static [u8; 3usize] = b"id\x00";
pub const ZPOOL_CONFIG_GUID: &'static [u8; 5usize] = b"guid\x00";
pub const ZPOOL_CONFIG_PATH: &'static [u8; 5usize] = b"path\x00";
pub const ZPOOL_CONFIG_DEVID: &'static [u8; 6usize] = b"devid\x00";
pub const ZPOOL_CONFIG_METASLAB_ARRAY: &'static [u8; 15usize] =
    b"metaslab_array\x00";
pub const ZPOOL_CONFIG_METASLAB_SHIFT: &'static [u8; 15usize] =
    b"metaslab_shift\x00";
pub const ZPOOL_CONFIG_ASHIFT: &'static [u8; 7usize] = b"ashift\x00";
pub const ZPOOL_CONFIG_ASIZE: &'static [u8; 6usize] = b"asize\x00";
pub const ZPOOL_CONFIG_DTL: &'static [u8; 4usize] = b"DTL\x00";
pub const ZPOOL_CONFIG_SCAN_STATS: &'static [u8; 11usize] = b"scan_stats\x00";
pub const ZPOOL_CONFIG_VDEV_STATS: &'static [u8; 11usize] = b"vdev_stats\x00";
pub const ZPOOL_CONFIG_VDEV_STATS_EX: &'static [u8; 14usize] =
    b"vdev_stats_ex\x00";
pub const ZPOOL_CONFIG_VDEV_SYNC_R_ACTIVE_QUEUE: &'static [u8; 25usize] =
    b"vdev_sync_r_active_queue\x00";
pub const ZPOOL_CONFIG_VDEV_SYNC_W_ACTIVE_QUEUE: &'static [u8; 25usize] =
    b"vdev_sync_w_active_queue\x00";
pub const ZPOOL_CONFIG_VDEV_ASYNC_R_ACTIVE_QUEUE: &'static [u8; 26usize] =
    b"vdev_async_r_active_queue\x00";
pub const ZPOOL_CONFIG_VDEV_ASYNC_W_ACTIVE_QUEUE: &'static [u8; 26usize] =
    b"vdev_async_w_active_queue\x00";
pub const ZPOOL_CONFIG_VDEV_SCRUB_ACTIVE_QUEUE: &'static [u8; 30usize] =
    b"vdev_async_scrub_active_queue\x00";
pub const ZPOOL_CONFIG_VDEV_SYNC_R_PEND_QUEUE: &'static [u8; 23usize] =
    b"vdev_sync_r_pend_queue\x00";
pub const ZPOOL_CONFIG_VDEV_SYNC_W_PEND_QUEUE: &'static [u8; 23usize] =
    b"vdev_sync_w_pend_queue\x00";
pub const ZPOOL_CONFIG_VDEV_ASYNC_R_PEND_QUEUE: &'static [u8; 24usize] =
    b"vdev_async_r_pend_queue\x00";
pub const ZPOOL_CONFIG_VDEV_ASYNC_W_PEND_QUEUE: &'static [u8; 24usize] =
    b"vdev_async_w_pend_queue\x00";
pub const ZPOOL_CONFIG_VDEV_SCRUB_PEND_QUEUE: &'static [u8; 28usize] =
    b"vdev_async_scrub_pend_queue\x00";
pub const ZPOOL_CONFIG_VDEV_TOT_R_LAT_HISTO: &'static [u8; 21usize] =
    b"vdev_tot_r_lat_histo\x00";
pub const ZPOOL_CONFIG_VDEV_TOT_W_LAT_HISTO: &'static [u8; 21usize] =
    b"vdev_tot_w_lat_histo\x00";
pub const ZPOOL_CONFIG_VDEV_DISK_R_LAT_HISTO: &'static [u8; 22usize] =
    b"vdev_disk_r_lat_histo\x00";
pub const ZPOOL_CONFIG_VDEV_DISK_W_LAT_HISTO: &'static [u8; 22usize] =
    b"vdev_disk_w_lat_histo\x00";
pub const ZPOOL_CONFIG_VDEV_SYNC_R_LAT_HISTO: &'static [u8; 22usize] =
    b"vdev_sync_r_lat_histo\x00";
pub const ZPOOL_CONFIG_VDEV_SYNC_W_LAT_HISTO: &'static [u8; 22usize] =
    b"vdev_sync_w_lat_histo\x00";
pub const ZPOOL_CONFIG_VDEV_ASYNC_R_LAT_HISTO: &'static [u8; 23usize] =
    b"vdev_async_r_lat_histo\x00";
pub const ZPOOL_CONFIG_VDEV_ASYNC_W_LAT_HISTO: &'static [u8; 23usize] =
    b"vdev_async_w_lat_histo\x00";
pub const ZPOOL_CONFIG_VDEV_SCRUB_LAT_HISTO: &'static [u8; 17usize] =
    b"vdev_scrub_histo\x00";
pub const ZPOOL_CONFIG_VDEV_SYNC_IND_R_HISTO: &'static [u8; 22usize] =
    b"vdev_sync_ind_r_histo\x00";
pub const ZPOOL_CONFIG_VDEV_SYNC_IND_W_HISTO: &'static [u8; 22usize] =
    b"vdev_sync_ind_w_histo\x00";
pub const ZPOOL_CONFIG_VDEV_ASYNC_IND_R_HISTO: &'static [u8; 23usize] =
    b"vdev_async_ind_r_histo\x00";
pub const ZPOOL_CONFIG_VDEV_ASYNC_IND_W_HISTO: &'static [u8; 23usize] =
    b"vdev_async_ind_w_histo\x00";
pub const ZPOOL_CONFIG_VDEV_IND_SCRUB_HISTO: &'static [u8; 21usize] =
    b"vdev_ind_scrub_histo\x00";
pub const ZPOOL_CONFIG_VDEV_SYNC_AGG_R_HISTO: &'static [u8; 22usize] =
    b"vdev_sync_agg_r_histo\x00";
pub const ZPOOL_CONFIG_VDEV_SYNC_AGG_W_HISTO: &'static [u8; 22usize] =
    b"vdev_sync_agg_w_histo\x00";
pub const ZPOOL_CONFIG_VDEV_ASYNC_AGG_R_HISTO: &'static [u8; 23usize] =
    b"vdev_async_agg_r_histo\x00";
pub const ZPOOL_CONFIG_VDEV_ASYNC_AGG_W_HISTO: &'static [u8; 23usize] =
    b"vdev_async_agg_w_histo\x00";
pub const ZPOOL_CONFIG_VDEV_AGG_SCRUB_HISTO: &'static [u8; 21usize] =
    b"vdev_agg_scrub_histo\x00";
pub const ZPOOL_CONFIG_VDEV_ENC_SYSFS_PATH: &'static [u8; 20usize] =
    b"vdev_enc_sysfs_path\x00";
pub const ZPOOL_CONFIG_WHOLE_DISK: &'static [u8; 11usize] = b"whole_disk\x00";
pub const ZPOOL_CONFIG_ERRCOUNT: &'static [u8; 12usize] = b"error_count\x00";
pub const ZPOOL_CONFIG_NOT_PRESENT: &'static [u8; 12usize] =
    b"not_present\x00";
pub const ZPOOL_CONFIG_SPARES: &'static [u8; 7usize] = b"spares\x00";
pub const ZPOOL_CONFIG_IS_SPARE: &'static [u8; 9usize] = b"is_spare\x00";
pub const ZPOOL_CONFIG_NPARITY: &'static [u8; 8usize] = b"nparity\x00";
pub const ZPOOL_CONFIG_HOSTID: &'static [u8; 7usize] = b"hostid\x00";
pub const ZPOOL_CONFIG_HOSTNAME: &'static [u8; 9usize] = b"hostname\x00";
pub const ZPOOL_CONFIG_LOADED_TIME: &'static [u8; 18usize] =
    b"initial_load_time\x00";
pub const ZPOOL_CONFIG_UNSPARE: &'static [u8; 8usize] = b"unspare\x00";
pub const ZPOOL_CONFIG_PHYS_PATH: &'static [u8; 10usize] = b"phys_path\x00";
pub const ZPOOL_CONFIG_IS_LOG: &'static [u8; 7usize] = b"is_log\x00";
pub const ZPOOL_CONFIG_L2CACHE: &'static [u8; 8usize] = b"l2cache\x00";
pub const ZPOOL_CONFIG_HOLE_ARRAY: &'static [u8; 11usize] = b"hole_array\x00";
pub const ZPOOL_CONFIG_VDEV_CHILDREN: &'static [u8; 14usize] =
    b"vdev_children\x00";
pub const ZPOOL_CONFIG_IS_HOLE: &'static [u8; 8usize] = b"is_hole\x00";
pub const ZPOOL_CONFIG_DDT_HISTOGRAM: &'static [u8; 14usize] =
    b"ddt_histogram\x00";
pub const ZPOOL_CONFIG_DDT_OBJ_STATS: &'static [u8; 17usize] =
    b"ddt_object_stats\x00";
pub const ZPOOL_CONFIG_DDT_STATS: &'static [u8; 10usize] = b"ddt_stats\x00";
pub const ZPOOL_CONFIG_SPLIT: &'static [u8; 9usize] = b"splitcfg\x00";
pub const ZPOOL_CONFIG_ORIG_GUID: &'static [u8; 10usize] = b"orig_guid\x00";
pub const ZPOOL_CONFIG_SPLIT_GUID: &'static [u8; 11usize] = b"split_guid\x00";
pub const ZPOOL_CONFIG_SPLIT_LIST: &'static [u8; 10usize] = b"guid_list\x00";
pub const ZPOOL_CONFIG_REMOVING: &'static [u8; 9usize] = b"removing\x00";
pub const ZPOOL_CONFIG_RESILVER_TXG: &'static [u8; 13usize] =
    b"resilver_txg\x00";
pub const ZPOOL_CONFIG_COMMENT: &'static [u8; 8usize] = b"comment\x00";
pub const ZPOOL_CONFIG_SUSPENDED: &'static [u8; 10usize] = b"suspended\x00";
pub const ZPOOL_CONFIG_TIMESTAMP: &'static [u8; 10usize] = b"timestamp\x00";
pub const ZPOOL_CONFIG_BOOTFS: &'static [u8; 7usize] = b"bootfs\x00";
pub const ZPOOL_CONFIG_MISSING_DEVICES: &'static [u8; 14usize] =
    b"missing_vdevs\x00";
pub const ZPOOL_CONFIG_LOAD_INFO: &'static [u8; 10usize] = b"load_info\x00";
pub const ZPOOL_CONFIG_REWIND_INFO: &'static [u8; 12usize] =
    b"rewind_info\x00";
pub const ZPOOL_CONFIG_UNSUP_FEAT: &'static [u8; 11usize] = b"unsup_feat\x00";
pub const ZPOOL_CONFIG_ENABLED_FEAT: &'static [u8; 13usize] =
    b"enabled_feat\x00";
pub const ZPOOL_CONFIG_CAN_RDONLY: &'static [u8; 11usize] = b"can_rdonly\x00";
pub const ZPOOL_CONFIG_FEATURES_FOR_READ: &'static [u8; 18usize] =
    b"features_for_read\x00";
pub const ZPOOL_CONFIG_FEATURE_STATS: &'static [u8; 14usize] =
    b"feature_stats\x00";
pub const ZPOOL_CONFIG_ERRATA: &'static [u8; 7usize] = b"errata\x00";
pub const ZPOOL_CONFIG_VDEV_TOP_ZAP: &'static [u8; 25usize] =
    b"com.delphix:vdev_zap_top\x00";
pub const ZPOOL_CONFIG_VDEV_LEAF_ZAP: &'static [u8; 26usize] =
    b"com.delphix:vdev_zap_leaf\x00";
pub const ZPOOL_CONFIG_HAS_PER_VDEV_ZAPS: &'static [u8; 30usize] =
    b"com.delphix:has_per_vdev_zaps\x00";
pub const ZPOOL_CONFIG_MMP_STATE: &'static [u8; 10usize] = b"mmp_state\x00";
pub const ZPOOL_CONFIG_MMP_TXG: &'static [u8; 8usize] = b"mmp_txg\x00";
pub const ZPOOL_CONFIG_MMP_HOSTNAME: &'static [u8; 13usize] =
    b"mmp_hostname\x00";
pub const ZPOOL_CONFIG_MMP_HOSTID: &'static [u8; 11usize] = b"mmp_hostid\x00";
pub const ZPOOL_CONFIG_OFFLINE: &'static [u8; 8usize] = b"offline\x00";
pub const ZPOOL_CONFIG_FAULTED: &'static [u8; 8usize] = b"faulted\x00";
pub const ZPOOL_CONFIG_DEGRADED: &'static [u8; 9usize] = b"degraded\x00";
pub const ZPOOL_CONFIG_REMOVED: &'static [u8; 8usize] = b"removed\x00";
pub const ZPOOL_CONFIG_FRU: &'static [u8; 4usize] = b"fru\x00";
pub const ZPOOL_CONFIG_AUX_STATE: &'static [u8; 10usize] = b"aux_state\x00";
pub const ZPOOL_REWIND_POLICY: &'static [u8; 14usize] = b"rewind-policy\x00";
pub const ZPOOL_REWIND_REQUEST: &'static [u8; 15usize] =
    b"rewind-request\x00";
pub const ZPOOL_REWIND_REQUEST_TXG: &'static [u8; 19usize] =
    b"rewind-request-txg\x00";
pub const ZPOOL_REWIND_META_THRESH: &'static [u8; 19usize] =
    b"rewind-meta-thresh\x00";
pub const ZPOOL_REWIND_DATA_THRESH: &'static [u8; 19usize] =
    b"rewind-data-thresh\x00";
pub const ZPOOL_CONFIG_LOAD_TIME: &'static [u8; 14usize] =
    b"rewind_txg_ts\x00";
pub const ZPOOL_CONFIG_LOAD_DATA_ERRORS: &'static [u8; 19usize] =
    b"verify_data_errors\x00";
pub const ZPOOL_CONFIG_REWIND_TIME: &'static [u8; 18usize] =
    b"seconds_of_rewind\x00";
pub const VDEV_TYPE_ROOT: &'static [u8; 5usize] = b"root\x00";
pub const VDEV_TYPE_MIRROR: &'static [u8; 7usize] = b"mirror\x00";
pub const VDEV_TYPE_REPLACING: &'static [u8; 10usize] = b"replacing\x00";
pub const VDEV_TYPE_RAIDZ: &'static [u8; 6usize] = b"raidz\x00";
pub const VDEV_TYPE_DISK: &'static [u8; 5usize] = b"disk\x00";
pub const VDEV_TYPE_FILE: &'static [u8; 5usize] = b"file\x00";
pub const VDEV_TYPE_MISSING: &'static [u8; 8usize] = b"missing\x00";
pub const VDEV_TYPE_HOLE: &'static [u8; 5usize] = b"hole\x00";
pub const VDEV_TYPE_SPARE: &'static [u8; 6usize] = b"spare\x00";
pub const VDEV_TYPE_LOG: &'static [u8; 4usize] = b"log\x00";
pub const VDEV_TYPE_L2CACHE: &'static [u8; 8usize] = b"l2cache\x00";
pub const SPA_MINDEVSIZE: ::libc::c_uint = 67108864;
pub const ZPOOL_CACHE: &'static [u8; 21usize] = b"/etc/zfs/zpool.cache\x00";
pub const VDEV_L_HISTO_BUCKETS: ::libc::c_uint = 37;
pub const VDEV_RQ_HISTO_BUCKETS: ::libc::c_uint = 25;
pub const ZVOL_DRIVER: &'static [u8; 5usize] = b"zvol\x00";
pub const ZFS_DRIVER: &'static [u8; 4usize] = b"zfs\x00";
pub const ZFS_DEV: &'static [u8; 9usize] = b"/dev/zfs\x00";
pub const ZFS_SHARETAB: &'static [u8; 18usize] = b"/etc/dfs/sharetab\x00";
pub const ZFS_SUPER_MAGIC: ::libc::c_uint = 801189825;
pub const ZVOL_DIR: &'static [u8; 5usize] = b"/dev\x00";
pub const ZVOL_MAJOR: ::libc::c_uint = 230;
pub const ZVOL_MINOR_BITS: ::libc::c_uint = 4;
pub const ZVOL_MINOR_MASK: ::libc::c_uint = 15;
pub const ZVOL_MINORS: ::libc::c_uint = 16;
pub const ZVOL_DEV_NAME: &'static [u8; 3usize] = b"zd\x00";
pub const ZVOL_PROP_NAME: &'static [u8; 5usize] = b"name\x00";
pub const ZVOL_DEFAULT_BLOCKSIZE: ::libc::c_uint = 8192;
pub const ZPOOL_ERR_LIST: &'static [u8; 11usize] = b"error list\x00";
pub const ZPOOL_ERR_DATASET: &'static [u8; 8usize] = b"dataset\x00";
pub const ZPOOL_ERR_OBJECT: &'static [u8; 7usize] = b"object\x00";
pub const HIS_MAX_RECORD_LEN: ::libc::c_uint = 8193;
pub const ZPOOL_HIST_RECORD: &'static [u8; 15usize] = b"history record\x00";
pub const ZPOOL_HIST_TIME: &'static [u8; 13usize] = b"history time\x00";
pub const ZPOOL_HIST_CMD: &'static [u8; 16usize] = b"history command\x00";
pub const ZPOOL_HIST_WHO: &'static [u8; 12usize] = b"history who\x00";
pub const ZPOOL_HIST_ZONE: &'static [u8; 13usize] = b"history zone\x00";
pub const ZPOOL_HIST_HOST: &'static [u8; 17usize] = b"history hostname\x00";
pub const ZPOOL_HIST_TXG: &'static [u8; 12usize] = b"history txg\x00";
pub const ZPOOL_HIST_INT_EVENT: &'static [u8; 23usize] =
    b"history internal event\x00";
pub const ZPOOL_HIST_INT_STR: &'static [u8; 21usize] =
    b"history internal str\x00";
pub const ZPOOL_HIST_INT_NAME: &'static [u8; 14usize] = b"internal_name\x00";
pub const ZPOOL_HIST_IOCTL: &'static [u8; 6usize] = b"ioctl\x00";
pub const ZPOOL_HIST_INPUT_NVL: &'static [u8; 7usize] = b"in_nvl\x00";
pub const ZPOOL_HIST_OUTPUT_NVL: &'static [u8; 8usize] = b"out_nvl\x00";
pub const ZPOOL_HIST_DSNAME: &'static [u8; 7usize] = b"dsname\x00";
pub const ZPOOL_HIST_DSID: &'static [u8; 5usize] = b"dsid\x00";
pub const ZFS_ONLINE_CHECKREMOVE: ::libc::c_uint = 1;
pub const ZFS_ONLINE_UNSPARE: ::libc::c_uint = 2;
pub const ZFS_ONLINE_FORCEFAULT: ::libc::c_uint = 4;
pub const ZFS_ONLINE_EXPAND: ::libc::c_uint = 8;
pub const ZFS_OFFLINE_TEMPORARY: ::libc::c_uint = 1;
pub const ZFS_IMPORT_NORMAL: ::libc::c_uint = 0;
pub const ZFS_IMPORT_VERBATIM: ::libc::c_uint = 1;
pub const ZFS_IMPORT_ANY_HOST: ::libc::c_uint = 2;
pub const ZFS_IMPORT_MISSING_LOG: ::libc::c_uint = 4;
pub const ZFS_IMPORT_ONLY: ::libc::c_uint = 8;
pub const ZFS_IMPORT_TEMP_NAME: ::libc::c_uint = 16;
pub const ZFS_IMPORT_SKIP_MMP: ::libc::c_uint = 32;
pub const ZFS_EV_POOL_NAME: &'static [u8; 10usize] = b"pool_name\x00";
pub const ZFS_EV_POOL_GUID: &'static [u8; 10usize] = b"pool_guid\x00";
pub const ZFS_EV_VDEV_PATH: &'static [u8; 10usize] = b"vdev_path\x00";
pub const ZFS_EV_VDEV_GUID: &'static [u8; 10usize] = b"vdev_guid\x00";
pub const ZFS_EV_HIST_TIME: &'static [u8; 13usize] = b"history_time\x00";
pub const ZFS_EV_HIST_CMD: &'static [u8; 16usize] = b"history_command\x00";
pub const ZFS_EV_HIST_WHO: &'static [u8; 12usize] = b"history_who\x00";
pub const ZFS_EV_HIST_ZONE: &'static [u8; 13usize] = b"history_zone\x00";
pub const ZFS_EV_HIST_HOST: &'static [u8; 17usize] = b"history_hostname\x00";
pub const ZFS_EV_HIST_TXG: &'static [u8; 12usize] = b"history_txg\x00";
pub const ZFS_EV_HIST_INT_EVENT: &'static [u8; 23usize] =
    b"history_internal_event\x00";
pub const ZFS_EV_HIST_INT_STR: &'static [u8; 21usize] =
    b"history_internal_str\x00";
pub const ZFS_EV_HIST_INT_NAME: &'static [u8; 22usize] =
    b"history_internal_name\x00";
pub const ZFS_EV_HIST_IOCTL: &'static [u8; 14usize] = b"history_ioctl\x00";
pub const ZFS_EV_HIST_DSNAME: &'static [u8; 15usize] = b"history_dsname\x00";
pub const ZFS_EV_HIST_DSID: &'static [u8; 13usize] = b"history_dsid\x00";
pub const AVL_BEFORE: ::libc::c_uint = 0;
pub const AVL_AFTER: ::libc::c_uint = 1;
pub const ZFS_MAXPROPLEN: ::libc::c_uint = 4096;
pub const ZPOOL_MAXPROPLEN: ::libc::c_uint = 4096;
pub const DISK_ROOT: &'static [u8; 5usize] = b"/dev\x00";
pub const UDISK_ROOT: &'static [u8; 10usize] = b"/dev/disk\x00";
pub const ZVOL_ROOT: &'static [u8; 10usize] = b"/dev/zvol\x00";
pub const DISK_LABEL_WAIT: ::libc::c_uint = 30000;
pub const IMPORT_ORDER_PREFERRED_1: ::libc::c_uint = 1;
pub const IMPORT_ORDER_PREFERRED_2: ::libc::c_uint = 2;
pub const IMPORT_ORDER_SCAN_OFFSET: ::libc::c_uint = 10;
pub const IMPORT_ORDER_DEFAULT: ::libc::c_uint = 100;
pub const DEFAULT_IMPORT_PATH_SIZE: ::libc::c_uint = 9;
pub const ZFS_MOUNTPOINT_NONE: &'static [u8; 5usize] = b"none\x00";
pub const ZFS_MOUNTPOINT_LEGACY: &'static [u8; 7usize] = b"legacy\x00";
pub const ZFS_FEATURE_DISABLED: &'static [u8; 9usize] = b"disabled\x00";
pub const ZFS_FEATURE_ENABLED: &'static [u8; 8usize] = b"enabled\x00";
pub const ZFS_FEATURE_ACTIVE: &'static [u8; 7usize] = b"active\x00";
pub const ZFS_UNSUPPORTED_INACTIVE: &'static [u8; 9usize] = b"inactive\x00";
pub const ZFS_UNSUPPORTED_READONLY: &'static [u8; 9usize] = b"readonly\x00";
pub const ZFS_GET_NCOLS: ::libc::c_uint = 5;
pub const STDOUT_VERBOSE: ::libc::c_uint = 1;
pub const STDERR_VERBOSE: ::libc::c_uint = 2;
pub const NO_DEFAULT_PATH: ::libc::c_uint = 4;
extern "C" {
    pub fn __assert_fail(__assertion: *const ::libc::c_char,
                         __file: *const ::libc::c_char,
                         __line: ::libc::c_uint,
                         __function: *const ::libc::c_char);
}
extern "C" {
    pub fn __assert_perror_fail(__errnum: ::libc::c_int,
                                __file: *const ::libc::c_char,
                                __line: ::libc::c_uint,
                                __function: *const ::libc::c_char);
}
extern "C" {
    pub fn __assert(__assertion: *const ::libc::c_char,
                    __file: *const ::libc::c_char, __line: ::libc::c_int);
}
pub type __u_char = ::libc::c_uchar;
pub type __u_short = ::libc::c_ushort;
pub type __u_int = ::libc::c_uint;
pub type __u_long = ::libc::c_ulong;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_long;
pub type __uint64_t = ::libc::c_ulong;
pub type __quad_t = ::libc::c_long;
pub type __u_quad_t = ::libc::c_ulong;
pub type __intmax_t = ::libc::c_long;
pub type __uintmax_t = ::libc::c_ulong;
pub type __dev_t = ::libc::c_ulong;
pub type __uid_t = ::libc::c_uint;
pub type __gid_t = ::libc::c_uint;
pub type __ino_t = ::libc::c_ulong;
pub type __ino64_t = ::libc::c_ulong;
pub type __mode_t = ::libc::c_uint;
pub type __nlink_t = ::libc::c_ulong;
pub type __off_t = ::libc::c_long;
pub type __off64_t = ::libc::c_long;
pub type __pid_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::core::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::core::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::libc::c_long;
pub type __rlim_t = ::libc::c_ulong;
pub type __rlim64_t = ::libc::c_ulong;
pub type __id_t = ::libc::c_uint;
pub type __time_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_uint;
pub type __suseconds_t = ::libc::c_long;
pub type __daddr_t = ::libc::c_int;
pub type __key_t = ::libc::c_int;
pub type __clockid_t = ::libc::c_int;
pub type __timer_t = *mut ::libc::c_void;
pub type __blksize_t = ::libc::c_long;
pub type __blkcnt_t = ::libc::c_long;
pub type __blkcnt64_t = ::libc::c_long;
pub type __fsblkcnt_t = ::libc::c_ulong;
pub type __fsblkcnt64_t = ::libc::c_ulong;
pub type __fsfilcnt_t = ::libc::c_ulong;
pub type __fsfilcnt64_t = ::libc::c_ulong;
pub type __fsword_t = ::libc::c_long;
pub type __ssize_t = ::libc::c_long;
pub type __syscall_slong_t = ::libc::c_long;
pub type __syscall_ulong_t = ::libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::libc::c_char;
pub type __intptr_t = ::libc::c_long;
pub type __socklen_t = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: ::libc::c_int,
    pub _IO_read_ptr: *mut ::libc::c_char,
    pub _IO_read_end: *mut ::libc::c_char,
    pub _IO_read_base: *mut ::libc::c_char,
    pub _IO_write_base: *mut ::libc::c_char,
    pub _IO_write_ptr: *mut ::libc::c_char,
    pub _IO_write_end: *mut ::libc::c_char,
    pub _IO_buf_base: *mut ::libc::c_char,
    pub _IO_buf_end: *mut ::libc::c_char,
    pub _IO_save_base: *mut ::libc::c_char,
    pub _IO_backup_base: *mut ::libc::c_char,
    pub _IO_save_end: *mut ::libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::libc::c_int,
    pub _flags2: ::libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::libc::c_ushort,
    pub _vtable_offset: ::libc::c_schar,
    pub _shortbuf: [::libc::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::libc::c_void,
    pub __pad2: *mut ::libc::c_void,
    pub __pad3: *mut ::libc::c_void,
    pub __pad4: *mut ::libc::c_void,
    pub __pad5: usize,
    pub _mode: ::libc::c_int,
    pub _unused2: [::libc::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::core::mem::size_of::<_IO_FILE>() , 216usize , concat ! (
               "Size of: " , stringify ! ( _IO_FILE ) ));
    assert_eq! (::core::mem::align_of::<_IO_FILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_FILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_backup_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _markers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _chain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _fileno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _old_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _cur_column ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const
                _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _vtable_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as
                usize } , 131usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _shortbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as
                usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _unused2 ) ));
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy)]
pub struct __mbstate_t {
    pub __count: ::libc::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::libc::c_uint,
    pub __wchb: [::libc::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::core::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::core::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::core::mem::size_of::<_G_fpos_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (::core::mem::align_of::<_G_fpos_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::core::mem::size_of::<_G_fpos64_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (::core::mem::align_of::<_G_fpos64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos64_t {
    fn clone(&self) -> Self { *self }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::libc::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::core::mem::size_of::<_IO_marker>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _IO_marker ) ));
    assert_eq! (::core::mem::align_of::<_IO_marker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _pos ) ));
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
    ::core::option::Option<unsafe extern "C" fn(__cookie: *mut ::libc::c_void,
                                                __buf: *mut ::libc::c_char,
                                                __nbytes: usize)
                               -> __ssize_t>;
pub type __io_write_fn =
    ::core::option::Option<unsafe extern "C" fn(__cookie: *mut ::libc::c_void,
                                                __buf: *const ::libc::c_char,
                                                __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
    ::core::option::Option<unsafe extern "C" fn(__cookie: *mut ::libc::c_void,
                                                __pos: *mut __off64_t,
                                                __w: ::libc::c_int)
                               -> ::libc::c_int>;
pub type __io_close_fn =
    ::core::option::Option<unsafe extern "C" fn(__cookie: *mut ::libc::c_void)
                               -> ::libc::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::libc::c_int, __fp: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE, arg2: *const ::libc::c_char,
                       arg3: *mut __va_list_tag, arg4: *mut ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE, arg2: *const ::libc::c_char,
                        arg3: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::libc::c_int, arg3: __ssize_t)
     -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::libc::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::libc::c_int, arg4: ::libc::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::libc::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::libc::c_char, __new: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: ::libc::c_int, __old: *const ::libc::c_char,
                    __newfd: ::libc::c_int, __new: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::libc::c_char, __pfx: *const ::libc::c_char)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::libc::c_char,
                 __modes: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::libc::c_char,
                   __modes: *const ::libc::c_char, __stream: *mut FILE)
     -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::libc::c_int, __modes: *const ::libc::c_char)
     -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::libc::c_void, __len: usize,
                    __modes: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::libc::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::libc::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::libc::c_char,
                   __modes: ::libc::c_int, __n: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::libc::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const ::libc::c_char, ...)
     -> ::libc::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::libc::c_char,
                   __format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::libc::c_char,
                    __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::libc::c_char, __arg: *mut __va_list_tag)
     -> ::libc::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::libc::c_char, __format: *const ::libc::c_char,
                    __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::libc::c_char, __maxlen: usize,
                    __format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::libc::c_char, __maxlen: usize,
                     __format: *const ::libc::c_char,
                     __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::libc::c_int, __fmt: *const ::libc::c_char,
                    __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::libc::c_int, __fmt: *const ::libc::c_char, ...)
     -> ::libc::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const ::libc::c_char, ...)
     -> ::libc::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::libc::c_char,
                  __format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const ::libc::c_char, ...)
     -> ::libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_scanf"]
    pub fn scanf1(__format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_sscanf"]
    pub fn sscanf1(__s: *const ::libc::c_char,
                   __format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::libc::c_char,
                   __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::libc::c_char, __arg: *mut __va_list_tag)
     -> ::libc::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::libc::c_char,
                   __format: *const ::libc::c_char, __arg: *mut __va_list_tag)
     -> ::libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfscanf"]
    pub fn vfscanf1(__s: *mut FILE, __format: *const ::libc::c_char,
                    __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::libc::c_char, __arg: *mut __va_list_tag)
     -> ::libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vsscanf"]
    pub fn vsscanf1(__s: *const ::libc::c_char,
                    __format: *const ::libc::c_char,
                    __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn getchar() -> ::libc::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::libc::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fputc(__c: ::libc::c_int, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn putc(__c: ::libc::c_int, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn putchar(__c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::libc::c_int, __stream: *mut FILE)
     -> ::libc::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::libc::c_int, __stream: *mut FILE)
     -> ::libc::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn putw(__w: ::libc::c_int, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::libc::c_char, __n: ::libc::c_int,
                 __stream: *mut FILE) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::libc::c_char, __n: *mut usize,
                      __delimiter: ::libc::c_int, __stream: *mut FILE)
     -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::libc::c_char, __n: *mut usize,
                    __delimiter: ::libc::c_int, __stream: *mut FILE)
     -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::libc::c_char, __n: *mut usize,
                   __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::libc::c_char, __stream: *mut FILE)
     -> ::libc::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::libc::c_int, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::libc::c_void, __size: usize, __n: usize,
                 __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::libc::c_void, __size: usize, __n: usize,
                  __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::libc::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::libc::c_void, __size: usize,
                           __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::libc::c_long,
                 __whence: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::libc::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::libc::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::libc::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: ::libc::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::libc::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::libc::c_char,
                 __modes: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type wchar_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::libc::c_int,
    pub rem: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::core::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::core::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::libc::c_long,
    pub rem: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::core::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::core::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::libc::c_longlong,
    pub rem: ::libc::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::core::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::core::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::libc::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::libc::c_char) -> ::libc::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::libc::c_char) -> ::libc::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::libc::c_char,
                  __endptr: *mut *mut ::libc::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::libc::c_char,
                  __endptr: *mut *mut ::libc::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::libc::c_char,
                   __endptr: *mut *mut ::libc::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::libc::c_char,
                  __endptr: *mut *mut ::libc::c_char, __base: ::libc::c_int)
     -> ::libc::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::libc::c_char,
                   __endptr: *mut *mut ::libc::c_char, __base: ::libc::c_int)
     -> ::libc::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::libc::c_char,
                  __endptr: *mut *mut ::libc::c_char, __base: ::libc::c_int)
     -> ::libc::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::libc::c_char,
                   __endptr: *mut *mut ::libc::c_char, __base: ::libc::c_int)
     -> ::libc::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::libc::c_char,
                   __endptr: *mut *mut ::libc::c_char, __base: ::libc::c_int)
     -> ::libc::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::libc::c_char,
                    __endptr: *mut *mut ::libc::c_char, __base: ::libc::c_int)
     -> ::libc::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::libc::c_long) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::libc::c_char) -> ::libc::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type uint = ::libc::c_uint;
pub type u_int8_t = ::libc::c_uchar;
pub type u_int16_t = ::libc::c_ushort;
pub type u_int32_t = ::libc::c_uint;
pub type u_int64_t = ::libc::c_ulong;
pub type register_t = ::libc::c_long;
pub type __sig_atomic_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::libc::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::core::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::core::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::core::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::core::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::core::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::core::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::libc::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::core::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::core::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::libc::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::libc::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::libc::c_uint, __minor: ::libc::c_uint)
     -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::libc::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub union pthread_attr_t {
    pub __size: [::libc::c_char; 56usize],
    pub __align: ::libc::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::core::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::core::mem::align_of::<pthread_attr_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::core::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::core::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::libc::c_char; 40usize],
    pub __align: ::libc::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::libc::c_int,
    pub __count: ::libc::c_uint,
    pub __owner: ::libc::c_int,
    pub __nusers: ::libc::c_uint,
    pub __kind: ::libc::c_int,
    pub __spins: ::libc::c_short,
    pub __elision: ::libc::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::core::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::core::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::core::mem::size_of::<pthread_mutex_t>() , 40usize , concat !
               ( "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::core::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutexattr_t {
    pub __size: [::libc::c_char; 4usize],
    pub __align: ::libc::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::core::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::core::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::libc::c_char; 48usize],
    pub __align: ::libc::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __bindgen_anon_1: pthread_cond_t__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: pthread_cond_t__bindgen_ty_1__bindgen_ty_2,
    pub __g_refs: [::libc::c_uint; 2usize],
    pub __g_size: [::libc::c_uint; 2usize],
    pub __g1_orig_size: ::libc::c_uint,
    pub __wrefs: ::libc::c_uint,
    pub __g_signals: [::libc::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_cond_t__bindgen_ty_1__bindgen_ty_1 {
    pub __wseq: ::libc::c_ulonglong,
    pub __wseq32: pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::libc::c_uint,
    pub __high: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ) .
                __low as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( __low ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ) .
                __high as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( __high ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_1 )
                ) . __wseq as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( __wseq ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_1 )
                ) . __wseq32 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( __wseq32 ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_cond_t__bindgen_ty_1__bindgen_ty_2 {
    pub __g1_start: ::libc::c_ulonglong,
    pub __g1_start32: pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::libc::c_uint,
    pub __high: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ) .
                __low as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ,
                "::" , stringify ! ( __low ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ) .
                __high as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ,
                "::" , stringify ! ( __high ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_2 )
                ) . __g1_start as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( __g1_start ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_2 )
                ) . __g1_start32 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( __g1_start32 ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pthread_cond_t__bindgen_ty_1>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g_refs as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __g_refs
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g_size as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __g_size
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g1_orig_size as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __g1_orig_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wrefs as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __wrefs
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g_signals as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __g_signals ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::core::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::core::mem::align_of::<pthread_cond_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_condattr_t {
    pub __size: [::libc::c_char; 4usize],
    pub __align: ::libc::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::core::mem::size_of::<pthread_condattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::core::mem::align_of::<pthread_condattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::libc::c_uint;
pub type pthread_once_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::libc::c_char; 56usize],
    pub __align: ::libc::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __readers: ::libc::c_uint,
    pub __writers: ::libc::c_uint,
    pub __wrphase_futex: ::libc::c_uint,
    pub __writers_futex: ::libc::c_uint,
    pub __pad3: ::libc::c_uint,
    pub __pad4: ::libc::c_uint,
    pub __cur_writer: ::libc::c_int,
    pub __shared: ::libc::c_int,
    pub __rwelision: ::libc::c_schar,
    pub __pad1: [::libc::c_uchar; 7usize],
    pub __pad2: ::libc::c_ulong,
    pub __flags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __wrphase_futex as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wrphase_futex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writers_futex as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writers_futex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad3 as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad4 as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __cur_writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __cur_writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::core::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::core::mem::align_of::<pthread_rwlock_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlockattr_t {
    pub __size: [::libc::c_char; 8usize],
    pub __align: ::libc::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::core::mem::size_of::<pthread_rwlockattr_t>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t )
               ));
    assert_eq! (::core::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrier_t {
    pub __size: [::libc::c_char; 32usize],
    pub __align: ::libc::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::core::mem::size_of::<pthread_barrier_t>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::core::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrierattr_t {
    pub __size: [::libc::c_char; 4usize],
    pub __align: ::libc::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::core::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::core::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
pub type int_least8_t = ::libc::c_schar;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_long;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulong;
pub type int_fast8_t = ::libc::c_schar;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct imaxdiv_t {
    pub quot: ::libc::c_long,
    pub rem: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(::core::mem::size_of::<imaxdiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (::core::mem::align_of::<imaxdiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . quot as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . rem as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for imaxdiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(__nptr: *const ::libc::c_char,
                     __endptr: *mut *mut ::libc::c_char,
                     __base: ::libc::c_int) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(__nptr: *const ::libc::c_char,
                     __endptr: *mut *mut ::libc::c_char,
                     __base: ::libc::c_int) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t, __base: ::libc::c_int)
     -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t, __base: ::libc::c_int)
     -> uintmax_t;
}
pub type caddr32_t = u32;
pub type daddr32_t = i32;
pub type off32_t = i32;
pub type ino32_t = u32;
pub type blkcnt32_t = i32;
pub type fsblkcnt32_t = u32;
pub type fsfilcnt32_t = u32;
pub type id32_t = i32;
pub type major32_t = u32;
pub type minor32_t = u32;
pub type key32_t = i32;
pub type mode32_t = u32;
pub type uid32_t = u32;
pub type gid32_t = u32;
pub type nlink32_t = u32;
pub type dev32_t = u32;
pub type pid32_t = i32;
pub type size32_t = u32;
pub type ssize32_t = i32;
pub type time32_t = i32;
pub type clock32_t = i32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval32 {
    pub tv_sec: time32_t,
    pub tv_usec: i32,
}
#[test]
fn bindgen_test_layout_timeval32() {
    assert_eq!(::core::mem::size_of::<timeval32>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timeval32 ) ));
    assert_eq! (::core::mem::align_of::<timeval32>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timeval32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval32 ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval32 ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval32 ) ) . tv_usec as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval32 ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec32 {
    pub tv_sec: time32_t,
    pub tv_nsec: i32,
}
#[test]
fn bindgen_test_layout_timespec32() {
    assert_eq!(::core::mem::size_of::<timespec32>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timespec32 ) ));
    assert_eq! (::core::mem::align_of::<timespec32>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timespec32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec32 ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec32 ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec32 ) ) . tv_nsec as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec32 ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec32 {
    fn clone(&self) -> Self { *self }
}
pub type timespec32_t = timespec32;
pub type timestruc32_t = timespec32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerspec32 {
    pub it_interval: timespec32,
    pub it_value: timespec32,
}
#[test]
fn bindgen_test_layout_itimerspec32() {
    assert_eq!(::core::mem::size_of::<itimerspec32>() , 16usize , concat ! (
               "Size of: " , stringify ! ( itimerspec32 ) ));
    assert_eq! (::core::mem::align_of::<itimerspec32>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec32 ) ) . it_interval as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec32 ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec32 ) ) . it_value as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec32 ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec32 {
    fn clone(&self) -> Self { *self }
}
pub type itimerspec32_t = itimerspec32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum boolean { B_FALSE = 0, B_TRUE = 1, }
pub use self::boolean as boolean_t;
pub type uchar_t = ::libc::c_uchar;
pub type ushort_t = ::libc::c_ushort;
pub type uint_t = ::libc::c_uint;
pub type ulong_t = ::libc::c_ulong;
pub type longlong_t = ::libc::c_longlong;
pub type u_longlong_t = ::libc::c_ulonglong;
pub type offset_t = longlong_t;
pub type u_offset_t = u_longlong_t;
pub type len_t = u_longlong_t;
pub type diskaddr_t = longlong_t;
pub type pgcnt_t = ulong_t;
pub type spgcnt_t = ::libc::c_long;
pub type pri_t = ::libc::c_short;
pub type zoneid_t = ::libc::c_int;
pub type projid_t = ::libc::c_int;
pub type major_t = ::libc::c_int;
pub type minor_t = ::libc::c_int;
pub type o_mode_t = ushort_t;
pub type index_t = ::libc::c_short;
extern "C" {
    pub fn __sigismember(arg1: *const __sigset_t, arg2: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn __sigaddset(arg1: *mut __sigset_t, arg2: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn __sigdelset(arg1: *mut __sigset_t, arg2: ::libc::c_int)
     -> ::libc::c_int;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy)]
pub union sigval {
    pub sival_int: ::libc::c_int,
    pub sival_ptr: *mut ::libc::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(::core::mem::size_of::<sigval>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sigval ) ));
    assert_eq! (::core::mem::align_of::<sigval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_ptr ) ));
}
impl Clone for sigval {
    fn clone(&self) -> Self { *self }
}
pub type sigval_t = sigval;
pub type __sigchld_clock_t = __clock_t;
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t {
    pub si_signo: ::libc::c_int,
    pub si_errno: ::libc::c_int,
    pub si_code: ::libc::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::libc::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
    _bindgen_union_align: [u64; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_1 ) )
                . si_pid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_1 ) )
                . si_uid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                si_uid ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::libc::c_int,
    pub si_overrun: ::libc::c_int,
    pub si_sigval: sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) )
                . si_tid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                si_tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) )
                . si_overrun as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                si_overrun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) )
                . si_sigval as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                si_sigval ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) )
                . si_pid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) )
                . si_uid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) )
                . si_sigval as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                si_sigval ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::libc::c_int,
    pub si_utime: __sigchld_clock_t,
    pub si_stime: __sigchld_clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_pid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_uid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_status as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_utime as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_stime as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_stime ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::libc::c_void,
    pub si_addr_lsb: ::libc::c_short,
    pub si_addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _lower: *mut ::libc::c_void,
    pub _upper: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ) .
                _lower as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) , "::" ,
                stringify ! ( _lower ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ) .
                _upper as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) , "::" ,
                stringify ! ( _upper ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) )
                . si_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                si_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) )
                . si_addr_lsb as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                si_addr_lsb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) )
                . si_addr_bnd as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                si_addr_bnd ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::libc::c_long,
    pub si_fd: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ));
    assert_eq! (::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_6 ) )
                . si_band as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                si_band ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_6 ) )
                . si_fd as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                si_fd ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::libc::c_void,
    pub _syscall: ::libc::c_int,
    pub _arch: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ));
    assert_eq! (::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) )
                . _call_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                _call_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) )
                . _syscall as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                _syscall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) )
                . _arch as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                _arch ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<siginfo_t__bindgen_ty_1>() , 112usize ,
               concat ! (
               "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<siginfo_t__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _pad as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _kill as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _kill ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _timer as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _rt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _rt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigchld as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigchld ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigfault
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigfault ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigpoll as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigpoll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigsys as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigsys ) ));
}
impl Clone for siginfo_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(::core::mem::size_of::<siginfo_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( siginfo_t ) ));
    assert_eq! (::core::mem::align_of::<siginfo_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( siginfo_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . si_signo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( si_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . si_errno as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( si_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . si_code as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( si_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . _sifields as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( _sifields ) ));
}
impl Clone for siginfo_t {
    fn clone(&self) -> Self { *self }
}
pub const SI_ASYNCNL: _bindgen_ty_1 = _bindgen_ty_1::SI_ASYNCNL;
pub const SI_TKILL: _bindgen_ty_1 = _bindgen_ty_1::SI_TKILL;
pub const SI_SIGIO: _bindgen_ty_1 = _bindgen_ty_1::SI_SIGIO;
pub const SI_ASYNCIO: _bindgen_ty_1 = _bindgen_ty_1::SI_ASYNCIO;
pub const SI_MESGQ: _bindgen_ty_1 = _bindgen_ty_1::SI_MESGQ;
pub const SI_TIMER: _bindgen_ty_1 = _bindgen_ty_1::SI_TIMER;
pub const SI_QUEUE: _bindgen_ty_1 = _bindgen_ty_1::SI_QUEUE;
pub const SI_USER: _bindgen_ty_1 = _bindgen_ty_1::SI_USER;
pub const SI_KERNEL: _bindgen_ty_1 = _bindgen_ty_1::SI_KERNEL;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    SI_ASYNCNL = -60,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128,
}
pub const ILL_ILLOPC: _bindgen_ty_2 = _bindgen_ty_2::ILL_ILLOPC;
pub const ILL_ILLOPN: _bindgen_ty_2 = _bindgen_ty_2::ILL_ILLOPN;
pub const ILL_ILLADR: _bindgen_ty_2 = _bindgen_ty_2::ILL_ILLADR;
pub const ILL_ILLTRP: _bindgen_ty_2 = _bindgen_ty_2::ILL_ILLTRP;
pub const ILL_PRVOPC: _bindgen_ty_2 = _bindgen_ty_2::ILL_PRVOPC;
pub const ILL_PRVREG: _bindgen_ty_2 = _bindgen_ty_2::ILL_PRVREG;
pub const ILL_COPROC: _bindgen_ty_2 = _bindgen_ty_2::ILL_COPROC;
pub const ILL_BADSTK: _bindgen_ty_2 = _bindgen_ty_2::ILL_BADSTK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
}
pub const FPE_INTDIV: _bindgen_ty_3 = _bindgen_ty_3::FPE_INTDIV;
pub const FPE_INTOVF: _bindgen_ty_3 = _bindgen_ty_3::FPE_INTOVF;
pub const FPE_FLTDIV: _bindgen_ty_3 = _bindgen_ty_3::FPE_FLTDIV;
pub const FPE_FLTOVF: _bindgen_ty_3 = _bindgen_ty_3::FPE_FLTOVF;
pub const FPE_FLTUND: _bindgen_ty_3 = _bindgen_ty_3::FPE_FLTUND;
pub const FPE_FLTRES: _bindgen_ty_3 = _bindgen_ty_3::FPE_FLTRES;
pub const FPE_FLTINV: _bindgen_ty_3 = _bindgen_ty_3::FPE_FLTINV;
pub const FPE_FLTSUB: _bindgen_ty_3 = _bindgen_ty_3::FPE_FLTSUB;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
}
pub const SEGV_MAPERR: _bindgen_ty_4 = _bindgen_ty_4::SEGV_MAPERR;
pub const SEGV_ACCERR: _bindgen_ty_4 = _bindgen_ty_4::SEGV_ACCERR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 { SEGV_MAPERR = 1, SEGV_ACCERR = 2, }
pub const BUS_ADRALN: _bindgen_ty_5 = _bindgen_ty_5::BUS_ADRALN;
pub const BUS_ADRERR: _bindgen_ty_5 = _bindgen_ty_5::BUS_ADRERR;
pub const BUS_OBJERR: _bindgen_ty_5 = _bindgen_ty_5::BUS_OBJERR;
pub const BUS_MCEERR_AR: _bindgen_ty_5 = _bindgen_ty_5::BUS_MCEERR_AR;
pub const BUS_MCEERR_AO: _bindgen_ty_5 = _bindgen_ty_5::BUS_MCEERR_AO;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5,
}
pub const CLD_EXITED: _bindgen_ty_6 = _bindgen_ty_6::CLD_EXITED;
pub const CLD_KILLED: _bindgen_ty_6 = _bindgen_ty_6::CLD_KILLED;
pub const CLD_DUMPED: _bindgen_ty_6 = _bindgen_ty_6::CLD_DUMPED;
pub const CLD_TRAPPED: _bindgen_ty_6 = _bindgen_ty_6::CLD_TRAPPED;
pub const CLD_STOPPED: _bindgen_ty_6 = _bindgen_ty_6::CLD_STOPPED;
pub const CLD_CONTINUED: _bindgen_ty_6 = _bindgen_ty_6::CLD_CONTINUED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6,
}
pub const POLL_IN: _bindgen_ty_7 = _bindgen_ty_7::POLL_IN;
pub const POLL_OUT: _bindgen_ty_7 = _bindgen_ty_7::POLL_OUT;
pub const POLL_MSG: _bindgen_ty_7 = _bindgen_ty_7::POLL_MSG;
pub const POLL_ERR: _bindgen_ty_7 = _bindgen_ty_7::POLL_ERR;
pub const POLL_PRI: _bindgen_ty_7 = _bindgen_ty_7::POLL_PRI;
pub const POLL_HUP: _bindgen_ty_7 = _bindgen_ty_7::POLL_HUP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6,
}
#[repr(C)]
#[derive(Copy)]
pub struct sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ::libc::c_int,
    pub sigev_notify: ::libc::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::libc::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                   sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               sigevent__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1__bindgen_ty_1 ) )
                . _function as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1__bindgen_ty_1 ) )
                . _attribute as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _attribute ) ));
}
impl Clone for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sigevent__bindgen_ty_1>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( sigevent__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<sigevent__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigevent__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . _pad as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . _tid as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) .
                _sigev_thread as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _sigev_thread ) ));
}
impl Clone for sigevent__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(::core::mem::size_of::<sigevent>() , 64usize , concat ! (
               "Size of: " , stringify ! ( sigevent ) ));
    assert_eq! (::core::mem::align_of::<sigevent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_value as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_signo as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . _sigev_un as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( _sigev_un ) ));
}
impl Clone for sigevent {
    fn clone(&self) -> Self { *self }
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_8 = _bindgen_ty_8::SIGEV_SIGNAL;
pub const SIGEV_NONE: _bindgen_ty_8 = _bindgen_ty_8::SIGEV_NONE;
pub const SIGEV_THREAD: _bindgen_ty_8 = _bindgen_ty_8::SIGEV_THREAD;
pub const SIGEV_THREAD_ID: _bindgen_ty_8 = _bindgen_ty_8::SIGEV_THREAD_ID;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4,
}
pub type __sighandler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::libc::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::libc::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn raise(__sig: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::libc::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::libc::c_int, __s: *const ::libc::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::libc::c_char);
}
extern "C" {
    pub fn sigblock(__mask: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::libc::c_int;
}
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn sigismember(__set: *const sigset_t, __signo: ::libc::c_int)
     -> ::libc::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::libc::c_int,
    pub sa_restorer: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                      ::libc::c_int,
                                                                  arg2:
                                                                      *mut siginfo_t,
                                                                  arg3:
                                                                      *mut ::libc::c_void)>,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sigaction__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( sigaction__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sigaction__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigaction__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction__bindgen_ty_1 ) ) . sa_handler
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction__bindgen_ty_1
                ) , "::" , stringify ! ( sa_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction__bindgen_ty_1 ) ) .
                sa_sigaction as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction__bindgen_ty_1
                ) , "::" , stringify ! ( sa_sigaction ) ));
}
impl Clone for sigaction__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(::core::mem::size_of::<sigaction>() , 152usize , concat ! (
               "Size of: " , stringify ! ( sigaction ) ));
    assert_eq! (::core::mem::align_of::<sigaction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . __sigaction_handler as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( __sigaction_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_flags as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_restorer as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_restorer ) ));
}
impl Clone for sigaction {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sigprocmask(__how: ::libc::c_int, __set: *const sigset_t,
                       __oset: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaction(__sig: ::libc::c_int, __act: *const sigaction,
                     __oact: *mut sigaction) -> ::libc::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigwait(__set: *const sigset_t, __sig: *mut ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn sigtimedwait(__set: *const sigset_t, __info: *mut siginfo_t,
                        __timeout: *const timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn sigqueue(__pid: __pid_t, __sig: ::libc::c_int, __val: sigval)
     -> ::libc::c_int;
}
extern "C" {
    #[link_name = "_sys_siglist"]
    pub static mut _sys_siglist: [*const ::libc::c_char; 65usize];
}
extern "C" {
    #[link_name = "sys_siglist"]
    pub static mut sys_siglist: [*const ::libc::c_char; 65usize];
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub padding: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(::core::mem::size_of::<_fpx_sw_bytes>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _fpx_sw_bytes ) ));
    assert_eq! (::core::mem::align_of::<_fpx_sw_bytes>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _fpx_sw_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . magic1 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( magic1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . extended_size as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( extended_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . xstate_bv as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( xstate_bv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . xstate_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( xstate_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . padding as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( padding ) ));
}
impl Clone for _fpx_sw_bytes {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpreg {
    pub significand: [::libc::c_ushort; 4usize],
    pub exponent: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(::core::mem::size_of::<_fpreg>() , 10usize , concat ! (
               "Size of: " , stringify ! ( _fpreg ) ));
    assert_eq! (::core::mem::align_of::<_fpreg>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _fpreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpreg ) ) . significand as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpreg ) , "::" ,
                stringify ! ( significand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpreg ) ) . exponent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpreg ) , "::" ,
                stringify ! ( exponent ) ));
}
impl Clone for _fpreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpxreg {
    pub significand: [::libc::c_ushort; 4usize],
    pub exponent: ::libc::c_ushort,
    pub padding: [::libc::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(::core::mem::size_of::<_fpxreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _fpxreg ) ));
    assert_eq! (::core::mem::align_of::<_fpxreg>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _fpxreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpxreg ) ) . significand as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpxreg ) , "::" ,
                stringify ! ( significand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpxreg ) ) . exponent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpxreg ) , "::" ,
                stringify ! ( exponent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpxreg ) ) . padding as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpxreg ) , "::" ,
                stringify ! ( padding ) ));
}
impl Clone for _fpxreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(::core::mem::size_of::<_xmmreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _xmmreg ) ));
    assert_eq! (::core::mem::align_of::<_xmmreg>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _xmmreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xmmreg ) ) . element as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _xmmreg ) , "::" ,
                stringify ! ( element ) ));
}
impl Clone for _xmmreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    assert_eq!(::core::mem::size_of::<_fpstate>() , 512usize , concat ! (
               "Size of: " , stringify ! ( _fpstate ) ));
    assert_eq! (::core::mem::align_of::<_fpstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . cwd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( cwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . swd as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( swd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . ftw as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( ftw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . fop as * const _ as usize
                } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( fop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . rip as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . rdp as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( rdp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . mxcsr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . mxcr_mask as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( mxcr_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . _st as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( _st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . _xmm as * const _ as usize
                } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( _xmm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . padding as * const _ as
                usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( padding ) ));
}
impl Clone for _fpstate {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::libc::c_ushort,
    pub gs: ::libc::c_ushort,
    pub fs: ::libc::c_ushort,
    pub __pad0: ::libc::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sigcontext__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( sigcontext__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sigcontext__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigcontext__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext__bindgen_ty_1 ) ) . fpstate as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigcontext__bindgen_ty_1 ) , "::" , stringify ! ( fpstate )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext__bindgen_ty_1 ) ) .
                __fpstate_word as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigcontext__bindgen_ty_1 ) , "::" , stringify ! (
                __fpstate_word ) ));
}
impl Clone for sigcontext__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(::core::mem::size_of::<sigcontext>() , 256usize , concat ! (
               "Size of: " , stringify ! ( sigcontext ) ));
    assert_eq! (::core::mem::align_of::<sigcontext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r8 as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r9 as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r10 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r11 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r12 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r13 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r14 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r15 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rdi as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rsi as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rbp as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rbx as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rdx as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rax as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rcx as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rsp as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rip as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . eflags as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( eflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . cs as * const _ as usize
                } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . gs as * const _ as usize
                } , 146usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . fs as * const _ as usize
                } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . __pad0 as * const _ as
                usize } , 150usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( __pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . err as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . trapno as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . oldmask as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( oldmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . cr2 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( cr2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . __reserved1 as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( __reserved1 ) ));
}
impl Clone for sigcontext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub reserved1: [__uint64_t; 2usize],
    pub reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    assert_eq!(::core::mem::size_of::<_xsave_hdr>() , 64usize , concat ! (
               "Size of: " , stringify ! ( _xsave_hdr ) ));
    assert_eq! (::core::mem::align_of::<_xsave_hdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _xsave_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xsave_hdr ) ) . xstate_bv as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" ,
                stringify ! ( xstate_bv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xsave_hdr ) ) . reserved1 as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" ,
                stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xsave_hdr ) ) . reserved2 as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" ,
                stringify ! ( reserved2 ) ));
}
impl Clone for _xsave_hdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(::core::mem::size_of::<_ymmh_state>() , 256usize , concat ! (
               "Size of: " , stringify ! ( _ymmh_state ) ));
    assert_eq! (::core::mem::align_of::<_ymmh_state>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _ymmh_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ymmh_state ) ) . ymmh_space as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _ymmh_state ) , "::" ,
                stringify ! ( ymmh_space ) ));
}
impl Clone for _ymmh_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(::core::mem::size_of::<_xstate>() , 832usize , concat ! (
               "Size of: " , stringify ! ( _xstate ) ));
    assert_eq! (::core::mem::align_of::<_xstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _xstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . fpstate as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . xstate_hdr as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( xstate_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . ymmh as * const _ as usize
                } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( ymmh ) ));
}
impl Clone for _xstate {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::libc::c_int;
}
extern "C" {
    pub fn siginterrupt(__sig: ::libc::c_int, __interrupt: ::libc::c_int)
     -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigstack {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_onstack: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(::core::mem::size_of::<sigstack>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigstack ) ));
    assert_eq! (::core::mem::align_of::<sigstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_onstack as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_onstack ) ));
}
impl Clone for sigstack {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigaltstack {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_flags: ::libc::c_int,
    pub ss_size: usize,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(::core::mem::size_of::<sigaltstack>() , 24usize , concat ! (
               "Size of: " , stringify ! ( sigaltstack ) ));
    assert_eq! (::core::mem::align_of::<sigaltstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaltstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_size ) ));
}
impl Clone for sigaltstack {
    fn clone(&self) -> Self { *self }
}
pub type stack_t = sigaltstack;
pub const SS_ONSTACK: _bindgen_ty_9 = _bindgen_ty_9::SS_ONSTACK;
pub const SS_DISABLE: _bindgen_ty_9 = _bindgen_ty_9::SS_DISABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 { SS_ONSTACK = 1, SS_DISABLE = 2, }
pub type greg_t = ::libc::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _libc_fpxreg {
    pub significand: [::libc::c_ushort; 4usize],
    pub exponent: ::libc::c_ushort,
    pub padding: [::libc::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    assert_eq!(::core::mem::size_of::<_libc_fpxreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _libc_fpxreg ) ));
    assert_eq! (::core::mem::align_of::<_libc_fpxreg>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _libc_fpxreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpxreg ) ) . significand as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" ,
                stringify ! ( significand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpxreg ) ) . exponent as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" ,
                stringify ! ( exponent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpxreg ) ) . padding as * const _
                as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" ,
                stringify ! ( padding ) ));
}
impl Clone for _libc_fpxreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    assert_eq!(::core::mem::size_of::<_libc_xmmreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _libc_xmmreg ) ));
    assert_eq! (::core::mem::align_of::<_libc_xmmreg>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _libc_xmmreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_xmmreg ) ) . element as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_xmmreg ) , "::" ,
                stringify ! ( element ) ));
}
impl Clone for _libc_xmmreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    assert_eq!(::core::mem::size_of::<_libc_fpstate>() , 512usize , concat ! (
               "Size of: " , stringify ! ( _libc_fpstate ) ));
    assert_eq! (::core::mem::align_of::<_libc_fpstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _libc_fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . cwd as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( cwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . swd as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( swd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . ftw as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( ftw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . fop as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( fop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . rip as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . rdp as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( rdp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . mxcsr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . mxcr_mask as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( mxcr_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . _st as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( _st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . _xmm as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( _xmm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . padding as * const _
                as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( padding ) ));
}
impl Clone for _libc_fpstate {
    fn clone(&self) -> Self { *self }
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::libc::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(::core::mem::size_of::<mcontext_t>() , 256usize , concat ! (
               "Size of: " , stringify ! ( mcontext_t ) ));
    assert_eq! (::core::mem::align_of::<mcontext_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mcontext_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcontext_t ) ) . gregs as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mcontext_t ) , "::" ,
                stringify ! ( gregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcontext_t ) ) . fpregs as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( mcontext_t ) , "::" ,
                stringify ! ( fpregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcontext_t ) ) . __reserved1 as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( mcontext_t ) , "::" ,
                stringify ! ( __reserved1 ) ));
}
impl Clone for mcontext_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ucontext {
    pub uc_flags: ::libc::c_ulong,
    pub uc_link: *mut ucontext,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: __sigset_t,
    pub __fpregs_mem: _libc_fpstate,
}
#[test]
fn bindgen_test_layout_ucontext() {
    assert_eq!(::core::mem::size_of::<ucontext>() , 936usize , concat ! (
               "Size of: " , stringify ! ( ucontext ) ));
    assert_eq! (::core::mem::align_of::<ucontext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ucontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_link as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_stack as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_mcontext as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_mcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_sigmask as * const _ as
                usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_sigmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . __fpregs_mem as * const _
                as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( __fpregs_mem ) ));
}
impl Clone for ucontext {
    fn clone(&self) -> Self { *self }
}
pub type ucontext_t = ucontext;
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack)
     -> ::libc::c_int;
}
extern "C" {
    pub fn sigaltstack(__ss: *const sigaltstack, __oss: *mut sigaltstack)
     -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_sigmask(__how: ::libc::c_int, __newmask: *const __sigset_t,
                           __oldmask: *mut __sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_kill(__threadid: pthread_t, __signo: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::libc::c_int;
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(__name: *const ::libc::c_char, __type: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn faccessat(__fd: ::libc::c_int, __file: *const ::libc::c_char,
                     __type: ::libc::c_int, __flag: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lseek(__fd: ::libc::c_int, __offset: __off_t,
                 __whence: ::libc::c_int) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn read(__fd: ::libc::c_int, __buf: *mut ::libc::c_void,
                __nbytes: usize) -> isize;
}
extern "C" {
    pub fn write(__fd: ::libc::c_int, __buf: *const ::libc::c_void,
                 __n: usize) -> isize;
}
extern "C" {
    pub fn pread(__fd: ::libc::c_int, __buf: *mut ::libc::c_void,
                 __nbytes: usize, __offset: __off_t) -> isize;
}
extern "C" {
    pub fn pwrite(__fd: ::libc::c_int, __buf: *const ::libc::c_void,
                  __n: usize, __offset: __off_t) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::libc::c_uint) -> ::libc::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::libc::c_uint) -> ::libc::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t)
     -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pause() -> ::libc::c_int;
}
extern "C" {
    pub fn chown(__file: *const ::libc::c_char, __owner: __uid_t,
                 __group: __gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn fchown(__fd: ::libc::c_int, __owner: __uid_t, __group: __gid_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lchown(__file: *const ::libc::c_char, __owner: __uid_t,
                  __group: __gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn fchownat(__fd: ::libc::c_int, __file: *const ::libc::c_char,
                    __owner: __uid_t, __group: __gid_t, __flag: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::libc::c_char, __size: usize)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn dup(__fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::libc::c_int, __fd2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "__environ"]
    pub static mut __environ: *mut *mut ::libc::c_char;
}
extern "C" {
    pub fn execve(__path: *const ::libc::c_char,
                  __argv: *const *const ::libc::c_char,
                  __envp: *const *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn fexecve(__fd: ::libc::c_int, __argv: *const *const ::libc::c_char,
                   __envp: *const *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn execv(__path: *const ::libc::c_char,
                 __argv: *const *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn execle(__path: *const ::libc::c_char,
                  __arg: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn execl(__path: *const ::libc::c_char,
                 __arg: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn execvp(__file: *const ::libc::c_char,
                  __argv: *const *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn execlp(__file: *const ::libc::c_char,
                  __arg: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn nice(__inc: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn _exit(__status: ::libc::c_int);
}
pub const _PC_LINK_MAX: _bindgen_ty_10 = _bindgen_ty_10::_PC_LINK_MAX;
pub const _PC_MAX_CANON: _bindgen_ty_10 = _bindgen_ty_10::_PC_MAX_CANON;
pub const _PC_MAX_INPUT: _bindgen_ty_10 = _bindgen_ty_10::_PC_MAX_INPUT;
pub const _PC_NAME_MAX: _bindgen_ty_10 = _bindgen_ty_10::_PC_NAME_MAX;
pub const _PC_PATH_MAX: _bindgen_ty_10 = _bindgen_ty_10::_PC_PATH_MAX;
pub const _PC_PIPE_BUF: _bindgen_ty_10 = _bindgen_ty_10::_PC_PIPE_BUF;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_10 =
    _bindgen_ty_10::_PC_CHOWN_RESTRICTED;
pub const _PC_NO_TRUNC: _bindgen_ty_10 = _bindgen_ty_10::_PC_NO_TRUNC;
pub const _PC_VDISABLE: _bindgen_ty_10 = _bindgen_ty_10::_PC_VDISABLE;
pub const _PC_SYNC_IO: _bindgen_ty_10 = _bindgen_ty_10::_PC_SYNC_IO;
pub const _PC_ASYNC_IO: _bindgen_ty_10 = _bindgen_ty_10::_PC_ASYNC_IO;
pub const _PC_PRIO_IO: _bindgen_ty_10 = _bindgen_ty_10::_PC_PRIO_IO;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_10 = _bindgen_ty_10::_PC_SOCK_MAXBUF;
pub const _PC_FILESIZEBITS: _bindgen_ty_10 = _bindgen_ty_10::_PC_FILESIZEBITS;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_10 =
    _bindgen_ty_10::_PC_REC_INCR_XFER_SIZE;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_10 =
    _bindgen_ty_10::_PC_REC_MAX_XFER_SIZE;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_10 =
    _bindgen_ty_10::_PC_REC_MIN_XFER_SIZE;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_10 =
    _bindgen_ty_10::_PC_REC_XFER_ALIGN;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_10 =
    _bindgen_ty_10::_PC_ALLOC_SIZE_MIN;
pub const _PC_SYMLINK_MAX: _bindgen_ty_10 = _bindgen_ty_10::_PC_SYMLINK_MAX;
pub const _PC_2_SYMLINKS: _bindgen_ty_10 = _bindgen_ty_10::_PC_2_SYMLINKS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20,
}
pub const _SC_ARG_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_ARG_MAX;
pub const _SC_CHILD_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_CHILD_MAX;
pub const _SC_CLK_TCK: _bindgen_ty_11 = _bindgen_ty_11::_SC_CLK_TCK;
pub const _SC_NGROUPS_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_NGROUPS_MAX;
pub const _SC_OPEN_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_OPEN_MAX;
pub const _SC_STREAM_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_STREAM_MAX;
pub const _SC_TZNAME_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_TZNAME_MAX;
pub const _SC_JOB_CONTROL: _bindgen_ty_11 = _bindgen_ty_11::_SC_JOB_CONTROL;
pub const _SC_SAVED_IDS: _bindgen_ty_11 = _bindgen_ty_11::_SC_SAVED_IDS;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_REALTIME_SIGNALS;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_PRIORITY_SCHEDULING;
pub const _SC_TIMERS: _bindgen_ty_11 = _bindgen_ty_11::_SC_TIMERS;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_ASYNCHRONOUS_IO;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_PRIORITIZED_IO;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_SYNCHRONIZED_IO;
pub const _SC_FSYNC: _bindgen_ty_11 = _bindgen_ty_11::_SC_FSYNC;
pub const _SC_MAPPED_FILES: _bindgen_ty_11 = _bindgen_ty_11::_SC_MAPPED_FILES;
pub const _SC_MEMLOCK: _bindgen_ty_11 = _bindgen_ty_11::_SC_MEMLOCK;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_MEMLOCK_RANGE;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_MEMORY_PROTECTION;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_MESSAGE_PASSING;
pub const _SC_SEMAPHORES: _bindgen_ty_11 = _bindgen_ty_11::_SC_SEMAPHORES;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_SHARED_MEMORY_OBJECTS;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_AIO_LISTIO_MAX;
pub const _SC_AIO_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_AIO_MAX;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_AIO_PRIO_DELTA_MAX;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_DELAYTIMER_MAX;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_MQ_OPEN_MAX;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_MQ_PRIO_MAX;
pub const _SC_VERSION: _bindgen_ty_11 = _bindgen_ty_11::_SC_VERSION;
pub const _SC_PAGESIZE: _bindgen_ty_11 = _bindgen_ty_11::_SC_PAGESIZE;
pub const _SC_RTSIG_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_RTSIG_MAX;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_SEM_NSEMS_MAX;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_SEM_VALUE_MAX;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_SIGQUEUE_MAX;
pub const _SC_TIMER_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_TIMER_MAX;
pub const _SC_BC_BASE_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_BC_BASE_MAX;
pub const _SC_BC_DIM_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_BC_DIM_MAX;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_BC_SCALE_MAX;
pub const _SC_BC_STRING_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_BC_STRING_MAX;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_COLL_WEIGHTS_MAX;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_EQUIV_CLASS_MAX;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_EXPR_NEST_MAX;
pub const _SC_LINE_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_LINE_MAX;
pub const _SC_RE_DUP_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_RE_DUP_MAX;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_CHARCLASS_NAME_MAX;
pub const _SC_2_VERSION: _bindgen_ty_11 = _bindgen_ty_11::_SC_2_VERSION;
pub const _SC_2_C_BIND: _bindgen_ty_11 = _bindgen_ty_11::_SC_2_C_BIND;
pub const _SC_2_C_DEV: _bindgen_ty_11 = _bindgen_ty_11::_SC_2_C_DEV;
pub const _SC_2_FORT_DEV: _bindgen_ty_11 = _bindgen_ty_11::_SC_2_FORT_DEV;
pub const _SC_2_FORT_RUN: _bindgen_ty_11 = _bindgen_ty_11::_SC_2_FORT_RUN;
pub const _SC_2_SW_DEV: _bindgen_ty_11 = _bindgen_ty_11::_SC_2_SW_DEV;
pub const _SC_2_LOCALEDEF: _bindgen_ty_11 = _bindgen_ty_11::_SC_2_LOCALEDEF;
pub const _SC_PII: _bindgen_ty_11 = _bindgen_ty_11::_SC_PII;
pub const _SC_PII_XTI: _bindgen_ty_11 = _bindgen_ty_11::_SC_PII_XTI;
pub const _SC_PII_SOCKET: _bindgen_ty_11 = _bindgen_ty_11::_SC_PII_SOCKET;
pub const _SC_PII_INTERNET: _bindgen_ty_11 = _bindgen_ty_11::_SC_PII_INTERNET;
pub const _SC_PII_OSI: _bindgen_ty_11 = _bindgen_ty_11::_SC_PII_OSI;
pub const _SC_POLL: _bindgen_ty_11 = _bindgen_ty_11::_SC_POLL;
pub const _SC_SELECT: _bindgen_ty_11 = _bindgen_ty_11::_SC_SELECT;
pub const _SC_UIO_MAXIOV: _bindgen_ty_11 = _bindgen_ty_11::_SC_UIO_MAXIOV;
pub const _SC_IOV_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_UIO_MAXIOV;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_PII_INTERNET_STREAM;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_PII_INTERNET_DGRAM;
pub const _SC_PII_OSI_COTS: _bindgen_ty_11 = _bindgen_ty_11::_SC_PII_OSI_COTS;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_11 = _bindgen_ty_11::_SC_PII_OSI_CLTS;
pub const _SC_PII_OSI_M: _bindgen_ty_11 = _bindgen_ty_11::_SC_PII_OSI_M;
pub const _SC_T_IOV_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_T_IOV_MAX;
pub const _SC_THREADS: _bindgen_ty_11 = _bindgen_ty_11::_SC_THREADS;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_SAFE_FUNCTIONS;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_GETGR_R_SIZE_MAX;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_GETPW_R_SIZE_MAX;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LOGIN_NAME_MAX;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_TTY_NAME_MAX;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_DESTRUCTOR_ITERATIONS;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_KEYS_MAX;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_STACK_MIN;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_THREADS_MAX;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_ATTR_STACKADDR;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_ATTR_STACKSIZE;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_PRIORITY_SCHEDULING;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_PRIO_INHERIT;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_PRIO_PROTECT;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_PROCESS_SHARED;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_NPROCESSORS_CONF;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_NPROCESSORS_ONLN;
pub const _SC_PHYS_PAGES: _bindgen_ty_11 = _bindgen_ty_11::_SC_PHYS_PAGES;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_11 = _bindgen_ty_11::_SC_AVPHYS_PAGES;
pub const _SC_ATEXIT_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_ATEXIT_MAX;
pub const _SC_PASS_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_PASS_MAX;
pub const _SC_XOPEN_VERSION: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_XOPEN_VERSION;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_XOPEN_XCU_VERSION;
pub const _SC_XOPEN_UNIX: _bindgen_ty_11 = _bindgen_ty_11::_SC_XOPEN_UNIX;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_11 = _bindgen_ty_11::_SC_XOPEN_CRYPT;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_XOPEN_ENH_I18N;
pub const _SC_XOPEN_SHM: _bindgen_ty_11 = _bindgen_ty_11::_SC_XOPEN_SHM;
pub const _SC_2_CHAR_TERM: _bindgen_ty_11 = _bindgen_ty_11::_SC_2_CHAR_TERM;
pub const _SC_2_C_VERSION: _bindgen_ty_11 = _bindgen_ty_11::_SC_2_C_VERSION;
pub const _SC_2_UPE: _bindgen_ty_11 = _bindgen_ty_11::_SC_2_UPE;
pub const _SC_XOPEN_XPG2: _bindgen_ty_11 = _bindgen_ty_11::_SC_XOPEN_XPG2;
pub const _SC_XOPEN_XPG3: _bindgen_ty_11 = _bindgen_ty_11::_SC_XOPEN_XPG3;
pub const _SC_XOPEN_XPG4: _bindgen_ty_11 = _bindgen_ty_11::_SC_XOPEN_XPG4;
pub const _SC_CHAR_BIT: _bindgen_ty_11 = _bindgen_ty_11::_SC_CHAR_BIT;
pub const _SC_CHAR_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_CHAR_MAX;
pub const _SC_CHAR_MIN: _bindgen_ty_11 = _bindgen_ty_11::_SC_CHAR_MIN;
pub const _SC_INT_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_INT_MAX;
pub const _SC_INT_MIN: _bindgen_ty_11 = _bindgen_ty_11::_SC_INT_MIN;
pub const _SC_LONG_BIT: _bindgen_ty_11 = _bindgen_ty_11::_SC_LONG_BIT;
pub const _SC_WORD_BIT: _bindgen_ty_11 = _bindgen_ty_11::_SC_WORD_BIT;
pub const _SC_MB_LEN_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_MB_LEN_MAX;
pub const _SC_NZERO: _bindgen_ty_11 = _bindgen_ty_11::_SC_NZERO;
pub const _SC_SSIZE_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_SSIZE_MAX;
pub const _SC_SCHAR_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_SCHAR_MAX;
pub const _SC_SCHAR_MIN: _bindgen_ty_11 = _bindgen_ty_11::_SC_SCHAR_MIN;
pub const _SC_SHRT_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_SHRT_MAX;
pub const _SC_SHRT_MIN: _bindgen_ty_11 = _bindgen_ty_11::_SC_SHRT_MIN;
pub const _SC_UCHAR_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_UCHAR_MAX;
pub const _SC_UINT_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_UINT_MAX;
pub const _SC_ULONG_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_ULONG_MAX;
pub const _SC_USHRT_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_USHRT_MAX;
pub const _SC_NL_ARGMAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_NL_ARGMAX;
pub const _SC_NL_LANGMAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_NL_LANGMAX;
pub const _SC_NL_MSGMAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_NL_MSGMAX;
pub const _SC_NL_NMAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_NL_NMAX;
pub const _SC_NL_SETMAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_NL_SETMAX;
pub const _SC_NL_TEXTMAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_NL_TEXTMAX;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_XBS5_ILP32_OFF32;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_XBS5_ILP32_OFFBIG;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_XBS5_LP64_OFF64;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_XBS5_LPBIG_OFFBIG;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_11 = _bindgen_ty_11::_SC_XOPEN_LEGACY;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_XOPEN_REALTIME;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_XOPEN_REALTIME_THREADS;
pub const _SC_ADVISORY_INFO: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_ADVISORY_INFO;
pub const _SC_BARRIERS: _bindgen_ty_11 = _bindgen_ty_11::_SC_BARRIERS;
pub const _SC_BASE: _bindgen_ty_11 = _bindgen_ty_11::_SC_BASE;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_C_LANG_SUPPORT;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_C_LANG_SUPPORT_R;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_CLOCK_SELECTION;
pub const _SC_CPUTIME: _bindgen_ty_11 = _bindgen_ty_11::_SC_CPUTIME;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_CPUTIME;
pub const _SC_DEVICE_IO: _bindgen_ty_11 = _bindgen_ty_11::_SC_DEVICE_IO;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_DEVICE_SPECIFIC;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_DEVICE_SPECIFIC_R;
pub const _SC_FD_MGMT: _bindgen_ty_11 = _bindgen_ty_11::_SC_FD_MGMT;
pub const _SC_FIFO: _bindgen_ty_11 = _bindgen_ty_11::_SC_FIFO;
pub const _SC_PIPE: _bindgen_ty_11 = _bindgen_ty_11::_SC_PIPE;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_FILE_ATTRIBUTES;
pub const _SC_FILE_LOCKING: _bindgen_ty_11 = _bindgen_ty_11::_SC_FILE_LOCKING;
pub const _SC_FILE_SYSTEM: _bindgen_ty_11 = _bindgen_ty_11::_SC_FILE_SYSTEM;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_MONOTONIC_CLOCK;
pub const _SC_MULTI_PROCESS: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_MULTI_PROCESS;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_SINGLE_PROCESS;
pub const _SC_NETWORKING: _bindgen_ty_11 = _bindgen_ty_11::_SC_NETWORKING;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_READER_WRITER_LOCKS;
pub const _SC_SPIN_LOCKS: _bindgen_ty_11 = _bindgen_ty_11::_SC_SPIN_LOCKS;
pub const _SC_REGEXP: _bindgen_ty_11 = _bindgen_ty_11::_SC_REGEXP;
pub const _SC_REGEX_VERSION: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_REGEX_VERSION;
pub const _SC_SHELL: _bindgen_ty_11 = _bindgen_ty_11::_SC_SHELL;
pub const _SC_SIGNALS: _bindgen_ty_11 = _bindgen_ty_11::_SC_SIGNALS;
pub const _SC_SPAWN: _bindgen_ty_11 = _bindgen_ty_11::_SC_SPAWN;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_SPORADIC_SERVER;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_SPORADIC_SERVER;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_SYSTEM_DATABASE;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_SYSTEM_DATABASE_R;
pub const _SC_TIMEOUTS: _bindgen_ty_11 = _bindgen_ty_11::_SC_TIMEOUTS;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_TYPED_MEMORY_OBJECTS;
pub const _SC_USER_GROUPS: _bindgen_ty_11 = _bindgen_ty_11::_SC_USER_GROUPS;
pub const _SC_USER_GROUPS_R: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_USER_GROUPS_R;
pub const _SC_2_PBS: _bindgen_ty_11 = _bindgen_ty_11::_SC_2_PBS;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_2_PBS_ACCOUNTING;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_11 = _bindgen_ty_11::_SC_2_PBS_LOCATE;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_2_PBS_MESSAGE;
pub const _SC_2_PBS_TRACK: _bindgen_ty_11 = _bindgen_ty_11::_SC_2_PBS_TRACK;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_SYMLOOP_MAX;
pub const _SC_STREAMS: _bindgen_ty_11 = _bindgen_ty_11::_SC_STREAMS;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_2_PBS_CHECKPOINT;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_V6_ILP32_OFF32;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_V6_ILP32_OFFBIG;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_V6_LP64_OFF64;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_V6_LPBIG_OFFBIG;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_HOST_NAME_MAX;
pub const _SC_TRACE: _bindgen_ty_11 = _bindgen_ty_11::_SC_TRACE;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_TRACE_EVENT_FILTER;
pub const _SC_TRACE_INHERIT: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_TRACE_INHERIT;
pub const _SC_TRACE_LOG: _bindgen_ty_11 = _bindgen_ty_11::_SC_TRACE_LOG;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL1_ICACHE_SIZE;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL1_ICACHE_ASSOC;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL1_ICACHE_LINESIZE;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL1_DCACHE_SIZE;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL1_DCACHE_ASSOC;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL1_DCACHE_LINESIZE;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL2_CACHE_SIZE;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL2_CACHE_ASSOC;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL2_CACHE_LINESIZE;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL3_CACHE_SIZE;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL3_CACHE_ASSOC;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL3_CACHE_LINESIZE;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL4_CACHE_SIZE;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL4_CACHE_ASSOC;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_LEVEL4_CACHE_LINESIZE;
pub const _SC_IPV6: _bindgen_ty_11 = _bindgen_ty_11::_SC_IPV6;
pub const _SC_RAW_SOCKETS: _bindgen_ty_11 = _bindgen_ty_11::_SC_RAW_SOCKETS;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_V7_ILP32_OFF32;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_V7_ILP32_OFFBIG;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_V7_LP64_OFF64;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_V7_LPBIG_OFFBIG;
pub const _SC_SS_REPL_MAX: _bindgen_ty_11 = _bindgen_ty_11::_SC_SS_REPL_MAX;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_TRACE_EVENT_NAME_MAX;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_TRACE_NAME_MAX;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_TRACE_SYS_MAX;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_TRACE_USER_EVENT_MAX;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_XOPEN_STREAMS;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_ROBUST_PRIO_INHERIT;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_11 =
    _bindgen_ty_11::_SC_THREAD_ROBUST_PRIO_PROTECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_11 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
}
pub const _CS_PATH: _bindgen_ty_12 = _bindgen_ty_12::_CS_PATH;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_V6_WIDTH_RESTRICTED_ENVS;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_GNU_LIBC_VERSION;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_GNU_LIBPTHREAD_VERSION;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_V5_WIDTH_RESTRICTED_ENVS;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_V7_WIDTH_RESTRICTED_ENVS;
pub const _CS_LFS_CFLAGS: _bindgen_ty_12 = _bindgen_ty_12::_CS_LFS_CFLAGS;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_12 = _bindgen_ty_12::_CS_LFS_LDFLAGS;
pub const _CS_LFS_LIBS: _bindgen_ty_12 = _bindgen_ty_12::_CS_LFS_LIBS;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_LFS_LINTFLAGS;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_12 = _bindgen_ty_12::_CS_LFS64_CFLAGS;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_LFS64_LDFLAGS;
pub const _CS_LFS64_LIBS: _bindgen_ty_12 = _bindgen_ty_12::_CS_LFS64_LIBS;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_LFS64_LINTFLAGS;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_ILP32_OFF32_CFLAGS;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_ILP32_OFF32_LDFLAGS;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_ILP32_OFF32_LIBS;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_ILP32_OFF32_LINTFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_ILP32_OFFBIG_CFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_ILP32_OFFBIG_LDFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_ILP32_OFFBIG_LIBS;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_LP64_OFF64_CFLAGS;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_LP64_OFF64_LDFLAGS;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_LP64_OFF64_LIBS;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_LP64_OFF64_LINTFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_LPBIG_OFFBIG_CFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_LPBIG_OFFBIG_LIBS;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_ILP32_OFF32_CFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_ILP32_OFF32_LDFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_ILP32_OFF32_LIBS;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_ILP32_OFFBIG_LIBS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_LP64_OFF64_CFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_LP64_OFF64_LDFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_LP64_OFF64_LIBS;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_LP64_OFF64_LINTFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_LPBIG_OFFBIG_LIBS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_ILP32_OFF32_CFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_ILP32_OFF32_LDFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_ILP32_OFF32_LIBS;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_ILP32_OFFBIG_LIBS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_LP64_OFF64_CFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_LP64_OFF64_LDFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_LP64_OFF64_LIBS;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_LP64_OFF64_LINTFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_LPBIG_OFFBIG_LIBS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_12 =
    _bindgen_ty_12::_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_V6_ENV: _bindgen_ty_12 = _bindgen_ty_12::_CS_V6_ENV;
pub const _CS_V7_ENV: _bindgen_ty_12 = _bindgen_ty_12::_CS_V7_ENV;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_12 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149,
}
extern "C" {
    pub fn pathconf(__path: *const ::libc::c_char, __name: ::libc::c_int)
     -> ::libc::c_long;
}
extern "C" {
    pub fn fpathconf(__fd: ::libc::c_int, __name: ::libc::c_int)
     -> ::libc::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::libc::c_int) -> ::libc::c_long;
}
extern "C" {
    pub fn confstr(__name: ::libc::c_int, __buf: *mut ::libc::c_char,
                   __len: usize) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::libc::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::libc::c_int, __list: *mut __gid_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::libc::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ttyname_r(__fd: ::libc::c_int, __buf: *mut ::libc::c_char,
                     __buflen: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::libc::c_int;
}
extern "C" {
    pub fn link(__from: *const ::libc::c_char, __to: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn linkat(__fromfd: ::libc::c_int, __from: *const ::libc::c_char,
                  __tofd: ::libc::c_int, __to: *const ::libc::c_char,
                  __flags: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn symlink(__from: *const ::libc::c_char, __to: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn readlink(__path: *const ::libc::c_char, __buf: *mut ::libc::c_char,
                    __len: usize) -> isize;
}
extern "C" {
    pub fn symlinkat(__from: *const ::libc::c_char, __tofd: ::libc::c_int,
                     __to: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn readlinkat(__fd: ::libc::c_int, __path: *const ::libc::c_char,
                      __buf: *mut ::libc::c_char, __len: usize) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn unlinkat(__fd: ::libc::c_int, __name: *const ::libc::c_char,
                    __flag: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::libc::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::libc::c_int, __pgrp_id: __pid_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::libc::c_char;
}
extern "C" {
    pub fn getlogin_r(__name: *mut ::libc::c_char, __name_len: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "optarg"]
    pub static mut optarg: *mut ::libc::c_char;
}
extern "C" {
    #[link_name = "optind"]
    pub static mut optind: ::libc::c_int;
}
extern "C" {
    #[link_name = "opterr"]
    pub static mut opterr: ::libc::c_int;
}
extern "C" {
    #[link_name = "optopt"]
    pub static mut optopt: ::libc::c_int;
}
extern "C" {
    pub fn getopt(___argc: ::libc::c_int,
                  ___argv: *const *const ::libc::c_char,
                  __shortopts: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::libc::c_char, __len: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn sethostname(__name: *const ::libc::c_char, __len: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::libc::c_long) -> ::libc::c_int;
}
extern "C" {
    pub fn getdomainname(__name: *mut ::libc::c_char, __len: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn setdomainname(__name: *const ::libc::c_char, __len: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn vhangup() -> ::libc::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn profil(__sample_buffer: *mut ::libc::c_ushort, __size: usize,
                  __offset: usize, __scale: ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::libc::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(__nochdir: ::libc::c_int, __noclose: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn gethostid() -> ::libc::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::libc::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::libc::c_int;
}
extern "C" {
    pub fn truncate(__file: *const ::libc::c_char, __length: __off_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::libc::c_int, __length: __off_t) -> ::libc::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::libc::c_long, ...) -> ::libc::c_long;
}
extern "C" {
    pub fn lockf(__fd: ::libc::c_int, __cmd: ::libc::c_int, __len: __off_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn getentropy(__buffer: *mut ::libc::c_void, __length: usize)
     -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct winsize {
    pub ws_row: ::libc::c_ushort,
    pub ws_col: ::libc::c_ushort,
    pub ws_xpixel: ::libc::c_ushort,
    pub ws_ypixel: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout_winsize() {
    assert_eq!(::core::mem::size_of::<winsize>() , 8usize , concat ! (
               "Size of: " , stringify ! ( winsize ) ));
    assert_eq! (::core::mem::align_of::<winsize>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( winsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const winsize ) ) . ws_row as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( winsize ) , "::" ,
                stringify ! ( ws_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const winsize ) ) . ws_col as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( winsize ) , "::" ,
                stringify ! ( ws_col ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const winsize ) ) . ws_xpixel as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( winsize ) , "::" ,
                stringify ! ( ws_xpixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const winsize ) ) . ws_ypixel as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( winsize ) , "::" ,
                stringify ! ( ws_ypixel ) ));
}
impl Clone for winsize {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct termio {
    pub c_iflag: ::libc::c_ushort,
    pub c_oflag: ::libc::c_ushort,
    pub c_cflag: ::libc::c_ushort,
    pub c_lflag: ::libc::c_ushort,
    pub c_line: ::libc::c_uchar,
    pub c_cc: [::libc::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_termio() {
    assert_eq!(::core::mem::size_of::<termio>() , 18usize , concat ! (
               "Size of: " , stringify ! ( termio ) ));
    assert_eq! (::core::mem::align_of::<termio>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( termio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const termio ) ) . c_iflag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( termio ) , "::" ,
                stringify ! ( c_iflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const termio ) ) . c_oflag as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( termio ) , "::" ,
                stringify ! ( c_oflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const termio ) ) . c_cflag as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( termio ) , "::" ,
                stringify ! ( c_cflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const termio ) ) . c_lflag as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( termio ) , "::" ,
                stringify ! ( c_lflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const termio ) ) . c_line as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( termio ) , "::" ,
                stringify ! ( c_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const termio ) ) . c_cc as * const _ as usize }
                , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( termio ) , "::" ,
                stringify ! ( c_cc ) ));
}
impl Clone for termio {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn ioctl(__fd: ::libc::c_int, __request: ::libc::c_ulong, ...)
     -> ::libc::c_int;
}
extern "C" {
    pub fn spl_pagesize() -> usize;
}
extern "C" {
    pub fn random() -> ::libc::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::libc::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::libc::c_uint, __statebuf: *mut ::libc::c_char,
                     __statelen: usize) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::libc::c_int,
    pub rand_deg: ::libc::c_int,
    pub rand_sep: ::libc::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::core::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::core::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::libc::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::libc::c_uint, __buf: *mut random_data)
     -> ::libc::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::libc::c_uint,
                       __statebuf: *mut ::libc::c_char, __statelen: usize,
                       __buf: *mut random_data) -> ::libc::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::libc::c_char,
                      __buf: *mut random_data) -> ::libc::c_int;
}
extern "C" {
    pub fn rand() -> ::libc::c_int;
}
extern "C" {
    pub fn srand(__seed: ::libc::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::libc::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::libc::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::libc::c_ushort) -> ::libc::c_long;
}
extern "C" {
    pub fn mrand48() -> ::libc::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::libc::c_ushort) -> ::libc::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::libc::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::libc::c_ushort) -> *mut ::libc::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::libc::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drand48_data {
    pub __x: [::libc::c_ushort; 3usize],
    pub __old_x: [::libc::c_ushort; 3usize],
    pub __c: ::libc::c_ushort,
    pub __init: ::libc::c_ushort,
    pub __a: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::core::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::core::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::libc::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::libc::c_long) -> ::libc::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::libc::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::libc::c_long) -> ::libc::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::libc::c_long) -> ::libc::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::libc::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::libc::c_long) -> ::libc::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::libc::c_long, __buffer: *mut drand48_data)
     -> ::libc::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::libc::c_ushort,
                    __buffer: *mut drand48_data) -> ::libc::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::libc::c_ushort,
                     __buffer: *mut drand48_data) -> ::libc::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::libc::c_void, __size: usize)
     -> *mut ::libc::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::libc::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::libc::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::libc::c_void,
                          __alignment: usize, __size: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::libc::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>)
     -> ::libc::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::core::option::Option<unsafe extern "C" fn()>)
     -> ::libc::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::core::option::Option<unsafe extern "C" fn(__status:
                                                                       ::libc::c_int,
                                                                   __arg:
                                                                       *mut ::libc::c_void)>,
                   __arg: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn exit(__status: ::libc::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::libc::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::libc::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::libc::c_char,
                  __value: *const ::libc::c_char, __replace: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn clearenv() -> ::libc::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::libc::c_char,
                    __suffixlen: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn system(__command: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::libc::c_char,
                    __resolved: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
pub type __compar_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *const ::libc::c_void,
                                                arg2: *const ::libc::c_void)
                               -> ::libc::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::libc::c_void,
                   __base: *const ::libc::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::libc::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::libc::c_void, __nmemb: usize, __size: usize,
                 __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn labs(__x: ::libc::c_long) -> ::libc::c_long;
}
extern "C" {
    pub fn llabs(__x: ::libc::c_longlong) -> ::libc::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::libc::c_int, __denom: ::libc::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::libc::c_long, __denom: ::libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::libc::c_longlong, __denom: ::libc::c_longlong)
     -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::libc::c_int,
                __decpt: *mut ::libc::c_int, __sign: *mut ::libc::c_int)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::libc::c_int,
                __decpt: *mut ::libc::c_int, __sign: *mut ::libc::c_int)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::libc::c_int,
                __buf: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::libc::c_int,
                 __decpt: *mut ::libc::c_int, __sign: *mut ::libc::c_int)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::libc::c_int,
                 __decpt: *mut ::libc::c_int, __sign: *mut ::libc::c_int)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::libc::c_int,
                 __buf: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::libc::c_int,
                  __decpt: *mut ::libc::c_int, __sign: *mut ::libc::c_int,
                  __buf: *mut ::libc::c_char, __len: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::libc::c_int,
                  __decpt: *mut ::libc::c_int, __sign: *mut ::libc::c_int,
                  __buf: *mut ::libc::c_char, __len: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::libc::c_int,
                   __decpt: *mut ::libc::c_int, __sign: *mut ::libc::c_int,
                   __buf: *mut ::libc::c_char, __len: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::libc::c_int,
                   __decpt: *mut ::libc::c_int, __sign: *mut ::libc::c_int,
                   __buf: *mut ::libc::c_char, __len: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::libc::c_char, __n: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::libc::c_char, __n: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::libc::c_char, __wchar: wchar_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::libc::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::libc::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::libc::c_char,
                     __tokens: *const *const ::libc::c_char,
                     __valuep: *mut *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn getexecname() -> *const ::libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::libc::c_int,
    pub tz_dsttime: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::core::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::core::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
pub type __timezone_ptr_t = *mut timezone;
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone)
     -> ::libc::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval)
     -> ::libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::core::mem::size_of::<itimerval>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerval ) ));
    assert_eq! (::core::mem::align_of::<itimerval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
pub type __itimer_which_t = ::libc::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval)
     -> ::libc::c_int;
}
extern "C" {
    pub fn setitimer(__which: __itimer_which_t, __new: *const itimerval,
                     __old: *mut itimerval) -> ::libc::c_int;
}
extern "C" {
    pub fn utimes(__file: *const ::libc::c_char, __tvp: *const timeval)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lutimes(__file: *const ::libc::c_char, __tvp: *const timeval)
     -> ::libc::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::libc::c_int, __tvp: *const timeval)
     -> ::libc::c_int;
}
pub type hrtime_t = ::libc::c_longlong;
pub type timestruc_t = timespec;
pub type timespec_t = timespec;
extern "C" {
    pub fn gethrtime() -> hrtime_t;
}
extern "C" {
    pub fn gethrestime(arg1: *mut timestruc_t);
}
extern "C" {
    pub fn __errno_location() -> *mut ::libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum data_type_t {
    DATA_TYPE_UNKNOWN = 0,
    DATA_TYPE_BOOLEAN = 1,
    DATA_TYPE_BYTE = 2,
    DATA_TYPE_INT16 = 3,
    DATA_TYPE_UINT16 = 4,
    DATA_TYPE_INT32 = 5,
    DATA_TYPE_UINT32 = 6,
    DATA_TYPE_INT64 = 7,
    DATA_TYPE_UINT64 = 8,
    DATA_TYPE_STRING = 9,
    DATA_TYPE_BYTE_ARRAY = 10,
    DATA_TYPE_INT16_ARRAY = 11,
    DATA_TYPE_UINT16_ARRAY = 12,
    DATA_TYPE_INT32_ARRAY = 13,
    DATA_TYPE_UINT32_ARRAY = 14,
    DATA_TYPE_INT64_ARRAY = 15,
    DATA_TYPE_UINT64_ARRAY = 16,
    DATA_TYPE_STRING_ARRAY = 17,
    DATA_TYPE_HRTIME = 18,
    DATA_TYPE_NVLIST = 19,
    DATA_TYPE_NVLIST_ARRAY = 20,
    DATA_TYPE_BOOLEAN_VALUE = 21,
    DATA_TYPE_INT8 = 22,
    DATA_TYPE_UINT8 = 23,
    DATA_TYPE_BOOLEAN_ARRAY = 24,
    DATA_TYPE_INT8_ARRAY = 25,
    DATA_TYPE_UINT8_ARRAY = 26,
    DATA_TYPE_DOUBLE = 27,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvpair {
    pub nvp_size: i32,
    pub nvp_name_sz: i16,
    pub nvp_reserve: i16,
    pub nvp_value_elem: i32,
    pub nvp_type: data_type_t,
}
#[test]
fn bindgen_test_layout_nvpair() {
    assert_eq!(::core::mem::size_of::<nvpair>() , 16usize , concat ! (
               "Size of: " , stringify ! ( nvpair ) ));
    assert_eq! (::core::mem::align_of::<nvpair>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nvpair ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvpair ) ) . nvp_size as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvpair ) , "::" ,
                stringify ! ( nvp_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvpair ) ) . nvp_name_sz as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvpair ) , "::" ,
                stringify ! ( nvp_name_sz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvpair ) ) . nvp_reserve as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( nvpair ) , "::" ,
                stringify ! ( nvp_reserve ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvpair ) ) . nvp_value_elem as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvpair ) , "::" ,
                stringify ! ( nvp_value_elem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvpair ) ) . nvp_type as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( nvpair ) , "::" ,
                stringify ! ( nvp_type ) ));
}
impl Clone for nvpair {
    fn clone(&self) -> Self { *self }
}
pub type nvpair_t = nvpair;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvlist {
    pub nvl_version: i32,
    pub nvl_nvflag: u32,
    pub nvl_priv: u64,
    pub nvl_flag: u32,
    pub nvl_pad: i32,
}
#[test]
fn bindgen_test_layout_nvlist() {
    assert_eq!(::core::mem::size_of::<nvlist>() , 24usize , concat ! (
               "Size of: " , stringify ! ( nvlist ) ));
    assert_eq! (::core::mem::align_of::<nvlist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nvlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvlist ) ) . nvl_version as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvlist ) , "::" ,
                stringify ! ( nvl_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvlist ) ) . nvl_nvflag as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvlist ) , "::" ,
                stringify ! ( nvl_nvflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvlist ) ) . nvl_priv as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvlist ) , "::" ,
                stringify ! ( nvl_priv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvlist ) ) . nvl_flag as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvlist ) , "::" ,
                stringify ! ( nvl_flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvlist ) ) . nvl_pad as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( nvlist ) , "::" ,
                stringify ! ( nvl_pad ) ));
}
impl Clone for nvlist {
    fn clone(&self) -> Self { *self }
}
pub type nvlist_t = nvlist;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nv_alloc_ops {
    pub nv_ao_init: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut nv_alloc_t,
                                                                arg2:
                                                                    *mut __va_list_tag)
                                               -> ::libc::c_int>,
    pub nv_ao_fini: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut nv_alloc_t)>,
    pub nv_ao_alloc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut nv_alloc_t,
                                                                 arg2: usize)
                                                -> *mut ::libc::c_void>,
    pub nv_ao_free: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut nv_alloc_t,
                                                                arg2:
                                                                    *mut ::libc::c_void,
                                                                arg3: usize)>,
    pub nv_ao_reset: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut nv_alloc_t)>,
}
#[test]
fn bindgen_test_layout_nv_alloc_ops() {
    assert_eq!(::core::mem::size_of::<nv_alloc_ops>() , 40usize , concat ! (
               "Size of: " , stringify ! ( nv_alloc_ops ) ));
    assert_eq! (::core::mem::align_of::<nv_alloc_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nv_alloc_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nv_alloc_ops ) ) . nv_ao_init as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nv_alloc_ops ) , "::" ,
                stringify ! ( nv_ao_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nv_alloc_ops ) ) . nv_ao_fini as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nv_alloc_ops ) , "::" ,
                stringify ! ( nv_ao_fini ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nv_alloc_ops ) ) . nv_ao_alloc as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nv_alloc_ops ) , "::" ,
                stringify ! ( nv_ao_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nv_alloc_ops ) ) . nv_ao_free as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nv_alloc_ops ) , "::" ,
                stringify ! ( nv_ao_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nv_alloc_ops ) ) . nv_ao_reset as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nv_alloc_ops ) , "::" ,
                stringify ! ( nv_ao_reset ) ));
}
impl Clone for nv_alloc_ops {
    fn clone(&self) -> Self { *self }
}
pub type nv_alloc_ops_t = nv_alloc_ops;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nv_alloc {
    pub nva_ops: *const nv_alloc_ops_t,
    pub nva_arg: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_nv_alloc() {
    assert_eq!(::core::mem::size_of::<nv_alloc>() , 16usize , concat ! (
               "Size of: " , stringify ! ( nv_alloc ) ));
    assert_eq! (::core::mem::align_of::<nv_alloc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nv_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nv_alloc ) ) . nva_ops as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nv_alloc ) , "::" ,
                stringify ! ( nva_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nv_alloc ) ) . nva_arg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nv_alloc ) , "::" ,
                stringify ! ( nva_arg ) ));
}
impl Clone for nv_alloc {
    fn clone(&self) -> Self { *self }
}
pub type nv_alloc_t = nv_alloc;
extern "C" {
    #[link_name = "nv_fixed_ops"]
    pub static mut nv_fixed_ops: *const nv_alloc_ops_t;
}
extern "C" {
    #[link_name = "nv_alloc_nosleep"]
    pub static mut nv_alloc_nosleep: *mut nv_alloc_t;
}
extern "C" {
    pub fn nv_alloc_init(arg1: *mut nv_alloc_t,
                         arg2: *const nv_alloc_ops_t, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn nv_alloc_reset(arg1: *mut nv_alloc_t);
}
extern "C" {
    pub fn nv_alloc_fini(arg1: *mut nv_alloc_t);
}
extern "C" {
    pub fn nvlist_alloc(arg1: *mut *mut nvlist_t, arg2: uint_t,
                        arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_free(arg1: *mut nvlist_t);
}
extern "C" {
    pub fn nvlist_size(arg1: *mut nvlist_t, arg2: *mut usize,
                       arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_pack(arg1: *mut nvlist_t, arg2: *mut *mut ::libc::c_char,
                       arg3: *mut usize, arg4: ::libc::c_int,
                       arg5: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_unpack(arg1: *mut ::libc::c_char, arg2: usize,
                         arg3: *mut *mut nvlist_t, arg4: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_dup(arg1: *mut nvlist_t, arg2: *mut *mut nvlist_t,
                      arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_merge(arg1: *mut nvlist_t, arg2: *mut nvlist_t,
                        arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_nvflag(arg1: *mut nvlist_t) -> uint_t;
}
extern "C" {
    pub fn nvlist_xalloc(arg1: *mut *mut nvlist_t, arg2: uint_t,
                         arg3: *mut nv_alloc_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_xpack(arg1: *mut nvlist_t, arg2: *mut *mut ::libc::c_char,
                        arg3: *mut usize, arg4: ::libc::c_int,
                        arg5: *mut nv_alloc_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_xunpack(arg1: *mut ::libc::c_char, arg2: usize,
                          arg3: *mut *mut nvlist_t, arg4: *mut nv_alloc_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_xdup(arg1: *mut nvlist_t, arg2: *mut *mut nvlist_t,
                       arg3: *mut nv_alloc_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_nv_alloc(arg1: *mut nvlist_t) -> *mut nv_alloc_t;
}
extern "C" {
    pub fn nvlist_add_nvpair(arg1: *mut nvlist_t, arg2: *mut nvpair_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_boolean(arg1: *mut nvlist_t,
                              arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_boolean_value(arg1: *mut nvlist_t,
                                    arg2: *const ::libc::c_char,
                                    arg3: boolean_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_byte(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                           arg3: uchar_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_int8(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                           arg3: i8) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_uint8(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                            arg3: u8) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_int16(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                            arg3: i16) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_uint16(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                             arg3: u16) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_int32(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                            arg3: i32) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_uint32(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                             arg3: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_int64(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                            arg3: i64) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_uint64(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                             arg3: u64) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_string(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                             arg3: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_nvlist(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                             arg3: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_boolean_array(arg1: *mut nvlist_t,
                                    arg2: *const ::libc::c_char,
                                    arg3: *mut boolean_t, arg4: uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_byte_array(arg1: *mut nvlist_t,
                                 arg2: *const ::libc::c_char,
                                 arg3: *mut uchar_t, arg4: uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_int8_array(arg1: *mut nvlist_t,
                                 arg2: *const ::libc::c_char, arg3: *mut i8,
                                 arg4: uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_uint8_array(arg1: *mut nvlist_t,
                                  arg2: *const ::libc::c_char, arg3: *mut u8,
                                  arg4: uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_int16_array(arg1: *mut nvlist_t,
                                  arg2: *const ::libc::c_char, arg3: *mut i16,
                                  arg4: uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_uint16_array(arg1: *mut nvlist_t,
                                   arg2: *const ::libc::c_char,
                                   arg3: *mut u16, arg4: uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_int32_array(arg1: *mut nvlist_t,
                                  arg2: *const ::libc::c_char, arg3: *mut i32,
                                  arg4: uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_uint32_array(arg1: *mut nvlist_t,
                                   arg2: *const ::libc::c_char,
                                   arg3: *mut u32, arg4: uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_int64_array(arg1: *mut nvlist_t,
                                  arg2: *const ::libc::c_char, arg3: *mut i64,
                                  arg4: uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_uint64_array(arg1: *mut nvlist_t,
                                   arg2: *const ::libc::c_char,
                                   arg3: *mut u64, arg4: uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_string_array(arg1: *mut nvlist_t,
                                   arg2: *const ::libc::c_char,
                                   arg3: *const *const ::libc::c_char,
                                   arg4: uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_nvlist_array(arg1: *mut nvlist_t,
                                   arg2: *const ::libc::c_char,
                                   arg3: *mut *mut nvlist_t, arg4: uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_hrtime(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                             arg3: hrtime_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_add_double(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                             arg3: f64) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_remove(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                         arg3: data_type_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_remove_all(arg1: *mut nvlist_t, arg2: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_remove_nvpair(arg1: *mut nvlist_t, arg2: *mut nvpair_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_boolean(arg1: *mut nvlist_t,
                                 arg2: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_boolean_value(arg1: *mut nvlist_t,
                                       arg2: *const ::libc::c_char,
                                       arg3: *mut boolean_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_byte(arg1: *mut nvlist_t,
                              arg2: *const ::libc::c_char, arg3: *mut uchar_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_int8(arg1: *mut nvlist_t,
                              arg2: *const ::libc::c_char, arg3: *mut i8)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_uint8(arg1: *mut nvlist_t,
                               arg2: *const ::libc::c_char, arg3: *mut u8)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_int16(arg1: *mut nvlist_t,
                               arg2: *const ::libc::c_char, arg3: *mut i16)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_uint16(arg1: *mut nvlist_t,
                                arg2: *const ::libc::c_char, arg3: *mut u16)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_int32(arg1: *mut nvlist_t,
                               arg2: *const ::libc::c_char, arg3: *mut i32)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_uint32(arg1: *mut nvlist_t,
                                arg2: *const ::libc::c_char, arg3: *mut u32)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_int64(arg1: *mut nvlist_t,
                               arg2: *const ::libc::c_char, arg3: *mut i64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_uint64(arg1: *mut nvlist_t,
                                arg2: *const ::libc::c_char, arg3: *mut u64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_string(arg1: *mut nvlist_t,
                                arg2: *const ::libc::c_char,
                                arg3: *mut *mut ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_nvlist(arg1: *mut nvlist_t,
                                arg2: *const ::libc::c_char,
                                arg3: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_boolean_array(arg1: *mut nvlist_t,
                                       arg2: *const ::libc::c_char,
                                       arg3: *mut *mut boolean_t,
                                       arg4: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_byte_array(arg1: *mut nvlist_t,
                                    arg2: *const ::libc::c_char,
                                    arg3: *mut *mut uchar_t,
                                    arg4: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_int8_array(arg1: *mut nvlist_t,
                                    arg2: *const ::libc::c_char,
                                    arg3: *mut *mut i8, arg4: *mut uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_uint8_array(arg1: *mut nvlist_t,
                                     arg2: *const ::libc::c_char,
                                     arg3: *mut *mut u8, arg4: *mut uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_int16_array(arg1: *mut nvlist_t,
                                     arg2: *const ::libc::c_char,
                                     arg3: *mut *mut i16, arg4: *mut uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_uint16_array(arg1: *mut nvlist_t,
                                      arg2: *const ::libc::c_char,
                                      arg3: *mut *mut u16, arg4: *mut uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_int32_array(arg1: *mut nvlist_t,
                                     arg2: *const ::libc::c_char,
                                     arg3: *mut *mut i32, arg4: *mut uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_uint32_array(arg1: *mut nvlist_t,
                                      arg2: *const ::libc::c_char,
                                      arg3: *mut *mut u32, arg4: *mut uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_int64_array(arg1: *mut nvlist_t,
                                     arg2: *const ::libc::c_char,
                                     arg3: *mut *mut i64, arg4: *mut uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_uint64_array(arg1: *mut nvlist_t,
                                      arg2: *const ::libc::c_char,
                                      arg3: *mut *mut u64, arg4: *mut uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_string_array(arg1: *mut nvlist_t,
                                      arg2: *const ::libc::c_char,
                                      arg3: *mut *mut *mut ::libc::c_char,
                                      arg4: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_nvlist_array(arg1: *mut nvlist_t,
                                      arg2: *const ::libc::c_char,
                                      arg3: *mut *mut *mut nvlist_t,
                                      arg4: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_hrtime(arg1: *mut nvlist_t,
                                arg2: *const ::libc::c_char,
                                arg3: *mut hrtime_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_pairs(arg1: *mut nvlist_t, arg2: ::libc::c_int, ...)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_double(arg1: *mut nvlist_t,
                                arg2: *const ::libc::c_char, arg3: *mut f64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_nvpair(arg1: *mut nvlist_t,
                                arg2: *const ::libc::c_char,
                                arg3: *mut *mut nvpair_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_lookup_nvpair_embedded_index(arg1: *mut nvlist_t,
                                               arg2: *const ::libc::c_char,
                                               arg3: *mut *mut nvpair_t,
                                               arg4: *mut ::libc::c_int,
                                               arg5: *mut *mut ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_exists(arg1: *mut nvlist_t, arg2: *const ::libc::c_char)
     -> boolean_t;
}
extern "C" {
    pub fn nvlist_empty(arg1: *mut nvlist_t) -> boolean_t;
}
extern "C" {
    pub fn nvlist_next_nvpair(arg1: *mut nvlist_t, arg2: *mut nvpair_t)
     -> *mut nvpair_t;
}
extern "C" {
    pub fn nvlist_prev_nvpair(arg1: *mut nvlist_t, arg2: *mut nvpair_t)
     -> *mut nvpair_t;
}
extern "C" {
    pub fn nvpair_name(arg1: *mut nvpair_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn nvpair_type(arg1: *mut nvpair_t) -> data_type_t;
}
extern "C" {
    pub fn nvpair_type_is_array(arg1: *mut nvpair_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_boolean_value(arg1: *mut nvpair_t,
                                      arg2: *mut boolean_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_byte(arg1: *mut nvpair_t, arg2: *mut uchar_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_int8(arg1: *mut nvpair_t, arg2: *mut i8)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_uint8(arg1: *mut nvpair_t, arg2: *mut u8)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_int16(arg1: *mut nvpair_t, arg2: *mut i16)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_uint16(arg1: *mut nvpair_t, arg2: *mut u16)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_int32(arg1: *mut nvpair_t, arg2: *mut i32)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_uint32(arg1: *mut nvpair_t, arg2: *mut u32)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_int64(arg1: *mut nvpair_t, arg2: *mut i64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_uint64(arg1: *mut nvpair_t, arg2: *mut u64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_string(arg1: *mut nvpair_t,
                               arg2: *mut *mut ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_nvlist(arg1: *mut nvpair_t, arg2: *mut *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_boolean_array(arg1: *mut nvpair_t,
                                      arg2: *mut *mut boolean_t,
                                      arg3: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_byte_array(arg1: *mut nvpair_t,
                                   arg2: *mut *mut uchar_t, arg3: *mut uint_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_int8_array(arg1: *mut nvpair_t, arg2: *mut *mut i8,
                                   arg3: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_uint8_array(arg1: *mut nvpair_t, arg2: *mut *mut u8,
                                    arg3: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_int16_array(arg1: *mut nvpair_t, arg2: *mut *mut i16,
                                    arg3: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_uint16_array(arg1: *mut nvpair_t, arg2: *mut *mut u16,
                                     arg3: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_int32_array(arg1: *mut nvpair_t, arg2: *mut *mut i32,
                                    arg3: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_uint32_array(arg1: *mut nvpair_t, arg2: *mut *mut u32,
                                     arg3: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_int64_array(arg1: *mut nvpair_t, arg2: *mut *mut i64,
                                    arg3: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_uint64_array(arg1: *mut nvpair_t, arg2: *mut *mut u64,
                                     arg3: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_string_array(arg1: *mut nvpair_t,
                                     arg2: *mut *mut *mut ::libc::c_char,
                                     arg3: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_nvlist_array(arg1: *mut nvpair_t,
                                     arg2: *mut *mut *mut nvlist_t,
                                     arg3: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_hrtime(arg1: *mut nvpair_t, arg2: *mut hrtime_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_double(arg1: *mut nvpair_t, arg2: *mut f64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn fnvlist_alloc() -> *mut nvlist_t;
}
extern "C" {
    pub fn fnvlist_free(arg1: *mut nvlist_t);
}
extern "C" {
    pub fn fnvlist_size(arg1: *mut nvlist_t) -> usize;
}
extern "C" {
    pub fn fnvlist_pack(arg1: *mut nvlist_t, arg2: *mut usize)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn fnvlist_pack_free(arg1: *mut ::libc::c_char, arg2: usize);
}
extern "C" {
    pub fn fnvlist_unpack(arg1: *mut ::libc::c_char, arg2: usize)
     -> *mut nvlist_t;
}
extern "C" {
    pub fn fnvlist_dup(arg1: *mut nvlist_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn fnvlist_merge(arg1: *mut nvlist_t, arg2: *mut nvlist_t);
}
extern "C" {
    pub fn fnvlist_num_pairs(arg1: *mut nvlist_t) -> usize;
}
extern "C" {
    pub fn fnvlist_add_boolean(arg1: *mut nvlist_t,
                               arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn fnvlist_add_boolean_value(arg1: *mut nvlist_t,
                                     arg2: *const ::libc::c_char,
                                     arg3: boolean_t);
}
extern "C" {
    pub fn fnvlist_add_byte(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                            arg3: uchar_t);
}
extern "C" {
    pub fn fnvlist_add_int8(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                            arg3: i8);
}
extern "C" {
    pub fn fnvlist_add_uint8(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                             arg3: u8);
}
extern "C" {
    pub fn fnvlist_add_int16(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                             arg3: i16);
}
extern "C" {
    pub fn fnvlist_add_uint16(arg1: *mut nvlist_t,
                              arg2: *const ::libc::c_char, arg3: u16);
}
extern "C" {
    pub fn fnvlist_add_int32(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                             arg3: i32);
}
extern "C" {
    pub fn fnvlist_add_uint32(arg1: *mut nvlist_t,
                              arg2: *const ::libc::c_char, arg3: u32);
}
extern "C" {
    pub fn fnvlist_add_int64(arg1: *mut nvlist_t, arg2: *const ::libc::c_char,
                             arg3: i64);
}
extern "C" {
    pub fn fnvlist_add_uint64(arg1: *mut nvlist_t,
                              arg2: *const ::libc::c_char, arg3: u64);
}
extern "C" {
    pub fn fnvlist_add_string(arg1: *mut nvlist_t,
                              arg2: *const ::libc::c_char,
                              arg3: *const ::libc::c_char);
}
extern "C" {
    pub fn fnvlist_add_nvlist(arg1: *mut nvlist_t,
                              arg2: *const ::libc::c_char,
                              arg3: *mut nvlist_t);
}
extern "C" {
    pub fn fnvlist_add_nvpair(arg1: *mut nvlist_t, arg2: *mut nvpair_t);
}
extern "C" {
    pub fn fnvlist_add_boolean_array(arg1: *mut nvlist_t,
                                     arg2: *const ::libc::c_char,
                                     arg3: *mut boolean_t, arg4: uint_t);
}
extern "C" {
    pub fn fnvlist_add_byte_array(arg1: *mut nvlist_t,
                                  arg2: *const ::libc::c_char,
                                  arg3: *mut uchar_t, arg4: uint_t);
}
extern "C" {
    pub fn fnvlist_add_int8_array(arg1: *mut nvlist_t,
                                  arg2: *const ::libc::c_char, arg3: *mut i8,
                                  arg4: uint_t);
}
extern "C" {
    pub fn fnvlist_add_uint8_array(arg1: *mut nvlist_t,
                                   arg2: *const ::libc::c_char, arg3: *mut u8,
                                   arg4: uint_t);
}
extern "C" {
    pub fn fnvlist_add_int16_array(arg1: *mut nvlist_t,
                                   arg2: *const ::libc::c_char,
                                   arg3: *mut i16, arg4: uint_t);
}
extern "C" {
    pub fn fnvlist_add_uint16_array(arg1: *mut nvlist_t,
                                    arg2: *const ::libc::c_char,
                                    arg3: *mut u16, arg4: uint_t);
}
extern "C" {
    pub fn fnvlist_add_int32_array(arg1: *mut nvlist_t,
                                   arg2: *const ::libc::c_char,
                                   arg3: *mut i32, arg4: uint_t);
}
extern "C" {
    pub fn fnvlist_add_uint32_array(arg1: *mut nvlist_t,
                                    arg2: *const ::libc::c_char,
                                    arg3: *mut u32, arg4: uint_t);
}
extern "C" {
    pub fn fnvlist_add_int64_array(arg1: *mut nvlist_t,
                                   arg2: *const ::libc::c_char,
                                   arg3: *mut i64, arg4: uint_t);
}
extern "C" {
    pub fn fnvlist_add_uint64_array(arg1: *mut nvlist_t,
                                    arg2: *const ::libc::c_char,
                                    arg3: *mut u64, arg4: uint_t);
}
extern "C" {
    pub fn fnvlist_add_string_array(arg1: *mut nvlist_t,
                                    arg2: *const ::libc::c_char,
                                    arg3: *const *const ::libc::c_char,
                                    arg4: uint_t);
}
extern "C" {
    pub fn fnvlist_add_nvlist_array(arg1: *mut nvlist_t,
                                    arg2: *const ::libc::c_char,
                                    arg3: *mut *mut nvlist_t, arg4: uint_t);
}
extern "C" {
    pub fn fnvlist_remove(arg1: *mut nvlist_t, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn fnvlist_remove_nvpair(arg1: *mut nvlist_t, arg2: *mut nvpair_t);
}
extern "C" {
    pub fn fnvlist_lookup_nvpair(nvl: *mut nvlist_t,
                                 name: *const ::libc::c_char)
     -> *mut nvpair_t;
}
extern "C" {
    pub fn fnvlist_lookup_boolean(nvl: *mut nvlist_t,
                                  name: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn fnvlist_lookup_boolean_value(nvl: *mut nvlist_t,
                                        name: *const ::libc::c_char)
     -> boolean_t;
}
extern "C" {
    pub fn fnvlist_lookup_byte(nvl: *mut nvlist_t,
                               name: *const ::libc::c_char) -> uchar_t;
}
extern "C" {
    pub fn fnvlist_lookup_int8(nvl: *mut nvlist_t,
                               name: *const ::libc::c_char) -> i8;
}
extern "C" {
    pub fn fnvlist_lookup_int16(nvl: *mut nvlist_t,
                                name: *const ::libc::c_char) -> i16;
}
extern "C" {
    pub fn fnvlist_lookup_int32(nvl: *mut nvlist_t,
                                name: *const ::libc::c_char) -> i32;
}
extern "C" {
    pub fn fnvlist_lookup_int64(nvl: *mut nvlist_t,
                                name: *const ::libc::c_char) -> i64;
}
extern "C" {
    pub fn fnvlist_lookup_uint8(nvl: *mut nvlist_t,
                                name: *const ::libc::c_char) -> u8;
}
extern "C" {
    pub fn fnvlist_lookup_uint16(nvl: *mut nvlist_t,
                                 name: *const ::libc::c_char) -> u16;
}
extern "C" {
    pub fn fnvlist_lookup_uint32(nvl: *mut nvlist_t,
                                 name: *const ::libc::c_char) -> u32;
}
extern "C" {
    pub fn fnvlist_lookup_uint64(nvl: *mut nvlist_t,
                                 name: *const ::libc::c_char) -> u64;
}
extern "C" {
    pub fn fnvlist_lookup_string(nvl: *mut nvlist_t,
                                 name: *const ::libc::c_char)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn fnvlist_lookup_nvlist(nvl: *mut nvlist_t,
                                 name: *const ::libc::c_char)
     -> *mut nvlist_t;
}
extern "C" {
    pub fn fnvpair_value_boolean_value(nvp: *mut nvpair_t) -> boolean_t;
}
extern "C" {
    pub fn fnvpair_value_byte(nvp: *mut nvpair_t) -> uchar_t;
}
extern "C" {
    pub fn fnvpair_value_int8(nvp: *mut nvpair_t) -> i8;
}
extern "C" {
    pub fn fnvpair_value_int16(nvp: *mut nvpair_t) -> i16;
}
extern "C" {
    pub fn fnvpair_value_int32(nvp: *mut nvpair_t) -> i32;
}
extern "C" {
    pub fn fnvpair_value_int64(nvp: *mut nvpair_t) -> i64;
}
extern "C" {
    pub fn fnvpair_value_uint8(nvp: *mut nvpair_t) -> u8;
}
extern "C" {
    pub fn fnvpair_value_uint16(nvp: *mut nvpair_t) -> u16;
}
extern "C" {
    pub fn fnvpair_value_uint32(nvp: *mut nvpair_t) -> u32;
}
extern "C" {
    pub fn fnvpair_value_uint64(nvp: *mut nvpair_t) -> u64;
}
extern "C" {
    pub fn fnvpair_value_string(nvp: *mut nvpair_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn fnvpair_value_nvlist(nvp: *mut nvpair_t) -> *mut nvlist_t;
}
pub type s_reg_t = ::libc::c_long;
pub type active_reg_t = ::libc::c_ulong;
pub type reg_syntax_t = ::libc::c_ulong;
extern "C" {
    #[link_name = "re_syntax_options"]
    pub static mut re_syntax_options: reg_syntax_t;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum reg_errcode_t {
    REG_ENOSYS = -1,
    REG_NOERROR = 0,
    REG_NOMATCH = 1,
    REG_BADPAT = 2,
    REG_ECOLLATE = 3,
    REG_ECTYPE = 4,
    REG_EESCAPE = 5,
    REG_ESUBREG = 6,
    REG_EBRACK = 7,
    REG_EPAREN = 8,
    REG_EBRACE = 9,
    REG_BADBR = 10,
    REG_ERANGE = 11,
    REG_ESPACE = 12,
    REG_BADRPT = 13,
    REG_EEND = 14,
    REG_ESIZE = 15,
    REG_ERPAREN = 16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct re_pattern_buffer {
    pub __buffer: *mut ::libc::c_uchar,
    pub __allocated: ::libc::c_ulong,
    pub __used: ::libc::c_ulong,
    pub __syntax: reg_syntax_t,
    pub __fastmap: *mut ::libc::c_char,
    pub __translate: *mut ::libc::c_uchar,
    pub re_nsub: usize,
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_re_pattern_buffer() {
    assert_eq!(::core::mem::size_of::<re_pattern_buffer>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( re_pattern_buffer ) ));
    assert_eq! (::core::mem::align_of::<re_pattern_buffer>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( re_pattern_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const re_pattern_buffer ) ) . __buffer as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( re_pattern_buffer ) ,
                "::" , stringify ! ( __buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const re_pattern_buffer ) ) . __allocated as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( re_pattern_buffer ) ,
                "::" , stringify ! ( __allocated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const re_pattern_buffer ) ) . __used as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( re_pattern_buffer ) ,
                "::" , stringify ! ( __used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const re_pattern_buffer ) ) . __syntax as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( re_pattern_buffer ) ,
                "::" , stringify ! ( __syntax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const re_pattern_buffer ) ) . __fastmap as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( re_pattern_buffer ) ,
                "::" , stringify ! ( __fastmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const re_pattern_buffer ) ) . __translate as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( re_pattern_buffer ) ,
                "::" , stringify ! ( __translate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const re_pattern_buffer ) ) . re_nsub as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( re_pattern_buffer ) ,
                "::" , stringify ! ( re_nsub ) ));
}
impl Clone for re_pattern_buffer {
    fn clone(&self) -> Self { *self }
}
impl re_pattern_buffer {
    #[inline]
    pub fn __can_be_null(&self) -> ::libc::c_uint {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___can_be_null(&mut self, val: ::libc::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn __regs_allocated(&self) -> ::libc::c_uint {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 6u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___regs_allocated(&mut self, val: ::libc::c_uint) {
        let mask = 6u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn __fastmap_accurate(&self) -> ::libc::c_uint {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___fastmap_accurate(&mut self, val: ::libc::c_uint) {
        let mask = 8u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn __no_sub(&self) -> ::libc::c_uint {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___no_sub(&mut self, val: ::libc::c_uint) {
        let mask = 16u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn __not_bol(&self) -> ::libc::c_uint {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 32u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___not_bol(&mut self, val: ::libc::c_uint) {
        let mask = 32u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn __not_eol(&self) -> ::libc::c_uint {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 64u64 as u8;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___not_eol(&mut self, val: ::libc::c_uint) {
        let mask = 64u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn __newline_anchor(&self) -> ::libc::c_uint {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 128u64 as u8;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___newline_anchor(&mut self, val: ::libc::c_uint) {
        let mask = 128u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__can_be_null: ::libc::c_uint,
                          __regs_allocated: ::libc::c_uint,
                          __fastmap_accurate: ::libc::c_uint,
                          __no_sub: ::libc::c_uint, __not_bol: ::libc::c_uint,
                          __not_eol: ::libc::c_uint,
                          __newline_anchor: ::libc::c_uint) -> u8 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({ 0 } |
                                           ((__can_be_null as u32 as u8) <<
                                                0usize) & (1u64 as u8))
                                  } |
                                      ((__regs_allocated as u32 as u8) <<
                                           1usize) & (6u64 as u8))
                             } |
                                 ((__fastmap_accurate as u32 as u8) << 3usize)
                                     & (8u64 as u8))
                        } |
                            ((__no_sub as u32 as u8) << 4usize) &
                                (16u64 as u8))
                   } | ((__not_bol as u32 as u8) << 5usize) & (32u64 as u8))
              } | ((__not_eol as u32 as u8) << 6usize) & (64u64 as u8))
         } | ((__newline_anchor as u32 as u8) << 7usize) & (128u64 as u8))
    }
}
pub type regex_t = re_pattern_buffer;
pub type regoff_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct regmatch_t {
    pub rm_so: regoff_t,
    pub rm_eo: regoff_t,
}
#[test]
fn bindgen_test_layout_regmatch_t() {
    assert_eq!(::core::mem::size_of::<regmatch_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( regmatch_t ) ));
    assert_eq! (::core::mem::align_of::<regmatch_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( regmatch_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const regmatch_t ) ) . rm_so as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( regmatch_t ) , "::" ,
                stringify ! ( rm_so ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const regmatch_t ) ) . rm_eo as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( regmatch_t ) , "::" ,
                stringify ! ( rm_eo ) ));
}
impl Clone for regmatch_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn regcomp(__preg: *mut regex_t, __pattern: *const ::libc::c_char,
                   __cflags: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn regexec(__preg: *const regex_t, __string: *const ::libc::c_char,
                   __nmatch: usize, __pmatch: *mut regmatch_t,
                   __eflags: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn regerror(__errcode: ::libc::c_int, __preg: *const regex_t,
                    __errbuf: *mut ::libc::c_char, __errbuf_size: usize)
     -> usize;
}
extern "C" {
    pub fn regfree(__preg: *mut regex_t);
}
extern "C" {
    pub fn nvpair_value_match(arg1: *mut nvpair_t, arg2: ::libc::c_int,
                              arg3: *mut ::libc::c_char,
                              arg4: *mut *mut ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvpair_value_match_regex(arg1: *mut nvpair_t, arg2: ::libc::c_int,
                                    arg3: *mut ::libc::c_char,
                                    arg4: *mut regex_t,
                                    arg5: *mut *mut ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn nvlist_print(arg1: *mut FILE, arg2: *mut nvlist_t);
}
extern "C" {
    pub fn dump_nvlist(arg1: *mut nvlist_t, arg2: ::libc::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvlist_prtctl {
    _unused: [u8; 0],
}
pub type nvlist_prtctl_t = *mut nvlist_prtctl;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvlist_indent_mode {
    NVLIST_INDENT_ABS = 0,
    NVLIST_INDENT_TABBED = 1,
}
extern "C" {
    pub fn nvlist_prtctl_alloc() -> nvlist_prtctl_t;
}
extern "C" {
    pub fn nvlist_prtctl_free(arg1: nvlist_prtctl_t);
}
extern "C" {
    pub fn nvlist_prt(arg1: *mut nvlist_t, arg2: nvlist_prtctl_t);
}
extern "C" {
    pub fn nvlist_prtctl_setdest(arg1: nvlist_prtctl_t, arg2: *mut FILE);
}
extern "C" {
    pub fn nvlist_prtctl_getdest(arg1: nvlist_prtctl_t) -> *mut FILE;
}
extern "C" {
    pub fn nvlist_prtctl_setindent(arg1: nvlist_prtctl_t,
                                   arg2: nvlist_indent_mode,
                                   arg3: ::libc::c_int, arg4: ::libc::c_int);
}
extern "C" {
    pub fn nvlist_prtctl_doindent(arg1: nvlist_prtctl_t, arg2: ::libc::c_int);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvlist_prtctl_fmt {
    NVLIST_FMT_MEMBER_NAME = 0,
    NVLIST_FMT_MEMBER_POSTAMBLE = 1,
    NVLIST_FMT_BTWN_ARRAY = 2,
}
extern "C" {
    pub fn nvlist_prtctl_setfmt(arg1: nvlist_prtctl_t,
                                arg2: nvlist_prtctl_fmt,
                                arg3: *const ::libc::c_char);
}
extern "C" {
    pub fn nvlist_prtctl_dofmt(arg1: nvlist_prtctl_t,
                               arg2: nvlist_prtctl_fmt, ...);
}
extern "C" {
    pub fn nvlist_prtctlop_boolean(arg1: nvlist_prtctl_t,
                                   arg2:
                                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                       nvlist_prtctl_t,
                                                                                   arg2:
                                                                                       *mut ::libc::c_void,
                                                                                   arg3:
                                                                                       *mut nvlist_t,
                                                                                   arg4:
                                                                                       *const ::libc::c_char,
                                                                                   arg5:
                                                                                       ::libc::c_int)
                                                                  ->
                                                                      ::libc::c_int>,
                                   arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_boolean_value(arg1: nvlist_prtctl_t,
                                         arg2:
                                             ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                             nvlist_prtctl_t,
                                                                                         arg2:
                                                                                             *mut ::libc::c_void,
                                                                                         arg3:
                                                                                             *mut nvlist_t,
                                                                                         arg4:
                                                                                             *const ::libc::c_char,
                                                                                         arg5:
                                                                                             boolean_t)
                                                                        ->
                                                                            ::libc::c_int>,
                                         arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_byte(arg1: nvlist_prtctl_t,
                                arg2:
                                    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                    nvlist_prtctl_t,
                                                                                arg2:
                                                                                    *mut ::libc::c_void,
                                                                                arg3:
                                                                                    *mut nvlist_t,
                                                                                arg4:
                                                                                    *const ::libc::c_char,
                                                                                arg5:
                                                                                    uchar_t)
                                                               ->
                                                                   ::libc::c_int>,
                                arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_int8(arg1: nvlist_prtctl_t,
                                arg2:
                                    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                    nvlist_prtctl_t,
                                                                                arg2:
                                                                                    *mut ::libc::c_void,
                                                                                arg3:
                                                                                    *mut nvlist_t,
                                                                                arg4:
                                                                                    *const ::libc::c_char,
                                                                                arg5:
                                                                                    i8)
                                                               ->
                                                                   ::libc::c_int>,
                                arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_uint8(arg1: nvlist_prtctl_t,
                                 arg2:
                                     ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                     nvlist_prtctl_t,
                                                                                 arg2:
                                                                                     *mut ::libc::c_void,
                                                                                 arg3:
                                                                                     *mut nvlist_t,
                                                                                 arg4:
                                                                                     *const ::libc::c_char,
                                                                                 arg5:
                                                                                     u8)
                                                                ->
                                                                    ::libc::c_int>,
                                 arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_int16(arg1: nvlist_prtctl_t,
                                 arg2:
                                     ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                     nvlist_prtctl_t,
                                                                                 arg2:
                                                                                     *mut ::libc::c_void,
                                                                                 arg3:
                                                                                     *mut nvlist_t,
                                                                                 arg4:
                                                                                     *const ::libc::c_char,
                                                                                 arg5:
                                                                                     i16)
                                                                ->
                                                                    ::libc::c_int>,
                                 arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_uint16(arg1: nvlist_prtctl_t,
                                  arg2:
                                      ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                      nvlist_prtctl_t,
                                                                                  arg2:
                                                                                      *mut ::libc::c_void,
                                                                                  arg3:
                                                                                      *mut nvlist_t,
                                                                                  arg4:
                                                                                      *const ::libc::c_char,
                                                                                  arg5:
                                                                                      u16)
                                                                 ->
                                                                     ::libc::c_int>,
                                  arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_int32(arg1: nvlist_prtctl_t,
                                 arg2:
                                     ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                     nvlist_prtctl_t,
                                                                                 arg2:
                                                                                     *mut ::libc::c_void,
                                                                                 arg3:
                                                                                     *mut nvlist_t,
                                                                                 arg4:
                                                                                     *const ::libc::c_char,
                                                                                 arg5:
                                                                                     i32)
                                                                ->
                                                                    ::libc::c_int>,
                                 arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_uint32(arg1: nvlist_prtctl_t,
                                  arg2:
                                      ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                      nvlist_prtctl_t,
                                                                                  arg2:
                                                                                      *mut ::libc::c_void,
                                                                                  arg3:
                                                                                      *mut nvlist_t,
                                                                                  arg4:
                                                                                      *const ::libc::c_char,
                                                                                  arg5:
                                                                                      u32)
                                                                 ->
                                                                     ::libc::c_int>,
                                  arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_int64(arg1: nvlist_prtctl_t,
                                 arg2:
                                     ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                     nvlist_prtctl_t,
                                                                                 arg2:
                                                                                     *mut ::libc::c_void,
                                                                                 arg3:
                                                                                     *mut nvlist_t,
                                                                                 arg4:
                                                                                     *const ::libc::c_char,
                                                                                 arg5:
                                                                                     i64)
                                                                ->
                                                                    ::libc::c_int>,
                                 arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_uint64(arg1: nvlist_prtctl_t,
                                  arg2:
                                      ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                      nvlist_prtctl_t,
                                                                                  arg2:
                                                                                      *mut ::libc::c_void,
                                                                                  arg3:
                                                                                      *mut nvlist_t,
                                                                                  arg4:
                                                                                      *const ::libc::c_char,
                                                                                  arg5:
                                                                                      u64)
                                                                 ->
                                                                     ::libc::c_int>,
                                  arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_double(arg1: nvlist_prtctl_t,
                                  arg2:
                                      ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                      nvlist_prtctl_t,
                                                                                  arg2:
                                                                                      *mut ::libc::c_void,
                                                                                  arg3:
                                                                                      *mut nvlist_t,
                                                                                  arg4:
                                                                                      *const ::libc::c_char,
                                                                                  arg5:
                                                                                      f64)
                                                                 ->
                                                                     ::libc::c_int>,
                                  arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_string(arg1: nvlist_prtctl_t,
                                  arg2:
                                      ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                      nvlist_prtctl_t,
                                                                                  arg2:
                                                                                      *mut ::libc::c_void,
                                                                                  arg3:
                                                                                      *mut nvlist_t,
                                                                                  arg4:
                                                                                      *const ::libc::c_char,
                                                                                  arg5:
                                                                                      *mut ::libc::c_char)
                                                                 ->
                                                                     ::libc::c_int>,
                                  arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_hrtime(arg1: nvlist_prtctl_t,
                                  arg2:
                                      ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                      nvlist_prtctl_t,
                                                                                  arg2:
                                                                                      *mut ::libc::c_void,
                                                                                  arg3:
                                                                                      *mut nvlist_t,
                                                                                  arg4:
                                                                                      *const ::libc::c_char,
                                                                                  arg5:
                                                                                      hrtime_t)
                                                                 ->
                                                                     ::libc::c_int>,
                                  arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_nvlist(arg1: nvlist_prtctl_t,
                                  arg2:
                                      ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                      nvlist_prtctl_t,
                                                                                  arg2:
                                                                                      *mut ::libc::c_void,
                                                                                  arg3:
                                                                                      *mut nvlist_t,
                                                                                  arg4:
                                                                                      *const ::libc::c_char,
                                                                                  arg5:
                                                                                      *mut nvlist_t)
                                                                 ->
                                                                     ::libc::c_int>,
                                  arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_boolean_array(arg1: nvlist_prtctl_t,
                                         arg2:
                                             ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                             nvlist_prtctl_t,
                                                                                         arg2:
                                                                                             *mut ::libc::c_void,
                                                                                         arg3:
                                                                                             *mut nvlist_t,
                                                                                         arg4:
                                                                                             *const ::libc::c_char,
                                                                                         arg5:
                                                                                             *mut boolean_t,
                                                                                         arg6:
                                                                                             uint_t)
                                                                        ->
                                                                            ::libc::c_int>,
                                         arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_byte_array(arg1: nvlist_prtctl_t,
                                      arg2:
                                          ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                          nvlist_prtctl_t,
                                                                                      arg2:
                                                                                          *mut ::libc::c_void,
                                                                                      arg3:
                                                                                          *mut nvlist_t,
                                                                                      arg4:
                                                                                          *const ::libc::c_char,
                                                                                      arg5:
                                                                                          *mut uchar_t,
                                                                                      arg6:
                                                                                          uint_t)
                                                                     ->
                                                                         ::libc::c_int>,
                                      arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_int8_array(arg1: nvlist_prtctl_t,
                                      arg2:
                                          ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                          nvlist_prtctl_t,
                                                                                      arg2:
                                                                                          *mut ::libc::c_void,
                                                                                      arg3:
                                                                                          *mut nvlist_t,
                                                                                      arg4:
                                                                                          *const ::libc::c_char,
                                                                                      arg5:
                                                                                          *mut i8,
                                                                                      arg6:
                                                                                          uint_t)
                                                                     ->
                                                                         ::libc::c_int>,
                                      arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_uint8_array(arg1: nvlist_prtctl_t,
                                       arg2:
                                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                           nvlist_prtctl_t,
                                                                                       arg2:
                                                                                           *mut ::libc::c_void,
                                                                                       arg3:
                                                                                           *mut nvlist_t,
                                                                                       arg4:
                                                                                           *const ::libc::c_char,
                                                                                       arg5:
                                                                                           *mut u8,
                                                                                       arg6:
                                                                                           uint_t)
                                                                      ->
                                                                          ::libc::c_int>,
                                       arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_int16_array(arg1: nvlist_prtctl_t,
                                       arg2:
                                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                           nvlist_prtctl_t,
                                                                                       arg2:
                                                                                           *mut ::libc::c_void,
                                                                                       arg3:
                                                                                           *mut nvlist_t,
                                                                                       arg4:
                                                                                           *const ::libc::c_char,
                                                                                       arg5:
                                                                                           *mut i16,
                                                                                       arg6:
                                                                                           uint_t)
                                                                      ->
                                                                          ::libc::c_int>,
                                       arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_uint16_array(arg1: nvlist_prtctl_t,
                                        arg2:
                                            ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                            nvlist_prtctl_t,
                                                                                        arg2:
                                                                                            *mut ::libc::c_void,
                                                                                        arg3:
                                                                                            *mut nvlist_t,
                                                                                        arg4:
                                                                                            *const ::libc::c_char,
                                                                                        arg5:
                                                                                            *mut u16,
                                                                                        arg6:
                                                                                            uint_t)
                                                                       ->
                                                                           ::libc::c_int>,
                                        arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_int32_array(arg1: nvlist_prtctl_t,
                                       arg2:
                                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                           nvlist_prtctl_t,
                                                                                       arg2:
                                                                                           *mut ::libc::c_void,
                                                                                       arg3:
                                                                                           *mut nvlist_t,
                                                                                       arg4:
                                                                                           *const ::libc::c_char,
                                                                                       arg5:
                                                                                           *mut i32,
                                                                                       arg6:
                                                                                           uint_t)
                                                                      ->
                                                                          ::libc::c_int>,
                                       arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_uint32_array(arg1: nvlist_prtctl_t,
                                        arg2:
                                            ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                            nvlist_prtctl_t,
                                                                                        arg2:
                                                                                            *mut ::libc::c_void,
                                                                                        arg3:
                                                                                            *mut nvlist_t,
                                                                                        arg4:
                                                                                            *const ::libc::c_char,
                                                                                        arg5:
                                                                                            *mut u32,
                                                                                        arg6:
                                                                                            uint_t)
                                                                       ->
                                                                           ::libc::c_int>,
                                        arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_int64_array(arg1: nvlist_prtctl_t,
                                       arg2:
                                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                           nvlist_prtctl_t,
                                                                                       arg2:
                                                                                           *mut ::libc::c_void,
                                                                                       arg3:
                                                                                           *mut nvlist_t,
                                                                                       arg4:
                                                                                           *const ::libc::c_char,
                                                                                       arg5:
                                                                                           *mut i64,
                                                                                       arg6:
                                                                                           uint_t)
                                                                      ->
                                                                          ::libc::c_int>,
                                       arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_uint64_array(arg1: nvlist_prtctl_t,
                                        arg2:
                                            ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                            nvlist_prtctl_t,
                                                                                        arg2:
                                                                                            *mut ::libc::c_void,
                                                                                        arg3:
                                                                                            *mut nvlist_t,
                                                                                        arg4:
                                                                                            *const ::libc::c_char,
                                                                                        arg5:
                                                                                            *mut u64,
                                                                                        arg6:
                                                                                            uint_t)
                                                                       ->
                                                                           ::libc::c_int>,
                                        arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_string_array(arg1: nvlist_prtctl_t,
                                        arg2:
                                            ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                            nvlist_prtctl_t,
                                                                                        arg2:
                                                                                            *mut ::libc::c_void,
                                                                                        arg3:
                                                                                            *mut nvlist_t,
                                                                                        arg4:
                                                                                            *const ::libc::c_char,
                                                                                        arg5:
                                                                                            *mut *mut ::libc::c_char,
                                                                                        arg6:
                                                                                            uint_t)
                                                                       ->
                                                                           ::libc::c_int>,
                                        arg3: *mut ::libc::c_void);
}
extern "C" {
    pub fn nvlist_prtctlop_nvlist_array(arg1: nvlist_prtctl_t,
                                        arg2:
                                            ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                            nvlist_prtctl_t,
                                                                                        arg2:
                                                                                            *mut ::libc::c_void,
                                                                                        arg3:
                                                                                            *mut nvlist_t,
                                                                                        arg4:
                                                                                            *const ::libc::c_char,
                                                                                        arg5:
                                                                                            *mut *mut nvlist_t,
                                                                                        arg6:
                                                                                            uint_t)
                                                                       ->
                                                                           ::libc::c_int>,
                                        arg3: *mut ::libc::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mntent {
    pub mnt_fsname: *mut ::libc::c_char,
    pub mnt_dir: *mut ::libc::c_char,
    pub mnt_type: *mut ::libc::c_char,
    pub mnt_opts: *mut ::libc::c_char,
    pub mnt_freq: ::libc::c_int,
    pub mnt_passno: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_mntent() {
    assert_eq!(::core::mem::size_of::<mntent>() , 40usize , concat ! (
               "Size of: " , stringify ! ( mntent ) ));
    assert_eq! (::core::mem::align_of::<mntent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mntent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mntent ) ) . mnt_fsname as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mntent ) , "::" ,
                stringify ! ( mnt_fsname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mntent ) ) . mnt_dir as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mntent ) , "::" ,
                stringify ! ( mnt_dir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mntent ) ) . mnt_type as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mntent ) , "::" ,
                stringify ! ( mnt_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mntent ) ) . mnt_opts as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mntent ) , "::" ,
                stringify ! ( mnt_opts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mntent ) ) . mnt_freq as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mntent ) , "::" ,
                stringify ! ( mnt_freq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mntent ) ) . mnt_passno as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( mntent ) , "::" ,
                stringify ! ( mnt_passno ) ));
}
impl Clone for mntent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn setmntent(__file: *const ::libc::c_char,
                     __mode: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn getmntent(__stream: *mut FILE) -> *mut mntent;
}
extern "C" {
    pub fn getmntent_r(__stream: *mut FILE, __result: *mut mntent,
                       __buffer: *mut ::libc::c_char,
                       __bufsize: ::libc::c_int) -> *mut mntent;
}
extern "C" {
    pub fn addmntent(__stream: *mut FILE, __mnt: *const mntent)
     -> ::libc::c_int;
}
extern "C" {
    pub fn endmntent(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn hasmntopt(__mnt: *const mntent, __opt: *const ::libc::c_char)
     -> *mut ::libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mnttab {
    pub mnt_special: *mut ::libc::c_char,
    pub mnt_mountp: *mut ::libc::c_char,
    pub mnt_fstype: *mut ::libc::c_char,
    pub mnt_mntopts: *mut ::libc::c_char,
}
#[test]
fn bindgen_test_layout_mnttab() {
    assert_eq!(::core::mem::size_of::<mnttab>() , 32usize , concat ! (
               "Size of: " , stringify ! ( mnttab ) ));
    assert_eq! (::core::mem::align_of::<mnttab>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mnttab ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mnttab ) ) . mnt_special as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mnttab ) , "::" ,
                stringify ! ( mnt_special ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mnttab ) ) . mnt_mountp as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mnttab ) , "::" ,
                stringify ! ( mnt_mountp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mnttab ) ) . mnt_fstype as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mnttab ) , "::" ,
                stringify ! ( mnt_fstype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mnttab ) ) . mnt_mntopts as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mnttab ) , "::" ,
                stringify ! ( mnt_mntopts ) ));
}
impl Clone for mnttab {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct extmnttab {
    pub mnt_special: *mut ::libc::c_char,
    pub mnt_mountp: *mut ::libc::c_char,
    pub mnt_fstype: *mut ::libc::c_char,
    pub mnt_mntopts: *mut ::libc::c_char,
    pub mnt_major: uint_t,
    pub mnt_minor: uint_t,
}
#[test]
fn bindgen_test_layout_extmnttab() {
    assert_eq!(::core::mem::size_of::<extmnttab>() , 40usize , concat ! (
               "Size of: " , stringify ! ( extmnttab ) ));
    assert_eq! (::core::mem::align_of::<extmnttab>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( extmnttab ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const extmnttab ) ) . mnt_special as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( extmnttab ) , "::" ,
                stringify ! ( mnt_special ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const extmnttab ) ) . mnt_mountp as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( extmnttab ) , "::" ,
                stringify ! ( mnt_mountp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const extmnttab ) ) . mnt_fstype as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( extmnttab ) , "::" ,
                stringify ! ( mnt_fstype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const extmnttab ) ) . mnt_mntopts as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( extmnttab ) , "::" ,
                stringify ! ( mnt_mntopts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const extmnttab ) ) . mnt_major as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( extmnttab ) , "::" ,
                stringify ! ( mnt_major ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const extmnttab ) ) . mnt_minor as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( extmnttab ) , "::" ,
                stringify ! ( mnt_minor ) ));
}
impl Clone for extmnttab {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn getmntany(fp: *mut FILE, mp: *mut mnttab, mpref: *mut mnttab)
     -> ::libc::c_int;
}
extern "C" {
    pub fn _sol_getmntent(fp: *mut FILE, mp: *mut mnttab) -> ::libc::c_int;
}
extern "C" {
    pub fn getextmntent(fp: *mut FILE, mp: *mut extmnttab, len: ::libc::c_int)
     -> ::libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zio_priority {
    ZIO_PRIORITY_SYNC_READ = 0,
    ZIO_PRIORITY_SYNC_WRITE = 1,
    ZIO_PRIORITY_ASYNC_READ = 2,
    ZIO_PRIORITY_ASYNC_WRITE = 3,
    ZIO_PRIORITY_SCRUB = 4,
    ZIO_PRIORITY_NUM_QUEUEABLE = 5,
    ZIO_PRIORITY_NOW = 6,
}
pub use self::zio_priority as zio_priority_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_type_t {
    ZFS_TYPE_FILESYSTEM = 1,
    ZFS_TYPE_SNAPSHOT = 2,
    ZFS_TYPE_VOLUME = 4,
    ZFS_TYPE_POOL = 8,
    ZFS_TYPE_BOOKMARK = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dmu_objset_type {
    DMU_OST_NONE = 0,
    DMU_OST_META = 1,
    DMU_OST_ZFS = 2,
    DMU_OST_ZVOL = 3,
    DMU_OST_OTHER = 4,
    DMU_OST_ANY = 5,
    DMU_OST_NUMTYPES = 6,
}
pub use self::dmu_objset_type as dmu_objset_type_t;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_prop_t {
    ZFS_PROP_BAD = -1,
    ZFS_PROP_TYPE = 0,
    ZFS_PROP_CREATION = 1,
    ZFS_PROP_USED = 2,
    ZFS_PROP_AVAILABLE = 3,
    ZFS_PROP_REFERENCED = 4,
    ZFS_PROP_COMPRESSRATIO = 5,
    ZFS_PROP_MOUNTED = 6,
    ZFS_PROP_ORIGIN = 7,
    ZFS_PROP_QUOTA = 8,
    ZFS_PROP_RESERVATION = 9,
    ZFS_PROP_VOLSIZE = 10,
    ZFS_PROP_VOLBLOCKSIZE = 11,
    ZFS_PROP_RECORDSIZE = 12,
    ZFS_PROP_MOUNTPOINT = 13,
    ZFS_PROP_SHARENFS = 14,
    ZFS_PROP_CHECKSUM = 15,
    ZFS_PROP_COMPRESSION = 16,
    ZFS_PROP_ATIME = 17,
    ZFS_PROP_DEVICES = 18,
    ZFS_PROP_EXEC = 19,
    ZFS_PROP_SETUID = 20,
    ZFS_PROP_READONLY = 21,
    ZFS_PROP_ZONED = 22,
    ZFS_PROP_SNAPDIR = 23,
    ZFS_PROP_PRIVATE = 24,
    ZFS_PROP_ACLINHERIT = 25,
    ZFS_PROP_CREATETXG = 26,
    ZFS_PROP_NAME = 27,
    ZFS_PROP_CANMOUNT = 28,
    ZFS_PROP_ISCSIOPTIONS = 29,
    ZFS_PROP_XATTR = 30,
    ZFS_PROP_NUMCLONES = 31,
    ZFS_PROP_COPIES = 32,
    ZFS_PROP_VERSION = 33,
    ZFS_PROP_UTF8ONLY = 34,
    ZFS_PROP_NORMALIZE = 35,
    ZFS_PROP_CASE = 36,
    ZFS_PROP_VSCAN = 37,
    ZFS_PROP_NBMAND = 38,
    ZFS_PROP_SHARESMB = 39,
    ZFS_PROP_REFQUOTA = 40,
    ZFS_PROP_REFRESERVATION = 41,
    ZFS_PROP_GUID = 42,
    ZFS_PROP_PRIMARYCACHE = 43,
    ZFS_PROP_SECONDARYCACHE = 44,
    ZFS_PROP_USEDSNAP = 45,
    ZFS_PROP_USEDDS = 46,
    ZFS_PROP_USEDCHILD = 47,
    ZFS_PROP_USEDREFRESERV = 48,
    ZFS_PROP_USERACCOUNTING = 49,
    ZFS_PROP_STMF_SHAREINFO = 50,
    ZFS_PROP_DEFER_DESTROY = 51,
    ZFS_PROP_USERREFS = 52,
    ZFS_PROP_LOGBIAS = 53,
    ZFS_PROP_UNIQUE = 54,
    ZFS_PROP_OBJSETID = 55,
    ZFS_PROP_DEDUP = 56,
    ZFS_PROP_MLSLABEL = 57,
    ZFS_PROP_SYNC = 58,
    ZFS_PROP_DNODESIZE = 59,
    ZFS_PROP_REFRATIO = 60,
    ZFS_PROP_WRITTEN = 61,
    ZFS_PROP_CLONES = 62,
    ZFS_PROP_LOGICALUSED = 63,
    ZFS_PROP_LOGICALREFERENCED = 64,
    ZFS_PROP_INCONSISTENT = 65,
    ZFS_PROP_VOLMODE = 66,
    ZFS_PROP_FILESYSTEM_LIMIT = 67,
    ZFS_PROP_SNAPSHOT_LIMIT = 68,
    ZFS_PROP_FILESYSTEM_COUNT = 69,
    ZFS_PROP_SNAPSHOT_COUNT = 70,
    ZFS_PROP_SNAPDEV = 71,
    ZFS_PROP_ACLTYPE = 72,
    ZFS_PROP_SELINUX_CONTEXT = 73,
    ZFS_PROP_SELINUX_FSCONTEXT = 74,
    ZFS_PROP_SELINUX_DEFCONTEXT = 75,
    ZFS_PROP_SELINUX_ROOTCONTEXT = 76,
    ZFS_PROP_RELATIME = 77,
    ZFS_PROP_REDUNDANT_METADATA = 78,
    ZFS_PROP_OVERLAY = 79,
    ZFS_PROP_PREV_SNAP = 80,
    ZFS_PROP_RECEIVE_RESUME_TOKEN = 81,
    ZFS_NUM_PROPS = 82,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_userquota_prop_t {
    ZFS_PROP_USERUSED = 0,
    ZFS_PROP_USERQUOTA = 1,
    ZFS_PROP_GROUPUSED = 2,
    ZFS_PROP_GROUPQUOTA = 3,
    ZFS_PROP_USEROBJUSED = 4,
    ZFS_PROP_USEROBJQUOTA = 5,
    ZFS_PROP_GROUPOBJUSED = 6,
    ZFS_PROP_GROUPOBJQUOTA = 7,
    ZFS_NUM_USERQUOTA_PROPS = 8,
}
extern "C" {
    #[link_name = "zfs_userquota_prop_prefixes"]
    pub static mut zfs_userquota_prop_prefixes:
               [*const ::libc::c_char; 8usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zpool_prop_t {
    ZPOOL_PROP_NAME = 0,
    ZPOOL_PROP_SIZE = 1,
    ZPOOL_PROP_CAPACITY = 2,
    ZPOOL_PROP_ALTROOT = 3,
    ZPOOL_PROP_HEALTH = 4,
    ZPOOL_PROP_GUID = 5,
    ZPOOL_PROP_VERSION = 6,
    ZPOOL_PROP_BOOTFS = 7,
    ZPOOL_PROP_DELEGATION = 8,
    ZPOOL_PROP_AUTOREPLACE = 9,
    ZPOOL_PROP_CACHEFILE = 10,
    ZPOOL_PROP_FAILUREMODE = 11,
    ZPOOL_PROP_LISTSNAPS = 12,
    ZPOOL_PROP_AUTOEXPAND = 13,
    ZPOOL_PROP_DEDUPDITTO = 14,
    ZPOOL_PROP_DEDUPRATIO = 15,
    ZPOOL_PROP_FREE = 16,
    ZPOOL_PROP_ALLOCATED = 17,
    ZPOOL_PROP_READONLY = 18,
    ZPOOL_PROP_ASHIFT = 19,
    ZPOOL_PROP_COMMENT = 20,
    ZPOOL_PROP_EXPANDSZ = 21,
    ZPOOL_PROP_FREEING = 22,
    ZPOOL_PROP_FRAGMENTATION = 23,
    ZPOOL_PROP_LEAKED = 24,
    ZPOOL_PROP_MAXBLOCKSIZE = 25,
    ZPOOL_PROP_TNAME = 26,
    ZPOOL_PROP_MAXDNODESIZE = 27,
    ZPOOL_PROP_MULTIHOST = 28,
    ZPOOL_NUM_PROPS = 29,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zprop_source_t {
    ZPROP_SRC_NONE = 1,
    ZPROP_SRC_DEFAULT = 2,
    ZPROP_SRC_TEMPORARY = 4,
    ZPROP_SRC_LOCAL = 8,
    ZPROP_SRC_INHERITED = 16,
    ZPROP_SRC_RECEIVED = 32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zprop_errflags_t { ZPROP_ERR_NOCLEAR = 1, ZPROP_ERR_NORESTORE = 2, }
pub type zprop_func =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int,
                                                arg2: *mut ::libc::c_void)
                               -> ::libc::c_int>;
extern "C" {
    pub fn zfs_prop_default_string(arg1: zfs_prop_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_prop_default_numeric(arg1: zfs_prop_t) -> u64;
}
extern "C" {
    pub fn zfs_prop_readonly(arg1: zfs_prop_t) -> boolean_t;
}
extern "C" {
    pub fn zfs_prop_inheritable(arg1: zfs_prop_t) -> boolean_t;
}
extern "C" {
    pub fn zfs_prop_setonce(arg1: zfs_prop_t) -> boolean_t;
}
extern "C" {
    pub fn zfs_prop_to_name(arg1: zfs_prop_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_name_to_prop(arg1: *const ::libc::c_char) -> zfs_prop_t;
}
extern "C" {
    pub fn zfs_prop_user(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_prop_userquota(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_prop_written(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_prop_index_to_string(arg1: zfs_prop_t, arg2: u64,
                                    arg3: *mut *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_string_to_index(arg1: zfs_prop_t,
                                    arg2: *const ::libc::c_char,
                                    arg3: *mut u64) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_random_value(arg1: zfs_prop_t, seed: u64) -> u64;
}
extern "C" {
    pub fn zfs_prop_valid_for_type(arg1: ::libc::c_int, arg2: zfs_type_t,
                                   arg3: boolean_t) -> boolean_t;
}
extern "C" {
    pub fn zpool_name_to_prop(arg1: *const ::libc::c_char) -> zpool_prop_t;
}
extern "C" {
    pub fn zpool_prop_to_name(arg1: zpool_prop_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zpool_prop_default_string(arg1: zpool_prop_t)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn zpool_prop_default_numeric(arg1: zpool_prop_t) -> u64;
}
extern "C" {
    pub fn zpool_prop_readonly(arg1: zpool_prop_t) -> boolean_t;
}
extern "C" {
    pub fn zpool_prop_feature(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zpool_prop_unsupported(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zpool_prop_index_to_string(arg1: zpool_prop_t, arg2: u64,
                                      arg3: *mut *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_prop_string_to_index(arg1: zpool_prop_t,
                                      arg2: *const ::libc::c_char,
                                      arg3: *mut u64) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_prop_random_value(arg1: zpool_prop_t, seed: u64) -> u64;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_deleg_who_type_t {
    ZFS_DELEG_WHO_UNKNOWN = 0,
    ZFS_DELEG_USER = 117,
    ZFS_DELEG_USER_SETS = 85,
    ZFS_DELEG_GROUP = 103,
    ZFS_DELEG_GROUP_SETS = 71,
    ZFS_DELEG_EVERYONE = 101,
    ZFS_DELEG_EVERYONE_SETS = 69,
    ZFS_DELEG_CREATE = 99,
    ZFS_DELEG_CREATE_SETS = 67,
    ZFS_DELEG_NAMED_SET = 115,
    ZFS_DELEG_NAMED_SET_SETS = 83,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_deleg_inherit_t {
    ZFS_DELEG_NONE = 0,
    ZFS_DELEG_PERM_LOCAL = 1,
    ZFS_DELEG_PERM_DESCENDENT = 2,
    ZFS_DELEG_PERM_LOCALDESCENDENT = 3,
    ZFS_DELEG_PERM_CREATE = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_canmount_type_t {
    ZFS_CANMOUNT_OFF = 0,
    ZFS_CANMOUNT_ON = 1,
    ZFS_CANMOUNT_NOAUTO = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_logbias_op_t {
    ZFS_LOGBIAS_LATENCY = 0,
    ZFS_LOGBIAS_THROUGHPUT = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_share_op {
    ZFS_SHARE_NFS = 0,
    ZFS_UNSHARE_NFS = 1,
    ZFS_SHARE_SMB = 2,
    ZFS_UNSHARE_SMB = 3,
}
pub use self::zfs_share_op as zfs_share_op_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_smb_acl_op {
    ZFS_SMB_ACL_ADD = 0,
    ZFS_SMB_ACL_REMOVE = 1,
    ZFS_SMB_ACL_RENAME = 2,
    ZFS_SMB_ACL_PURGE = 3,
}
pub use self::zfs_smb_acl_op as zfs_smb_acl_op_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_cache_type {
    ZFS_CACHE_NONE = 0,
    ZFS_CACHE_METADATA = 1,
    ZFS_CACHE_ALL = 2,
}
pub use self::zfs_cache_type as zfs_cache_type_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_sync_type_t {
    ZFS_SYNC_STANDARD = 0,
    ZFS_SYNC_ALWAYS = 1,
    ZFS_SYNC_DISABLED = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_xattr_type_t {
    ZFS_XATTR_OFF = 0,
    ZFS_XATTR_DIR = 1,
    ZFS_XATTR_SA = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_dnsize_type_t {
    ZFS_DNSIZE_LEGACY = 0,
    ZFS_DNSIZE_AUTO = 1,
    ZFS_DNSIZE_1K = 1024,
    ZFS_DNSIZE_2K = 2048,
    ZFS_DNSIZE_4K = 4096,
    ZFS_DNSIZE_8K = 8192,
    ZFS_DNSIZE_16K = 16384,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_redundant_metadata_type_t {
    ZFS_REDUNDANT_METADATA_ALL = 0,
    ZFS_REDUNDANT_METADATA_MOST = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_volmode_t {
    ZFS_VOLMODE_DEFAULT = 0,
    ZFS_VOLMODE_GEOM = 1,
    ZFS_VOLMODE_DEV = 2,
    ZFS_VOLMODE_NONE = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct zpool_rewind_policy {
    pub zrp_request: u32,
    pub zrp_maxmeta: u64,
    pub zrp_maxdata: u64,
    pub zrp_txg: u64,
}
#[test]
fn bindgen_test_layout_zpool_rewind_policy() {
    assert_eq!(::core::mem::size_of::<zpool_rewind_policy>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( zpool_rewind_policy )
               ));
    assert_eq! (::core::mem::align_of::<zpool_rewind_policy>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( zpool_rewind_policy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_rewind_policy ) ) . zrp_request as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_rewind_policy ) ,
                "::" , stringify ! ( zrp_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_rewind_policy ) ) . zrp_maxmeta as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_rewind_policy ) ,
                "::" , stringify ! ( zrp_maxmeta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_rewind_policy ) ) . zrp_maxdata as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_rewind_policy ) ,
                "::" , stringify ! ( zrp_maxdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zpool_rewind_policy ) ) . zrp_txg as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( zpool_rewind_policy ) ,
                "::" , stringify ! ( zrp_txg ) ));
}
impl Clone for zpool_rewind_policy {
    fn clone(&self) -> Self { *self }
}
pub type zpool_rewind_policy_t = zpool_rewind_policy;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vdev_state {
    VDEV_STATE_UNKNOWN = 0,
    VDEV_STATE_CLOSED = 1,
    VDEV_STATE_OFFLINE = 2,
    VDEV_STATE_REMOVED = 3,
    VDEV_STATE_CANT_OPEN = 4,
    VDEV_STATE_FAULTED = 5,
    VDEV_STATE_DEGRADED = 6,
    VDEV_STATE_HEALTHY = 7,
}
pub use self::vdev_state as vdev_state_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vdev_aux {
    VDEV_AUX_NONE = 0,
    VDEV_AUX_OPEN_FAILED = 1,
    VDEV_AUX_CORRUPT_DATA = 2,
    VDEV_AUX_NO_REPLICAS = 3,
    VDEV_AUX_BAD_GUID_SUM = 4,
    VDEV_AUX_TOO_SMALL = 5,
    VDEV_AUX_BAD_LABEL = 6,
    VDEV_AUX_VERSION_NEWER = 7,
    VDEV_AUX_VERSION_OLDER = 8,
    VDEV_AUX_UNSUP_FEAT = 9,
    VDEV_AUX_SPARED = 10,
    VDEV_AUX_ERR_EXCEEDED = 11,
    VDEV_AUX_IO_FAILURE = 12,
    VDEV_AUX_BAD_LOG = 13,
    VDEV_AUX_EXTERNAL = 14,
    VDEV_AUX_SPLIT_POOL = 15,
    VDEV_AUX_BAD_ASHIFT = 16,
    VDEV_AUX_EXTERNAL_PERSIST = 17,
    VDEV_AUX_ACTIVE = 18,
}
pub use self::vdev_aux as vdev_aux_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pool_state {
    POOL_STATE_ACTIVE = 0,
    POOL_STATE_EXPORTED = 1,
    POOL_STATE_DESTROYED = 2,
    POOL_STATE_SPARE = 3,
    POOL_STATE_L2CACHE = 4,
    POOL_STATE_UNINITIALIZED = 5,
    POOL_STATE_UNAVAIL = 6,
    POOL_STATE_POTENTIALLY_ACTIVE = 7,
}
pub use self::pool_state as pool_state_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mmp_state {
    MMP_STATE_ACTIVE = 0,
    MMP_STATE_INACTIVE = 1,
    MMP_STATE_NO_HOSTID = 2,
}
pub use self::mmp_state as mmp_state_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pool_scan_func {
    POOL_SCAN_NONE = 0,
    POOL_SCAN_SCRUB = 1,
    POOL_SCAN_RESILVER = 2,
    POOL_SCAN_FUNCS = 3,
}
pub use self::pool_scan_func as pool_scan_func_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pool_scrub_cmd {
    POOL_SCRUB_NORMAL = 0,
    POOL_SCRUB_PAUSE = 1,
    POOL_SCRUB_FLAGS_END = 2,
}
pub use self::pool_scrub_cmd as pool_scrub_cmd_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zio_type {
    ZIO_TYPE_NULL = 0,
    ZIO_TYPE_READ = 1,
    ZIO_TYPE_WRITE = 2,
    ZIO_TYPE_FREE = 3,
    ZIO_TYPE_CLAIM = 4,
    ZIO_TYPE_IOCTL = 5,
    ZIO_TYPES = 6,
}
pub use self::zio_type as zio_type_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pool_scan_stat {
    pub pss_func: u64,
    pub pss_state: u64,
    pub pss_start_time: u64,
    pub pss_end_time: u64,
    pub pss_to_examine: u64,
    pub pss_examined: u64,
    pub pss_to_process: u64,
    pub pss_processed: u64,
    pub pss_errors: u64,
    pub pss_pass_exam: u64,
    pub pss_pass_start: u64,
    pub pss_pass_scrub_pause: u64,
    pub pss_pass_scrub_spent_paused: u64,
}
#[test]
fn bindgen_test_layout_pool_scan_stat() {
    assert_eq!(::core::mem::size_of::<pool_scan_stat>() , 104usize , concat !
               ( "Size of: " , stringify ! ( pool_scan_stat ) ));
    assert_eq! (::core::mem::align_of::<pool_scan_stat>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pool_scan_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pool_scan_stat ) ) . pss_func as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pool_scan_stat ) , "::"
                , stringify ! ( pss_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pool_scan_stat ) ) . pss_state as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pool_scan_stat ) , "::"
                , stringify ! ( pss_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pool_scan_stat ) ) . pss_start_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pool_scan_stat ) , "::"
                , stringify ! ( pss_start_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pool_scan_stat ) ) . pss_end_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pool_scan_stat ) , "::"
                , stringify ! ( pss_end_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pool_scan_stat ) ) . pss_to_examine as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pool_scan_stat ) , "::"
                , stringify ! ( pss_to_examine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pool_scan_stat ) ) . pss_examined as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pool_scan_stat ) , "::"
                , stringify ! ( pss_examined ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pool_scan_stat ) ) . pss_to_process as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pool_scan_stat ) , "::"
                , stringify ! ( pss_to_process ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pool_scan_stat ) ) . pss_processed as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pool_scan_stat ) , "::"
                , stringify ! ( pss_processed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pool_scan_stat ) ) . pss_errors as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pool_scan_stat ) , "::"
                , stringify ! ( pss_errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pool_scan_stat ) ) . pss_pass_exam as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( pool_scan_stat ) , "::"
                , stringify ! ( pss_pass_exam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pool_scan_stat ) ) . pss_pass_start as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( pool_scan_stat ) , "::"
                , stringify ! ( pss_pass_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pool_scan_stat ) ) . pss_pass_scrub_pause
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( pool_scan_stat ) , "::"
                , stringify ! ( pss_pass_scrub_pause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pool_scan_stat ) ) .
                pss_pass_scrub_spent_paused as * const _ as usize } , 96usize
                , concat ! (
                "Alignment of field: " , stringify ! ( pool_scan_stat ) , "::"
                , stringify ! ( pss_pass_scrub_spent_paused ) ));
}
impl Clone for pool_scan_stat {
    fn clone(&self) -> Self { *self }
}
pub type pool_scan_stat_t = pool_scan_stat;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dsl_scan_state {
    DSS_NONE = 0,
    DSS_SCANNING = 1,
    DSS_FINISHED = 2,
    DSS_CANCELED = 3,
    DSS_NUM_STATES = 4,
}
pub use self::dsl_scan_state as dsl_scan_state_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zpool_errata {
    ZPOOL_ERRATA_NONE = 0,
    ZPOOL_ERRATA_ZOL_2094_SCRUB = 1,
    ZPOOL_ERRATA_ZOL_2094_ASYNC_DESTROY = 2,
}
pub use self::zpool_errata as zpool_errata_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vdev_stat {
    pub vs_timestamp: hrtime_t,
    pub vs_state: u64,
    pub vs_aux: u64,
    pub vs_alloc: u64,
    pub vs_space: u64,
    pub vs_dspace: u64,
    pub vs_rsize: u64,
    pub vs_esize: u64,
    pub vs_ops: [u64; 6usize],
    pub vs_bytes: [u64; 6usize],
    pub vs_read_errors: u64,
    pub vs_write_errors: u64,
    pub vs_checksum_errors: u64,
    pub vs_self_healed: u64,
    pub vs_scan_removing: u64,
    pub vs_scan_processed: u64,
    pub vs_fragmentation: u64,
}
#[test]
fn bindgen_test_layout_vdev_stat() {
    assert_eq!(::core::mem::size_of::<vdev_stat>() , 216usize , concat ! (
               "Size of: " , stringify ! ( vdev_stat ) ));
    assert_eq! (::core::mem::align_of::<vdev_stat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vdev_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_timestamp as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_aux as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_aux ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_alloc as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_space as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_dspace as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_dspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_rsize as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_rsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_esize as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_esize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_ops as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_bytes as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_read_errors as * const
                _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_read_errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_write_errors as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_write_errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_checksum_errors as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_checksum_errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_self_healed as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_self_healed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_scan_removing as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_scan_removing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_scan_processed as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_scan_processed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat ) ) . vs_fragmentation as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat ) , "::" ,
                stringify ! ( vs_fragmentation ) ));
}
impl Clone for vdev_stat {
    fn clone(&self) -> Self { *self }
}
pub type vdev_stat_t = vdev_stat;
#[repr(C)]
#[derive(Copy)]
pub struct vdev_stat_ex {
    pub vsx_active_queue: [u64; 5usize],
    pub vsx_pend_queue: [u64; 5usize],
    pub vsx_queue_histo: [[u64; 37usize]; 5usize],
    pub vsx_total_histo: [[u64; 37usize]; 6usize],
    pub vsx_disk_histo: [[u64; 37usize]; 6usize],
    pub vsx_ind_histo: [[u64; 25usize]; 5usize],
    pub vsx_agg_histo: [[u64; 25usize]; 5usize],
}
#[test]
fn bindgen_test_layout_vdev_stat_ex() {
    assert_eq!(::core::mem::size_of::<vdev_stat_ex>() , 7112usize , concat ! (
               "Size of: " , stringify ! ( vdev_stat_ex ) ));
    assert_eq! (::core::mem::align_of::<vdev_stat_ex>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vdev_stat_ex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat_ex ) ) . vsx_active_queue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat_ex ) , "::" ,
                stringify ! ( vsx_active_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat_ex ) ) . vsx_pend_queue as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat_ex ) , "::" ,
                stringify ! ( vsx_pend_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat_ex ) ) . vsx_queue_histo as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat_ex ) , "::" ,
                stringify ! ( vsx_queue_histo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat_ex ) ) . vsx_total_histo as *
                const _ as usize } , 1560usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat_ex ) , "::" ,
                stringify ! ( vsx_total_histo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat_ex ) ) . vsx_disk_histo as *
                const _ as usize } , 3336usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat_ex ) , "::" ,
                stringify ! ( vsx_disk_histo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat_ex ) ) . vsx_ind_histo as *
                const _ as usize } , 5112usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat_ex ) , "::" ,
                stringify ! ( vsx_ind_histo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_stat_ex ) ) . vsx_agg_histo as *
                const _ as usize } , 6112usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_stat_ex ) , "::" ,
                stringify ! ( vsx_agg_histo ) ));
}
impl Clone for vdev_stat_ex {
    fn clone(&self) -> Self { *self }
}
pub type vdev_stat_ex_t = vdev_stat_ex;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ddt_object {
    pub ddo_count: u64,
    pub ddo_dspace: u64,
    pub ddo_mspace: u64,
}
#[test]
fn bindgen_test_layout_ddt_object() {
    assert_eq!(::core::mem::size_of::<ddt_object>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ddt_object ) ));
    assert_eq! (::core::mem::align_of::<ddt_object>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ddt_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_object ) ) . ddo_count as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_object ) , "::" ,
                stringify ! ( ddo_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_object ) ) . ddo_dspace as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_object ) , "::" ,
                stringify ! ( ddo_dspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_object ) ) . ddo_mspace as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_object ) , "::" ,
                stringify ! ( ddo_mspace ) ));
}
impl Clone for ddt_object {
    fn clone(&self) -> Self { *self }
}
pub type ddt_object_t = ddt_object;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ddt_stat {
    pub dds_blocks: u64,
    pub dds_lsize: u64,
    pub dds_psize: u64,
    pub dds_dsize: u64,
    pub dds_ref_blocks: u64,
    pub dds_ref_lsize: u64,
    pub dds_ref_psize: u64,
    pub dds_ref_dsize: u64,
}
#[test]
fn bindgen_test_layout_ddt_stat() {
    assert_eq!(::core::mem::size_of::<ddt_stat>() , 64usize , concat ! (
               "Size of: " , stringify ! ( ddt_stat ) ));
    assert_eq! (::core::mem::align_of::<ddt_stat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ddt_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_blocks as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_blocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_lsize as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_lsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_psize as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_psize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_dsize as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_dsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_ref_blocks as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_ref_blocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_ref_lsize as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_ref_lsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_ref_psize as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_ref_psize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_stat ) ) . dds_ref_dsize as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_stat ) , "::" ,
                stringify ! ( dds_ref_dsize ) ));
}
impl Clone for ddt_stat {
    fn clone(&self) -> Self { *self }
}
pub type ddt_stat_t = ddt_stat;
#[repr(C)]
#[derive(Copy)]
pub struct ddt_histogram {
    pub ddh_stat: [ddt_stat_t; 64usize],
}
#[test]
fn bindgen_test_layout_ddt_histogram() {
    assert_eq!(::core::mem::size_of::<ddt_histogram>() , 4096usize , concat !
               ( "Size of: " , stringify ! ( ddt_histogram ) ));
    assert_eq! (::core::mem::align_of::<ddt_histogram>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ddt_histogram ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ddt_histogram ) ) . ddh_stat as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ddt_histogram ) , "::"
                , stringify ! ( ddh_stat ) ));
}
impl Clone for ddt_histogram {
    fn clone(&self) -> Self { *self }
}
pub type ddt_histogram_t = ddt_histogram;
pub const zfs_ioc_ZFS_IOC: zfs_ioc = zfs_ioc::ZFS_IOC_FIRST;
pub const zfs_ioc_ZFS_IOC_POOL_CREATE: zfs_ioc = zfs_ioc::ZFS_IOC_FIRST;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_ioc {
    ZFS_IOC_FIRST = 23040,
    ZFS_IOC_POOL_DESTROY = 23041,
    ZFS_IOC_POOL_IMPORT = 23042,
    ZFS_IOC_POOL_EXPORT = 23043,
    ZFS_IOC_POOL_CONFIGS = 23044,
    ZFS_IOC_POOL_STATS = 23045,
    ZFS_IOC_POOL_TRYIMPORT = 23046,
    ZFS_IOC_POOL_SCAN = 23047,
    ZFS_IOC_POOL_FREEZE = 23048,
    ZFS_IOC_POOL_UPGRADE = 23049,
    ZFS_IOC_POOL_GET_HISTORY = 23050,
    ZFS_IOC_VDEV_ADD = 23051,
    ZFS_IOC_VDEV_REMOVE = 23052,
    ZFS_IOC_VDEV_SET_STATE = 23053,
    ZFS_IOC_VDEV_ATTACH = 23054,
    ZFS_IOC_VDEV_DETACH = 23055,
    ZFS_IOC_VDEV_SETPATH = 23056,
    ZFS_IOC_VDEV_SETFRU = 23057,
    ZFS_IOC_OBJSET_STATS = 23058,
    ZFS_IOC_OBJSET_ZPLPROPS = 23059,
    ZFS_IOC_DATASET_LIST_NEXT = 23060,
    ZFS_IOC_SNAPSHOT_LIST_NEXT = 23061,
    ZFS_IOC_SET_PROP = 23062,
    ZFS_IOC_CREATE = 23063,
    ZFS_IOC_DESTROY = 23064,
    ZFS_IOC_ROLLBACK = 23065,
    ZFS_IOC_RENAME = 23066,
    ZFS_IOC_RECV = 23067,
    ZFS_IOC_SEND = 23068,
    ZFS_IOC_INJECT_FAULT = 23069,
    ZFS_IOC_CLEAR_FAULT = 23070,
    ZFS_IOC_INJECT_LIST_NEXT = 23071,
    ZFS_IOC_ERROR_LOG = 23072,
    ZFS_IOC_CLEAR = 23073,
    ZFS_IOC_PROMOTE = 23074,
    ZFS_IOC_SNAPSHOT = 23075,
    ZFS_IOC_DSOBJ_TO_DSNAME = 23076,
    ZFS_IOC_OBJ_TO_PATH = 23077,
    ZFS_IOC_POOL_SET_PROPS = 23078,
    ZFS_IOC_POOL_GET_PROPS = 23079,
    ZFS_IOC_SET_FSACL = 23080,
    ZFS_IOC_GET_FSACL = 23081,
    ZFS_IOC_SHARE = 23082,
    ZFS_IOC_INHERIT_PROP = 23083,
    ZFS_IOC_SMB_ACL = 23084,
    ZFS_IOC_USERSPACE_ONE = 23085,
    ZFS_IOC_USERSPACE_MANY = 23086,
    ZFS_IOC_USERSPACE_UPGRADE = 23087,
    ZFS_IOC_HOLD = 23088,
    ZFS_IOC_RELEASE = 23089,
    ZFS_IOC_GET_HOLDS = 23090,
    ZFS_IOC_OBJSET_RECVD_PROPS = 23091,
    ZFS_IOC_VDEV_SPLIT = 23092,
    ZFS_IOC_NEXT_OBJ = 23093,
    ZFS_IOC_DIFF = 23094,
    ZFS_IOC_TMP_SNAPSHOT = 23095,
    ZFS_IOC_OBJ_TO_STATS = 23096,
    ZFS_IOC_SPACE_WRITTEN = 23097,
    ZFS_IOC_SPACE_SNAPS = 23098,
    ZFS_IOC_DESTROY_SNAPS = 23099,
    ZFS_IOC_POOL_REGUID = 23100,
    ZFS_IOC_POOL_REOPEN = 23101,
    ZFS_IOC_SEND_PROGRESS = 23102,
    ZFS_IOC_LOG_HISTORY = 23103,
    ZFS_IOC_SEND_NEW = 23104,
    ZFS_IOC_SEND_SPACE = 23105,
    ZFS_IOC_CLONE = 23106,
    ZFS_IOC_BOOKMARK = 23107,
    ZFS_IOC_GET_BOOKMARKS = 23108,
    ZFS_IOC_DESTROY_BOOKMARKS = 23109,
    ZFS_IOC_RECV_NEW = 23110,
    ZFS_IOC_POOL_SYNC = 23111,
    ZFS_IOC_LINUX = 23168,
    ZFS_IOC_EVENTS_NEXT = 23169,
    ZFS_IOC_EVENTS_CLEAR = 23170,
    ZFS_IOC_EVENTS_SEEK = 23171,
    ZFS_IOC_FREEBSD = 23232,
    ZFS_IOC_LAST = 23233,
}
pub use self::zfs_ioc as zfs_ioc_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spa_load_state_t {
    SPA_LOAD_NONE = 0,
    SPA_LOAD_OPEN = 1,
    SPA_LOAD_IMPORT = 2,
    SPA_LOAD_TRYIMPORT = 3,
    SPA_LOAD_RECOVER = 4,
    SPA_LOAD_ERROR = 5,
    SPA_LOAD_CREATE = 6,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avl_node {
    pub avl_child: [*mut avl_node; 2usize],
    pub avl_pcb: usize,
}
#[test]
fn bindgen_test_layout_avl_node() {
    assert_eq!(::core::mem::size_of::<avl_node>() , 24usize , concat ! (
               "Size of: " , stringify ! ( avl_node ) ));
    assert_eq! (::core::mem::align_of::<avl_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( avl_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avl_node ) ) . avl_child as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avl_node ) , "::" ,
                stringify ! ( avl_child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avl_node ) ) . avl_pcb as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( avl_node ) , "::" ,
                stringify ! ( avl_pcb ) ));
}
impl Clone for avl_node {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct avl_tree {
    pub avl_root: *mut avl_node,
    pub avl_compar: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::libc::c_void,
                                                                arg2:
                                                                    *const ::libc::c_void)
                                               -> ::libc::c_int>,
    pub avl_offset: usize,
    pub avl_numnodes: ulong_t,
    pub avl_size: usize,
}
#[test]
fn bindgen_test_layout_avl_tree() {
    assert_eq!(::core::mem::size_of::<avl_tree>() , 40usize , concat ! (
               "Size of: " , stringify ! ( avl_tree ) ));
    assert_eq! (::core::mem::align_of::<avl_tree>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( avl_tree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avl_tree ) ) . avl_root as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( avl_tree ) , "::" ,
                stringify ! ( avl_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avl_tree ) ) . avl_compar as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( avl_tree ) , "::" ,
                stringify ! ( avl_compar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avl_tree ) ) . avl_offset as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( avl_tree ) , "::" ,
                stringify ! ( avl_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avl_tree ) ) . avl_numnodes as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( avl_tree ) , "::" ,
                stringify ! ( avl_numnodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const avl_tree ) ) . avl_size as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( avl_tree ) , "::" ,
                stringify ! ( avl_size ) ));
}
impl Clone for avl_tree {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn avl_walk(arg1: *mut avl_tree, arg2: *mut ::libc::c_void,
                    arg3: ::libc::c_int) -> *mut ::libc::c_void;
}
pub type avl_tree_t = avl_tree;
pub type avl_node_t = avl_node;
pub type avl_index_t = usize;
extern "C" {
    pub fn avl_create(tree: *mut avl_tree_t,
                      compar:
                          ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                          *const ::libc::c_void,
                                                                      arg2:
                                                                          *const ::libc::c_void)
                                                     -> ::libc::c_int>,
                      size: usize, offset: usize);
}
extern "C" {
    pub fn avl_find(tree: *mut avl_tree_t, node: *const ::libc::c_void,
                    where_: *mut avl_index_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn avl_insert(tree: *mut avl_tree_t, node: *mut ::libc::c_void,
                      where_: avl_index_t);
}
extern "C" {
    pub fn avl_insert_here(tree: *mut avl_tree_t,
                           new_data: *mut ::libc::c_void,
                           here: *mut ::libc::c_void,
                           direction: ::libc::c_int);
}
extern "C" {
    pub fn avl_first(tree: *mut avl_tree_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn avl_last(tree: *mut avl_tree_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn avl_nearest(tree: *mut avl_tree_t, where_: avl_index_t,
                       direction: ::libc::c_int) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn avl_add(tree: *mut avl_tree_t, node: *mut ::libc::c_void);
}
extern "C" {
    pub fn avl_remove(tree: *mut avl_tree_t, node: *mut ::libc::c_void);
}
extern "C" {
    pub fn avl_update(arg1: *mut avl_tree_t, arg2: *mut ::libc::c_void)
     -> boolean_t;
}
extern "C" {
    pub fn avl_update_lt(arg1: *mut avl_tree_t, arg2: *mut ::libc::c_void)
     -> boolean_t;
}
extern "C" {
    pub fn avl_update_gt(arg1: *mut avl_tree_t, arg2: *mut ::libc::c_void)
     -> boolean_t;
}
extern "C" {
    pub fn avl_swap(tree1: *mut avl_tree_t, tree2: *mut avl_tree_t);
}
extern "C" {
    pub fn avl_numnodes(tree: *mut avl_tree_t) -> ulong_t;
}
extern "C" {
    pub fn avl_is_empty(tree: *mut avl_tree_t) -> boolean_t;
}
extern "C" {
    pub fn avl_destroy_nodes(tree: *mut avl_tree_t,
                             cookie: *mut *mut ::libc::c_void)
     -> *mut ::libc::c_void;
}
extern "C" {
    pub fn avl_destroy(tree: *mut avl_tree_t);
}
pub type ucred_t = ::libc::c_int;
extern "C" {
    pub fn libzfs_core_init() -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_core_fini();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lzc_dataset_type {
    LZC_DATSET_TYPE_ZFS = 2,
    LZC_DATSET_TYPE_ZVOL = 3,
}
extern "C" {
    pub fn lzc_snapshot(arg1: *mut nvlist_t, arg2: *mut nvlist_t,
                        arg3: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_create(arg1: *const ::libc::c_char, arg2: lzc_dataset_type,
                      arg3: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_clone(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                     arg3: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_promote(arg1: *const ::libc::c_char, arg2: *mut ::libc::c_char,
                       arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_destroy_snaps(arg1: *mut nvlist_t, arg2: boolean_t,
                             arg3: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_bookmark(arg1: *mut nvlist_t, arg2: *mut *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_get_bookmarks(arg1: *const ::libc::c_char, arg2: *mut nvlist_t,
                             arg3: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_destroy_bookmarks(arg1: *mut nvlist_t,
                                 arg2: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_snaprange_space(arg1: *const ::libc::c_char,
                               arg2: *const ::libc::c_char, arg3: *mut u64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_hold(arg1: *mut nvlist_t, arg2: ::libc::c_int,
                    arg3: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_release(arg1: *mut nvlist_t, arg2: *mut *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_get_holds(arg1: *const ::libc::c_char,
                         arg2: *mut *mut nvlist_t) -> ::libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lzc_send_flags {
    LZC_SEND_FLAG_EMBED_DATA = 1,
    LZC_SEND_FLAG_LARGE_BLOCK = 2,
    LZC_SEND_FLAG_COMPRESS = 4,
}
extern "C" {
    pub fn lzc_send(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                    arg3: ::libc::c_int, arg4: lzc_send_flags)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_send_resume(arg1: *const ::libc::c_char,
                           arg2: *const ::libc::c_char, arg3: ::libc::c_int,
                           arg4: lzc_send_flags, arg5: u64, arg6: u64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_send_space(arg1: *const ::libc::c_char,
                          arg2: *const ::libc::c_char, arg3: lzc_send_flags,
                          arg4: *mut u64) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dmu_replay_record {
    _unused: [u8; 0],
}
extern "C" {
    pub fn lzc_receive(arg1: *const ::libc::c_char, arg2: *mut nvlist_t,
                       arg3: *const ::libc::c_char, arg4: boolean_t,
                       arg5: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_receive_resumable(arg1: *const ::libc::c_char,
                                 arg2: *mut nvlist_t,
                                 arg3: *const ::libc::c_char, arg4: boolean_t,
                                 arg5: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_receive_with_header(arg1: *const ::libc::c_char,
                                   arg2: *mut nvlist_t,
                                   arg3: *const ::libc::c_char,
                                   arg4: boolean_t, arg5: boolean_t,
                                   arg6: ::libc::c_int,
                                   arg7: *const dmu_replay_record)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_receive_one(arg1: *const ::libc::c_char, arg2: *mut nvlist_t,
                           arg3: *const ::libc::c_char, arg4: boolean_t,
                           arg5: boolean_t, arg6: ::libc::c_int,
                           arg7: *const dmu_replay_record,
                           arg8: ::libc::c_int, arg9: *mut u64,
                           arg10: *mut u64, arg11: *mut u64,
                           arg12: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_receive_with_cmdprops(arg1: *const ::libc::c_char,
                                     arg2: *mut nvlist_t, arg3: *mut nvlist_t,
                                     arg4: *const ::libc::c_char,
                                     arg5: boolean_t, arg6: boolean_t,
                                     arg7: ::libc::c_int,
                                     arg8: *const dmu_replay_record,
                                     arg9: ::libc::c_int, arg10: *mut u64,
                                     arg11: *mut u64, arg12: *mut u64,
                                     arg13: *mut *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_exists(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn lzc_rollback(arg1: *const ::libc::c_char,
                        arg2: *mut ::libc::c_char, arg3: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_rollback_to(arg1: *const ::libc::c_char,
                           arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn lzc_sync(arg1: *const ::libc::c_char, arg2: *mut nvlist_t,
                    arg3: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "zpool_default_import_path"]
    pub static mut zpool_default_import_path: [*mut ::libc::c_char; 9usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_error {
    EZFS_SUCCESS = 0,
    EZFS_NOMEM = 2000,
    EZFS_BADPROP = 2001,
    EZFS_PROPREADONLY = 2002,
    EZFS_PROPTYPE = 2003,
    EZFS_PROPNONINHERIT = 2004,
    EZFS_PROPSPACE = 2005,
    EZFS_BADTYPE = 2006,
    EZFS_BUSY = 2007,
    EZFS_EXISTS = 2008,
    EZFS_NOENT = 2009,
    EZFS_BADSTREAM = 2010,
    EZFS_DSREADONLY = 2011,
    EZFS_VOLTOOBIG = 2012,
    EZFS_INVALIDNAME = 2013,
    EZFS_BADRESTORE = 2014,
    EZFS_BADBACKUP = 2015,
    EZFS_BADTARGET = 2016,
    EZFS_NODEVICE = 2017,
    EZFS_BADDEV = 2018,
    EZFS_NOREPLICAS = 2019,
    EZFS_RESILVERING = 2020,
    EZFS_BADVERSION = 2021,
    EZFS_POOLUNAVAIL = 2022,
    EZFS_DEVOVERFLOW = 2023,
    EZFS_BADPATH = 2024,
    EZFS_CROSSTARGET = 2025,
    EZFS_ZONED = 2026,
    EZFS_MOUNTFAILED = 2027,
    EZFS_UMOUNTFAILED = 2028,
    EZFS_UNSHARENFSFAILED = 2029,
    EZFS_SHARENFSFAILED = 2030,
    EZFS_PERM = 2031,
    EZFS_NOSPC = 2032,
    EZFS_FAULT = 2033,
    EZFS_IO = 2034,
    EZFS_INTR = 2035,
    EZFS_ISSPARE = 2036,
    EZFS_INVALCONFIG = 2037,
    EZFS_RECURSIVE = 2038,
    EZFS_NOHISTORY = 2039,
    EZFS_POOLPROPS = 2040,
    EZFS_POOL_NOTSUP = 2041,
    EZFS_POOL_INVALARG = 2042,
    EZFS_NAMETOOLONG = 2043,
    EZFS_OPENFAILED = 2044,
    EZFS_NOCAP = 2045,
    EZFS_LABELFAILED = 2046,
    EZFS_BADWHO = 2047,
    EZFS_BADPERM = 2048,
    EZFS_BADPERMSET = 2049,
    EZFS_NODELEGATION = 2050,
    EZFS_UNSHARESMBFAILED = 2051,
    EZFS_SHARESMBFAILED = 2052,
    EZFS_BADCACHE = 2053,
    EZFS_ISL2CACHE = 2054,
    EZFS_VDEVNOTSUP = 2055,
    EZFS_NOTSUP = 2056,
    EZFS_ACTIVE_SPARE = 2057,
    EZFS_UNPLAYED_LOGS = 2058,
    EZFS_REFTAG_RELE = 2059,
    EZFS_REFTAG_HOLD = 2060,
    EZFS_TAGTOOLONG = 2061,
    EZFS_PIPEFAILED = 2062,
    EZFS_THREADCREATEFAILED = 2063,
    EZFS_POSTSPLIT_ONLINE = 2064,
    EZFS_SCRUBBING = 2065,
    EZFS_NO_SCRUB = 2066,
    EZFS_DIFF = 2067,
    EZFS_DIFFDATA = 2068,
    EZFS_POOLREADONLY = 2069,
    EZFS_SCRUB_PAUSED = 2070,
    EZFS_ACTIVE_POOL = 2071,
    EZFS_UNKNOWN = 2072,
}
pub use self::zfs_error as zfs_error_t;
#[repr(C)]
#[derive(Copy)]
pub struct zfs_perm_node {
    pub z_node: avl_node_t,
    pub z_pname: [::libc::c_char; 4096usize],
}
#[test]
fn bindgen_test_layout_zfs_perm_node() {
    assert_eq!(::core::mem::size_of::<zfs_perm_node>() , 4120usize , concat !
               ( "Size of: " , stringify ! ( zfs_perm_node ) ));
    assert_eq! (::core::mem::align_of::<zfs_perm_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( zfs_perm_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_perm_node ) ) . z_node as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_perm_node ) , "::"
                , stringify ! ( z_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_perm_node ) ) . z_pname as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_perm_node ) , "::"
                , stringify ! ( z_pname ) ));
}
impl Clone for zfs_perm_node {
    fn clone(&self) -> Self { *self }
}
pub type zfs_perm_node_t = zfs_perm_node;
#[repr(C)]
#[derive(Copy)]
pub struct zfs_allow_node {
    pub z_node: avl_node_t,
    pub z_key: [::libc::c_char; 4096usize],
    pub z_localdescend: avl_tree_t,
    pub z_local: avl_tree_t,
    pub z_descend: avl_tree_t,
}
#[test]
fn bindgen_test_layout_zfs_allow_node() {
    assert_eq!(::core::mem::size_of::<zfs_allow_node>() , 4240usize , concat !
               ( "Size of: " , stringify ! ( zfs_allow_node ) ));
    assert_eq! (::core::mem::align_of::<zfs_allow_node>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( zfs_allow_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow_node ) ) . z_node as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow_node ) , "::"
                , stringify ! ( z_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow_node ) ) . z_key as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow_node ) , "::"
                , stringify ! ( z_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow_node ) ) . z_localdescend as *
                const _ as usize } , 4120usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow_node ) , "::"
                , stringify ! ( z_localdescend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow_node ) ) . z_local as * const _
                as usize } , 4160usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow_node ) , "::"
                , stringify ! ( z_local ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow_node ) ) . z_descend as * const
                _ as usize } , 4200usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow_node ) , "::"
                , stringify ! ( z_descend ) ));
}
impl Clone for zfs_allow_node {
    fn clone(&self) -> Self { *self }
}
pub type zfs_allow_node_t = zfs_allow_node;
#[repr(C)]
#[derive(Copy)]
pub struct zfs_allow {
    pub z_next: *mut zfs_allow,
    pub z_setpoint: [::libc::c_char; 4096usize],
    pub z_sets: avl_tree_t,
    pub z_crperms: avl_tree_t,
    pub z_user: avl_tree_t,
    pub z_group: avl_tree_t,
    pub z_everyone: avl_tree_t,
}
#[test]
fn bindgen_test_layout_zfs_allow() {
    assert_eq!(::core::mem::size_of::<zfs_allow>() , 4304usize , concat ! (
               "Size of: " , stringify ! ( zfs_allow ) ));
    assert_eq! (::core::mem::align_of::<zfs_allow>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( zfs_allow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow ) ) . z_next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow ) , "::" ,
                stringify ! ( z_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow ) ) . z_setpoint as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow ) , "::" ,
                stringify ! ( z_setpoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow ) ) . z_sets as * const _ as
                usize } , 4104usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow ) , "::" ,
                stringify ! ( z_sets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow ) ) . z_crperms as * const _ as
                usize } , 4144usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow ) , "::" ,
                stringify ! ( z_crperms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow ) ) . z_user as * const _ as
                usize } , 4184usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow ) , "::" ,
                stringify ! ( z_user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow ) ) . z_group as * const _ as
                usize } , 4224usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow ) , "::" ,
                stringify ! ( z_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zfs_allow ) ) . z_everyone as * const _
                as usize } , 4264usize , concat ! (
                "Alignment of field: " , stringify ! ( zfs_allow ) , "::" ,
                stringify ! ( z_everyone ) ));
}
impl Clone for zfs_allow {
    fn clone(&self) -> Self { *self }
}
pub type zfs_allow_t = zfs_allow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zfs_handle {
    _unused: [u8; 0],
}
pub type zfs_handle_t = zfs_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zpool_handle {
    _unused: [u8; 0],
}
pub type zpool_handle_t = zpool_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libzfs_handle {
    _unused: [u8; 0],
}
pub type libzfs_handle_t = libzfs_handle;
extern "C" {
    pub fn libzfs_init() -> *mut libzfs_handle_t;
}
extern "C" {
    pub fn libzfs_fini(arg1: *mut libzfs_handle_t);
}
extern "C" {
    pub fn zpool_get_handle(arg1: *mut zpool_handle_t)
     -> *mut libzfs_handle_t;
}
extern "C" {
    pub fn zfs_get_handle(arg1: *mut zfs_handle_t) -> *mut libzfs_handle_t;
}
extern "C" {
    pub fn libzfs_print_on_error(arg1: *mut libzfs_handle_t, arg2: boolean_t);
}
extern "C" {
    pub fn zfs_save_arguments(argc: ::libc::c_int,
                              arg1: *mut *mut ::libc::c_char,
                              arg2: *mut ::libc::c_char, arg3: ::libc::c_int);
}
extern "C" {
    pub fn zpool_log_history(arg1: *mut libzfs_handle_t,
                             arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_errno(arg1: *mut libzfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_error_init(arg1: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn libzfs_error_action(arg1: *mut libzfs_handle_t)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn libzfs_error_description(arg1: *mut libzfs_handle_t)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_standard_error(arg1: *mut libzfs_handle_t, arg2: ::libc::c_int,
                              arg3: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_mnttab_init(arg1: *mut libzfs_handle_t);
}
extern "C" {
    pub fn libzfs_mnttab_fini(arg1: *mut libzfs_handle_t);
}
extern "C" {
    pub fn libzfs_mnttab_cache(arg1: *mut libzfs_handle_t, arg2: boolean_t);
}
extern "C" {
    pub fn libzfs_mnttab_find(arg1: *mut libzfs_handle_t,
                              arg2: *const ::libc::c_char, arg3: *mut mnttab)
     -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_mnttab_add(arg1: *mut libzfs_handle_t,
                             arg2: *const ::libc::c_char,
                             arg3: *const ::libc::c_char,
                             arg4: *const ::libc::c_char);
}
extern "C" {
    pub fn libzfs_mnttab_remove(arg1: *mut libzfs_handle_t,
                                arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn zpool_open(arg1: *mut libzfs_handle_t, arg2: *const ::libc::c_char)
     -> *mut zpool_handle_t;
}
extern "C" {
    pub fn zpool_open_canfail(arg1: *mut libzfs_handle_t,
                              arg2: *const ::libc::c_char)
     -> *mut zpool_handle_t;
}
extern "C" {
    pub fn zpool_close(arg1: *mut zpool_handle_t);
}
extern "C" {
    pub fn zpool_get_name(arg1: *mut zpool_handle_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zpool_get_state(arg1: *mut zpool_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_state_to_name(arg1: vdev_state_t, arg2: vdev_aux_t)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn zpool_pool_state_to_name(arg1: pool_state_t)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn zpool_free_handles(arg1: *mut libzfs_handle_t);
}
pub type zpool_iter_f =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut zpool_handle_t,
                                                arg2: *mut ::libc::c_void)
                               -> ::libc::c_int>;
extern "C" {
    pub fn zpool_iter(arg1: *mut libzfs_handle_t, arg2: zpool_iter_f,
                      arg3: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_skip_pool(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zpool_create(arg1: *mut libzfs_handle_t,
                        arg2: *const ::libc::c_char, arg3: *mut nvlist_t,
                        arg4: *mut nvlist_t, arg5: *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_destroy(arg1: *mut zpool_handle_t,
                         arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_add(arg1: *mut zpool_handle_t, arg2: *mut nvlist_t)
     -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct splitflags {
    pub _bitfield_1: u8,
    pub name_flags: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_splitflags() {
    assert_eq!(::core::mem::size_of::<splitflags>() , 8usize , concat ! (
               "Size of: " , stringify ! ( splitflags ) ));
    assert_eq! (::core::mem::align_of::<splitflags>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( splitflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const splitflags ) ) . name_flags as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( splitflags ) , "::" ,
                stringify ! ( name_flags ) ));
}
impl Clone for splitflags {
    fn clone(&self) -> Self { *self }
}
impl splitflags {
    #[inline]
    pub fn dryrun(&self) -> ::libc::c_int {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_dryrun(&mut self, val: ::libc::c_int) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn import(&self) -> ::libc::c_int {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_import(&mut self, val: ::libc::c_int) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(dryrun: ::libc::c_int, import: ::libc::c_int)
     -> u8 {
        ({ ({ 0 } | ((dryrun as u32 as u8) << 0usize) & (1u64 as u8)) } |
             ((import as u32 as u8) << 1usize) & (2u64 as u8))
    }
}
pub type splitflags_t = splitflags;
extern "C" {
    pub fn zpool_scan(arg1: *mut zpool_handle_t, arg2: pool_scan_func_t,
                      arg3: pool_scrub_cmd_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_clear(arg1: *mut zpool_handle_t, arg2: *const ::libc::c_char,
                       arg3: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_reguid(arg1: *mut zpool_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_reopen(arg1: *mut zpool_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_sync_one(arg1: *mut zpool_handle_t,
                          arg2: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_online(arg1: *mut zpool_handle_t,
                             arg2: *const ::libc::c_char, arg3: ::libc::c_int,
                             arg4: *mut vdev_state_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_offline(arg1: *mut zpool_handle_t,
                              arg2: *const ::libc::c_char, arg3: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_attach(arg1: *mut zpool_handle_t,
                             arg2: *const ::libc::c_char,
                             arg3: *const ::libc::c_char, arg4: *mut nvlist_t,
                             arg5: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_detach(arg1: *mut zpool_handle_t,
                             arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_remove(arg1: *mut zpool_handle_t,
                             arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_split(arg1: *mut zpool_handle_t,
                            arg2: *mut ::libc::c_char,
                            arg3: *mut *mut nvlist_t, arg4: *mut nvlist_t,
                            arg5: splitflags_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_fault(arg1: *mut zpool_handle_t, arg2: u64,
                            arg3: vdev_aux_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_degrade(arg1: *mut zpool_handle_t, arg2: u64,
                              arg3: vdev_aux_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_clear(arg1: *mut zpool_handle_t, arg2: u64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_find_vdev(arg1: *mut zpool_handle_t,
                           arg2: *const ::libc::c_char, arg3: *mut boolean_t,
                           arg4: *mut boolean_t, arg5: *mut boolean_t)
     -> *mut nvlist_t;
}
extern "C" {
    pub fn zpool_find_vdev_by_physpath(arg1: *mut zpool_handle_t,
                                       arg2: *const ::libc::c_char,
                                       arg3: *mut boolean_t,
                                       arg4: *mut boolean_t,
                                       arg5: *mut boolean_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn zpool_label_disk_wait(arg1: *mut ::libc::c_char,
                                 arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_label_disk(arg1: *mut libzfs_handle_t,
                            arg2: *mut zpool_handle_t,
                            arg3: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_vdev_path_to_guid(zhp: *mut zpool_handle_t,
                                   path: *const ::libc::c_char) -> u64;
}
extern "C" {
    pub fn zfs_dev_is_dm(dev_name: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_dev_is_whole_disk(dev_name: *mut ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_get_underlying_path(dev_name: *mut ::libc::c_char)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn zfs_get_enclosure_sysfs_path(dev_name: *mut ::libc::c_char)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn zpool_set_prop(arg1: *mut zpool_handle_t,
                          arg2: *const ::libc::c_char,
                          arg3: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_get_prop(arg1: *mut zpool_handle_t, arg2: zpool_prop_t,
                          arg3: *mut ::libc::c_char, proplen: usize,
                          arg4: *mut zprop_source_t, literal: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_get_prop_int(arg1: *mut zpool_handle_t, arg2: zpool_prop_t,
                              arg3: *mut zprop_source_t) -> u64;
}
extern "C" {
    pub fn zpool_prop_values(arg1: zpool_prop_t) -> *const ::libc::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zpool_status_t {
    ZPOOL_STATUS_CORRUPT_CACHE = 0,
    ZPOOL_STATUS_MISSING_DEV_R = 1,
    ZPOOL_STATUS_MISSING_DEV_NR = 2,
    ZPOOL_STATUS_CORRUPT_LABEL_R = 3,
    ZPOOL_STATUS_CORRUPT_LABEL_NR = 4,
    ZPOOL_STATUS_BAD_GUID_SUM = 5,
    ZPOOL_STATUS_CORRUPT_POOL = 6,
    ZPOOL_STATUS_CORRUPT_DATA = 7,
    ZPOOL_STATUS_FAILING_DEV = 8,
    ZPOOL_STATUS_VERSION_NEWER = 9,
    ZPOOL_STATUS_HOSTID_MISMATCH = 10,
    ZPOOL_STATUS_HOSTID_ACTIVE = 11,
    ZPOOL_STATUS_HOSTID_REQUIRED = 12,
    ZPOOL_STATUS_IO_FAILURE_WAIT = 13,
    ZPOOL_STATUS_IO_FAILURE_CONTINUE = 14,
    ZPOOL_STATUS_BAD_LOG = 15,
    ZPOOL_STATUS_ERRATA = 16,
    ZPOOL_STATUS_UNSUP_FEAT_READ = 17,
    ZPOOL_STATUS_UNSUP_FEAT_WRITE = 18,
    ZPOOL_STATUS_FAULTED_DEV_R = 19,
    ZPOOL_STATUS_FAULTED_DEV_NR = 20,
    ZPOOL_STATUS_VERSION_OLDER = 21,
    ZPOOL_STATUS_FEAT_DISABLED = 22,
    ZPOOL_STATUS_RESILVERING = 23,
    ZPOOL_STATUS_OFFLINE_DEV = 24,
    ZPOOL_STATUS_REMOVED_DEV = 25,
    ZPOOL_STATUS_OK = 26,
}
extern "C" {
    pub fn get_system_hostid() -> ::libc::c_ulong;
}
extern "C" {
    pub fn zpool_get_status(arg1: *mut zpool_handle_t,
                            arg2: *mut *mut ::libc::c_char,
                            arg3: *mut zpool_errata_t) -> zpool_status_t;
}
extern "C" {
    pub fn zpool_import_status(arg1: *mut nvlist_t,
                               arg2: *mut *mut ::libc::c_char,
                               arg3: *mut zpool_errata_t) -> zpool_status_t;
}
extern "C" {
    pub fn zpool_dump_ddt(dds: *const ddt_stat_t,
                          ddh: *const ddt_histogram_t);
}
extern "C" {
    pub fn zpool_get_config(arg1: *mut zpool_handle_t,
                            arg2: *mut *mut nvlist_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn zpool_get_features(arg1: *mut zpool_handle_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn zpool_refresh_stats(arg1: *mut zpool_handle_t,
                               arg2: *mut boolean_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_get_errlog(arg1: *mut zpool_handle_t,
                            arg2: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_export(arg1: *mut zpool_handle_t, arg2: boolean_t,
                        arg3: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_export_force(arg1: *mut zpool_handle_t,
                              arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_import(arg1: *mut libzfs_handle_t, arg2: *mut nvlist_t,
                        arg3: *const ::libc::c_char,
                        altroot: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_import_props(arg1: *mut libzfs_handle_t, arg2: *mut nvlist_t,
                              arg3: *const ::libc::c_char,
                              arg4: *mut nvlist_t, arg5: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_print_unsup_feat(config: *mut nvlist_t);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct importargs {
    pub path: *mut *mut ::libc::c_char,
    pub paths: ::libc::c_int,
    pub poolname: *mut ::libc::c_char,
    pub guid: u64,
    pub cachefile: *mut ::libc::c_char,
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_importargs() {
    assert_eq!(::core::mem::size_of::<importargs>() , 48usize , concat ! (
               "Size of: " , stringify ! ( importargs ) ));
    assert_eq! (::core::mem::align_of::<importargs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( importargs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const importargs ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( importargs ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const importargs ) ) . paths as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( importargs ) , "::" ,
                stringify ! ( paths ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const importargs ) ) . poolname as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( importargs ) , "::" ,
                stringify ! ( poolname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const importargs ) ) . guid as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( importargs ) , "::" ,
                stringify ! ( guid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const importargs ) ) . cachefile as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( importargs ) , "::" ,
                stringify ! ( cachefile ) ));
}
impl Clone for importargs {
    fn clone(&self) -> Self { *self }
}
impl importargs {
    #[inline]
    pub fn can_be_active(&self) -> ::libc::c_int {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_can_be_active(&mut self, val: ::libc::c_int) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn unique(&self) -> ::libc::c_int {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_unique(&mut self, val: ::libc::c_int) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn exists(&self) -> ::libc::c_int {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_exists(&mut self, val: ::libc::c_int) {
        let mask = 4u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn scan(&self) -> ::libc::c_int {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_scan(&mut self, val: ::libc::c_int) {
        let mask = 8u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(can_be_active: ::libc::c_int, unique: ::libc::c_int,
                          exists: ::libc::c_int, scan: ::libc::c_int) -> u8 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((can_be_active as u32 as u8) << 0usize) &
                                (1u64 as u8))
                   } | ((unique as u32 as u8) << 1usize) & (2u64 as u8))
              } | ((exists as u32 as u8) << 2usize) & (4u64 as u8))
         } | ((scan as u32 as u8) << 3usize) & (8u64 as u8))
    }
}
pub type importargs_t = importargs;
extern "C" {
    pub fn zpool_search_import(arg1: *mut libzfs_handle_t,
                               arg2: *mut importargs_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn zpool_tryimport(hdl: *mut libzfs_handle_t,
                           target: *mut ::libc::c_char,
                           configp: *mut *mut nvlist_t,
                           args: *mut importargs_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_find_import(arg1: *mut libzfs_handle_t, arg2: ::libc::c_int,
                             arg3: *mut *mut ::libc::c_char) -> *mut nvlist_t;
}
extern "C" {
    pub fn zpool_find_import_cached(arg1: *mut libzfs_handle_t,
                                    arg2: *const ::libc::c_char,
                                    arg3: *mut ::libc::c_char, arg4: u64)
     -> *mut nvlist_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zfs_cmd {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "zfs_history_event_names"]
    pub static mut zfs_history_event_names: [*const ::libc::c_char; 0usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vdev_name_t {
    VDEV_NAME_PATH = 1,
    VDEV_NAME_GUID = 2,
    VDEV_NAME_FOLLOW_LINKS = 4,
    VDEV_NAME_TYPE_ID = 8,
}
extern "C" {
    pub fn zpool_vdev_name(arg1: *mut libzfs_handle_t,
                           arg2: *mut zpool_handle_t, arg3: *mut nvlist_t,
                           name_flags: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn zpool_upgrade(arg1: *mut zpool_handle_t, arg2: u64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_get_history(arg1: *mut zpool_handle_t,
                             arg2: *mut *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_history_unpack(arg1: *mut ::libc::c_char, arg2: u64,
                                arg3: *mut u64, arg4: *mut *mut *mut nvlist_t,
                                arg5: *mut uint_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_events_next(arg1: *mut libzfs_handle_t,
                             arg2: *mut *mut nvlist_t,
                             arg3: *mut ::libc::c_int, arg4: ::libc::c_uint,
                             arg5: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_events_clear(arg1: *mut libzfs_handle_t,
                              arg2: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_events_seek(arg1: *mut libzfs_handle_t, arg2: u64,
                             arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_obj_to_path(arg1: *mut zpool_handle_t, arg2: u64, arg3: u64,
                             arg4: *mut ::libc::c_char, len: usize);
}
extern "C" {
    pub fn zfs_ioctl(arg1: *mut libzfs_handle_t, arg2: ::libc::c_int,
                     arg3: *mut zfs_cmd) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_get_physpath(arg1: *mut zpool_handle_t,
                              arg2: *mut ::libc::c_char, arg3: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_explain_recover(arg1: *mut libzfs_handle_t,
                                 arg2: *const ::libc::c_char,
                                 arg3: ::libc::c_int, arg4: *mut nvlist_t);
}
extern "C" {
    pub fn zfs_open(arg1: *mut libzfs_handle_t, arg2: *const ::libc::c_char,
                    arg3: ::libc::c_int) -> *mut zfs_handle_t;
}
extern "C" {
    pub fn zfs_handle_dup(arg1: *mut zfs_handle_t) -> *mut zfs_handle_t;
}
extern "C" {
    pub fn zfs_close(arg1: *mut zfs_handle_t);
}
extern "C" {
    pub fn zfs_get_type(arg1: *const zfs_handle_t) -> zfs_type_t;
}
extern "C" {
    pub fn zfs_get_name(arg1: *const zfs_handle_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_get_pool_handle(arg1: *const zfs_handle_t)
     -> *mut zpool_handle_t;
}
extern "C" {
    pub fn zfs_get_pool_name(arg1: *const zfs_handle_t)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_prop_column_name(arg1: zfs_prop_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_prop_align_right(arg1: zfs_prop_t) -> boolean_t;
}
extern "C" {
    pub fn zfs_valid_proplist(arg1: *mut libzfs_handle_t, arg2: zfs_type_t,
                              arg3: *mut nvlist_t, arg4: u64,
                              arg5: *mut zfs_handle_t,
                              arg6: *mut zpool_handle_t,
                              arg7: *const ::libc::c_char) -> *mut nvlist_t;
}
extern "C" {
    pub fn zfs_prop_set(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                        arg3: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_set_list(arg1: *mut zfs_handle_t, arg2: *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get(arg1: *mut zfs_handle_t, arg2: zfs_prop_t,
                        arg3: *mut ::libc::c_char, arg4: usize,
                        arg5: *mut zprop_source_t, arg6: *mut ::libc::c_char,
                        arg7: usize, arg8: boolean_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_recvd(arg1: *mut zfs_handle_t,
                              arg2: *const ::libc::c_char,
                              arg3: *mut ::libc::c_char, arg4: usize,
                              arg5: boolean_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_numeric(arg1: *mut zfs_handle_t, arg2: zfs_prop_t,
                                arg3: *mut u64, arg4: *mut zprop_source_t,
                                arg5: *mut ::libc::c_char, arg6: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_userquota_int(zhp: *mut zfs_handle_t,
                                      propname: *const ::libc::c_char,
                                      propvalue: *mut u64) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_userquota(zhp: *mut zfs_handle_t,
                                  propname: *const ::libc::c_char,
                                  propbuf: *mut ::libc::c_char,
                                  proplen: ::libc::c_int, literal: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_written_int(zhp: *mut zfs_handle_t,
                                    propname: *const ::libc::c_char,
                                    propvalue: *mut u64) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_written(zhp: *mut zfs_handle_t,
                                propname: *const ::libc::c_char,
                                propbuf: *mut ::libc::c_char,
                                proplen: ::libc::c_int, literal: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_get_feature(zhp: *mut zfs_handle_t,
                                propname: *const ::libc::c_char,
                                buf: *mut ::libc::c_char, len: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn getprop_uint64(arg1: *mut zfs_handle_t, arg2: zfs_prop_t,
                          arg3: *mut *mut ::libc::c_char) -> u64;
}
extern "C" {
    pub fn zfs_prop_get_int(arg1: *mut zfs_handle_t, arg2: zfs_prop_t) -> u64;
}
extern "C" {
    pub fn zfs_prop_inherit(arg1: *mut zfs_handle_t,
                            arg2: *const ::libc::c_char, arg3: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prop_values(arg1: zfs_prop_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_prop_is_string(prop: zfs_prop_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_get_user_props(arg1: *mut zfs_handle_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn zfs_get_recvd_props(arg1: *mut zfs_handle_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn zfs_get_clones_nvl(arg1: *mut zfs_handle_t) -> *mut nvlist_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct zprop_list {
    pub pl_prop: ::libc::c_int,
    pub pl_user_prop: *mut ::libc::c_char,
    pub pl_next: *mut zprop_list,
    pub pl_all: boolean_t,
    pub pl_width: usize,
    pub pl_recvd_width: usize,
    pub pl_fixed: boolean_t,
}
#[test]
fn bindgen_test_layout_zprop_list() {
    assert_eq!(::core::mem::size_of::<zprop_list>() , 56usize , concat ! (
               "Size of: " , stringify ! ( zprop_list ) ));
    assert_eq! (::core::mem::align_of::<zprop_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( zprop_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_prop as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_prop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_user_prop as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_user_prop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_next as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_all as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_all ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_width as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_recvd_width as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_recvd_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_list ) ) . pl_fixed as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_list ) , "::" ,
                stringify ! ( pl_fixed ) ));
}
impl Clone for zprop_list {
    fn clone(&self) -> Self { *self }
}
pub type zprop_list_t = zprop_list;
extern "C" {
    pub fn zfs_expand_proplist(arg1: *mut zfs_handle_t,
                               arg2: *mut *mut zprop_list_t, arg3: boolean_t,
                               arg4: boolean_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_prune_proplist(arg1: *mut zfs_handle_t, arg2: *mut u8);
}
extern "C" {
    pub fn zpool_expand_proplist(arg1: *mut zpool_handle_t,
                                 arg2: *mut *mut zprop_list_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_prop_get_feature(arg1: *mut zpool_handle_t,
                                  arg2: *const ::libc::c_char,
                                  arg3: *mut ::libc::c_char, arg4: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_prop_column_name(arg1: zpool_prop_t)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn zpool_prop_align_right(arg1: zpool_prop_t) -> boolean_t;
}
extern "C" {
    pub fn zprop_iter(func: zprop_func, cb: *mut ::libc::c_void,
                      show_all: boolean_t, ordered: boolean_t,
                      type_: zfs_type_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zprop_get_list(arg1: *mut libzfs_handle_t,
                          arg2: *mut ::libc::c_char,
                          arg3: *mut *mut zprop_list_t, arg4: zfs_type_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zprop_free_list(arg1: *mut zprop_list_t);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_get_column_t {
    GET_COL_NONE = 0,
    GET_COL_NAME = 1,
    GET_COL_PROPERTY = 2,
    GET_COL_VALUE = 3,
    GET_COL_RECVD = 4,
    GET_COL_SOURCE = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct zprop_get_cbdata {
    pub cb_sources: ::libc::c_int,
    pub cb_columns: [zfs_get_column_t; 5usize],
    pub cb_colwidths: [::libc::c_int; 6usize],
    pub cb_scripted: boolean_t,
    pub cb_literal: boolean_t,
    pub cb_first: boolean_t,
    pub cb_proplist: *mut zprop_list_t,
    pub cb_type: zfs_type_t,
}
#[test]
fn bindgen_test_layout_zprop_get_cbdata() {
    assert_eq!(::core::mem::size_of::<zprop_get_cbdata>() , 80usize , concat !
               ( "Size of: " , stringify ! ( zprop_get_cbdata ) ));
    assert_eq! (::core::mem::align_of::<zprop_get_cbdata>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( zprop_get_cbdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_sources as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_sources ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_columns as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_columns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_colwidths as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_colwidths ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_scripted as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_scripted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_literal as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_literal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_first as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_proplist as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_proplist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zprop_get_cbdata ) ) . cb_type as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( zprop_get_cbdata ) ,
                "::" , stringify ! ( cb_type ) ));
}
impl Clone for zprop_get_cbdata {
    fn clone(&self) -> Self { *self }
}
pub type zprop_get_cbdata_t = zprop_get_cbdata;
extern "C" {
    pub fn zprop_print_one_property(arg1: *const ::libc::c_char,
                                    arg2: *mut zprop_get_cbdata_t,
                                    arg3: *const ::libc::c_char,
                                    arg4: *const ::libc::c_char,
                                    arg5: zprop_source_t,
                                    arg6: *const ::libc::c_char,
                                    arg7: *const ::libc::c_char);
}
pub type zfs_iter_f =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut zfs_handle_t,
                                                arg2: *mut ::libc::c_void)
                               -> ::libc::c_int>;
extern "C" {
    pub fn zfs_iter_root(arg1: *mut libzfs_handle_t, arg2: zfs_iter_f,
                         arg3: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_iter_children(arg1: *mut zfs_handle_t, arg2: zfs_iter_f,
                             arg3: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_iter_dependents(arg1: *mut zfs_handle_t, arg2: boolean_t,
                               arg3: zfs_iter_f, arg4: *mut ::libc::c_void)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_iter_filesystems(arg1: *mut zfs_handle_t, arg2: zfs_iter_f,
                                arg3: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_iter_snapshots(arg1: *mut zfs_handle_t, arg2: boolean_t,
                              arg3: zfs_iter_f, arg4: *mut ::libc::c_void)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_iter_snapshots_sorted(arg1: *mut zfs_handle_t,
                                     arg2: zfs_iter_f,
                                     arg3: *mut ::libc::c_void)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_iter_snapspec(arg1: *mut zfs_handle_t,
                             arg2: *const ::libc::c_char, arg3: zfs_iter_f,
                             arg4: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_iter_bookmarks(arg1: *mut zfs_handle_t, arg2: zfs_iter_f,
                              arg3: *mut ::libc::c_void) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct get_all_cb {
    pub cb_handles: *mut *mut zfs_handle_t,
    pub cb_alloc: usize,
    pub cb_used: usize,
    pub cb_verbose: boolean_t,
    pub cb_getone: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut zfs_handle_t,
                                                               arg2:
                                                                   *mut ::libc::c_void)
                                              -> ::libc::c_int>,
}
#[test]
fn bindgen_test_layout_get_all_cb() {
    assert_eq!(::core::mem::size_of::<get_all_cb>() , 40usize , concat ! (
               "Size of: " , stringify ! ( get_all_cb ) ));
    assert_eq! (::core::mem::align_of::<get_all_cb>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( get_all_cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const get_all_cb ) ) . cb_handles as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( get_all_cb ) , "::" ,
                stringify ! ( cb_handles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const get_all_cb ) ) . cb_alloc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( get_all_cb ) , "::" ,
                stringify ! ( cb_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const get_all_cb ) ) . cb_used as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( get_all_cb ) , "::" ,
                stringify ! ( cb_used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const get_all_cb ) ) . cb_verbose as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( get_all_cb ) , "::" ,
                stringify ! ( cb_verbose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const get_all_cb ) ) . cb_getone as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( get_all_cb ) , "::" ,
                stringify ! ( cb_getone ) ));
}
impl Clone for get_all_cb {
    fn clone(&self) -> Self { *self }
}
pub type get_all_cb_t = get_all_cb;
extern "C" {
    pub fn libzfs_add_handle(arg1: *mut get_all_cb_t,
                             arg2: *mut zfs_handle_t);
}
extern "C" {
    pub fn libzfs_dataset_cmp(arg1: *const ::libc::c_void,
                              arg2: *const ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_create(arg1: *mut libzfs_handle_t, arg2: *const ::libc::c_char,
                      arg3: zfs_type_t, arg4: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_create_ancestors(arg1: *mut libzfs_handle_t,
                                arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_destroy(arg1: *mut zfs_handle_t, arg2: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_destroy_snaps(arg1: *mut zfs_handle_t,
                             arg2: *mut ::libc::c_char, arg3: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_destroy_snaps_nvl(arg1: *mut libzfs_handle_t,
                                 arg2: *mut nvlist_t, arg3: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_clone(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                     arg3: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_snapshot(arg1: *mut libzfs_handle_t,
                        arg2: *const ::libc::c_char, arg3: boolean_t,
                        arg4: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_snapshot_nvl(hdl: *mut libzfs_handle_t, snaps: *mut nvlist_t,
                            props: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_rollback(arg1: *mut zfs_handle_t, arg2: *mut zfs_handle_t,
                        arg3: boolean_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_rename(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                      arg3: boolean_t, arg4: boolean_t) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sendflags {
    pub verbose: boolean_t,
    pub replicate: boolean_t,
    pub doall: boolean_t,
    pub fromorigin: boolean_t,
    pub dedup: boolean_t,
    pub props: boolean_t,
    pub dryrun: boolean_t,
    pub parsable: boolean_t,
    pub progress: boolean_t,
    pub largeblock: boolean_t,
    pub embed_data: boolean_t,
    pub compress: boolean_t,
}
#[test]
fn bindgen_test_layout_sendflags() {
    assert_eq!(::core::mem::size_of::<sendflags>() , 48usize , concat ! (
               "Size of: " , stringify ! ( sendflags ) ));
    assert_eq! (::core::mem::align_of::<sendflags>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sendflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . verbose as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( verbose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . replicate as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( replicate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . doall as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( doall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . fromorigin as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( fromorigin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . dedup as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( dedup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . props as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( props ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . dryrun as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( dryrun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . parsable as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( parsable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . progress as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( progress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . largeblock as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( largeblock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . embed_data as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( embed_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sendflags ) ) . compress as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( sendflags ) , "::" ,
                stringify ! ( compress ) ));
}
impl Clone for sendflags {
    fn clone(&self) -> Self { *self }
}
pub type sendflags_t = sendflags;
pub type snapfilter_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut zfs_handle_t,
                                                arg2: *mut ::libc::c_void)
                               -> boolean_t>;
extern "C" {
    pub fn zfs_send(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                    arg3: *const ::libc::c_char, arg4: *mut sendflags_t,
                    arg5: ::libc::c_int, arg6: snapfilter_cb_t,
                    arg7: *mut ::libc::c_void, arg8: *mut *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_send_one(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                        arg3: ::libc::c_int, arg4: lzc_send_flags)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_send_resume(arg1: *mut libzfs_handle_t, arg2: *mut sendflags_t,
                           outfd: ::libc::c_int, arg3: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_send_resume_token_to_nvlist(hdl: *mut libzfs_handle_t,
                                           token: *const ::libc::c_char)
     -> *mut nvlist_t;
}
extern "C" {
    pub fn zfs_promote(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_hold(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                    arg3: *const ::libc::c_char, arg4: boolean_t,
                    arg5: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_hold_nvl(arg1: *mut zfs_handle_t, arg2: ::libc::c_int,
                        arg3: *mut nvlist_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_release(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                       arg3: *const ::libc::c_char, arg4: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_get_holds(arg1: *mut zfs_handle_t, arg2: *mut *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zvol_volsize_to_reservation(arg1: u64, arg2: *mut nvlist_t) -> u64;
}
pub type zfs_userspace_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::libc::c_void,
                                                domain: *const ::libc::c_char,
                                                rid: uid_t, space: u64)
                               -> ::libc::c_int>;
extern "C" {
    pub fn zfs_userspace(arg1: *mut zfs_handle_t, arg2: zfs_userquota_prop_t,
                         arg3: zfs_userspace_cb_t, arg4: *mut ::libc::c_void)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_get_fsacl(arg1: *mut zfs_handle_t, arg2: *mut *mut nvlist_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_set_fsacl(arg1: *mut zfs_handle_t, arg2: boolean_t,
                         arg3: *mut nvlist_t) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct recvflags {
    pub verbose: boolean_t,
    pub isprefix: boolean_t,
    pub istail: boolean_t,
    pub dryrun: boolean_t,
    pub force: boolean_t,
    pub canmountoff: boolean_t,
    pub resumable: boolean_t,
    pub byteswap: boolean_t,
    pub nomount: boolean_t,
}
#[test]
fn bindgen_test_layout_recvflags() {
    assert_eq!(::core::mem::size_of::<recvflags>() , 36usize , concat ! (
               "Size of: " , stringify ! ( recvflags ) ));
    assert_eq! (::core::mem::align_of::<recvflags>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( recvflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . verbose as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( verbose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . isprefix as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( isprefix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . istail as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( istail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . dryrun as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( dryrun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . force as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( force ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . canmountoff as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( canmountoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . resumable as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( resumable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . byteswap as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( byteswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const recvflags ) ) . nomount as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( recvflags ) , "::" ,
                stringify ! ( nomount ) ));
}
impl Clone for recvflags {
    fn clone(&self) -> Self { *self }
}
pub type recvflags_t = recvflags;
extern "C" {
    pub fn zfs_receive(arg1: *mut libzfs_handle_t,
                       arg2: *const ::libc::c_char, arg3: *mut nvlist_t,
                       arg4: *mut recvflags_t, arg5: ::libc::c_int,
                       arg6: *mut avl_tree_t) -> ::libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum diff_flags {
    ZFS_DIFF_PARSEABLE = 1,
    ZFS_DIFF_TIMESTAMP = 2,
    ZFS_DIFF_CLASSIFY = 4,
}
pub use self::diff_flags as diff_flags_t;
extern "C" {
    pub fn zfs_show_diffs(arg1: *mut zfs_handle_t, arg2: ::libc::c_int,
                          arg3: *const ::libc::c_char,
                          arg4: *const ::libc::c_char, arg5: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_type_to_name(arg1: zfs_type_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn zfs_refresh_properties(arg1: *mut zfs_handle_t);
}
extern "C" {
    pub fn zfs_name_valid(arg1: *const ::libc::c_char, arg2: zfs_type_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_path_to_zhandle(arg1: *mut libzfs_handle_t,
                               arg2: *mut ::libc::c_char, arg3: zfs_type_t)
     -> *mut zfs_handle_t;
}
extern "C" {
    pub fn zfs_dataset_exists(arg1: *mut libzfs_handle_t,
                              arg2: *const ::libc::c_char, arg3: zfs_type_t)
     -> boolean_t;
}
extern "C" {
    pub fn zfs_spa_version(arg1: *mut zfs_handle_t, arg2: *mut ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_bookmark_exists(path: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_append_partition(path: *mut ::libc::c_char, max_len: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_resolve_shortname(name: *const ::libc::c_char,
                                 path: *mut ::libc::c_char, pathlen: usize)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_strcmp_pathname(name: *mut ::libc::c_char,
                               cmp_name: *mut ::libc::c_char,
                               wholedisk: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_path_order(path: *mut ::libc::c_char,
                          order: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn is_mounted(arg1: *mut libzfs_handle_t,
                      special: *const ::libc::c_char,
                      arg2: *mut *mut ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_is_mounted(arg1: *mut zfs_handle_t,
                          arg2: *mut *mut ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_mount(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                     arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unmount(arg1: *mut zfs_handle_t, arg2: *const ::libc::c_char,
                       arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unmountall(arg1: *mut zfs_handle_t, arg2: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_is_shared(arg1: *mut zfs_handle_t) -> boolean_t;
}
extern "C" {
    pub fn zfs_share(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshare(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_is_shared_nfs(arg1: *mut zfs_handle_t,
                             arg2: *mut *mut ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_is_shared_smb(arg1: *mut zfs_handle_t,
                             arg2: *mut *mut ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zfs_share_nfs(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_share_smb(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_shareall(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshare_nfs(arg1: *mut zfs_handle_t,
                           arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshare_smb(arg1: *mut zfs_handle_t,
                           arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshareall_nfs(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshareall_smb(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshareall_bypath(arg1: *mut zfs_handle_t,
                                 arg2: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshareall_bytype(arg1: *mut zfs_handle_t,
                                 arg2: *const ::libc::c_char,
                                 arg3: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_unshareall(arg1: *mut zfs_handle_t) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_deleg_share_nfs(arg1: *mut libzfs_handle_t,
                               arg2: *mut ::libc::c_char,
                               arg3: *mut ::libc::c_char,
                               arg4: *mut ::libc::c_char,
                               arg5: *mut ::libc::c_void,
                               arg6: *mut ::libc::c_void, arg7: ::libc::c_int,
                               arg8: zfs_share_op_t) -> ::libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zfs_nicenum_format {
    ZFS_NICENUM_1024 = 0,
    ZFS_NICENUM_BYTES = 1,
    ZFS_NICENUM_TIME = 2,
    ZFS_NICENUM_RAW = 3,
    ZFS_NICENUM_RAWTIME = 4,
}
extern "C" {
    pub fn zfs_nicenum(arg1: u64, arg2: *mut ::libc::c_char, arg3: usize);
}
extern "C" {
    pub fn zfs_nicenum_format(num: u64, buf: *mut ::libc::c_char,
                              buflen: usize, type_: zfs_nicenum_format);
}
extern "C" {
    pub fn zfs_nicetime(arg1: u64, arg2: *mut ::libc::c_char, arg3: usize);
}
extern "C" {
    pub fn zfs_nicebytes(arg1: u64, arg2: *mut ::libc::c_char, arg3: usize);
}
extern "C" {
    pub fn zfs_nicestrtonum(arg1: *mut libzfs_handle_t,
                            arg2: *const ::libc::c_char, arg3: *mut u64)
     -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_run_process(arg1: *const ::libc::c_char,
                              arg2: *mut *mut ::libc::c_char,
                              flags: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_run_process_get_stdout(path: *const ::libc::c_char,
                                         argv: *mut *mut ::libc::c_char,
                                         env: *mut *mut ::libc::c_char,
                                         lines: *mut *mut *mut ::libc::c_char,
                                         lines_cnt: *mut ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_run_process_get_stdout_nopath(path: *const ::libc::c_char,
                                                argv:
                                                    *mut *mut ::libc::c_char,
                                                env: *mut *mut ::libc::c_char,
                                                lines:
                                                    *mut *mut *mut ::libc::c_char,
                                                lines_cnt: *mut ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_free_str_array(strs: *mut *mut ::libc::c_char,
                                 count: ::libc::c_int);
}
extern "C" {
    pub fn libzfs_envvar_is_set(envvar: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_in_use(arg1: *mut libzfs_handle_t, arg2: ::libc::c_int,
                        arg3: *mut pool_state_t,
                        arg4: *mut *mut ::libc::c_char, arg5: *mut boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_read_label(arg1: ::libc::c_int, arg2: *mut *mut nvlist_t,
                            arg3: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_clear_label(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_smb_acl_add(arg1: *mut libzfs_handle_t,
                           arg2: *mut ::libc::c_char,
                           arg3: *mut ::libc::c_char,
                           arg4: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_smb_acl_remove(arg1: *mut libzfs_handle_t,
                              arg2: *mut ::libc::c_char,
                              arg3: *mut ::libc::c_char,
                              arg4: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_smb_acl_purge(arg1: *mut libzfs_handle_t,
                             arg2: *mut ::libc::c_char,
                             arg3: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zfs_smb_acl_rename(arg1: *mut libzfs_handle_t,
                              arg2: *mut ::libc::c_char,
                              arg3: *mut ::libc::c_char,
                              arg4: *mut ::libc::c_char,
                              arg5: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_enable_datasets(arg1: *mut zpool_handle_t,
                                 arg2: *const ::libc::c_char,
                                 arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn zpool_disable_datasets(arg1: *mut zpool_handle_t, arg2: boolean_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn libzfs_fru_refresh(arg1: *mut libzfs_handle_t);
}
extern "C" {
    pub fn libzfs_fru_lookup(arg1: *mut libzfs_handle_t,
                             arg2: *const ::libc::c_char)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn libzfs_fru_devpath(arg1: *mut libzfs_handle_t,
                              arg2: *const ::libc::c_char)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn libzfs_fru_compare(arg1: *mut libzfs_handle_t,
                              arg2: *const ::libc::c_char,
                              arg3: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn libzfs_fru_notself(arg1: *mut libzfs_handle_t,
                              arg2: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn zpool_fru_set(arg1: *mut zpool_handle_t, arg2: u64,
                         arg3: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn is_mpath_whole_disk(arg1: *const ::libc::c_char) -> boolean_t;
}
extern "C" {
    pub fn update_vdev_config_dev_strs(arg1: *mut nvlist_t);
}
extern "C" {
    pub fn zfs_strip_partition(arg1: *mut ::libc::c_char)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn zfs_strip_partition_path(arg1: *mut ::libc::c_char)
     -> *mut ::libc::c_char;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::libc::c_uint,
    pub fp_offset: ::libc::c_uint,
    pub overflow_arg_area: *mut ::libc::c_void,
    pub reg_save_area: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::core::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::core::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
